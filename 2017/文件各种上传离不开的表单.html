<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>文件各种上传，离不开的表单 | Java面试</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="文件各种上传，离不开的表单" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="文件各种上传，离不开的表单" />
<meta property="og:description" content="文件各种上传，离不开的表单" />
<link rel="canonical" href="http://www.jfox.info/2017/%E6%96%87%E4%BB%B6%E5%90%84%E7%A7%8D%E4%B8%8A%E4%BC%A0%E7%A6%BB%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A1%A8%E5%8D%95.html" />
<meta property="og:url" content="http://www.jfox.info/2017/%E6%96%87%E4%BB%B6%E5%90%84%E7%A7%8D%E4%B8%8A%E4%BC%A0%E7%A6%BB%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A1%A8%E5%8D%95.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T23:58:04+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"文件各种上传，离不开的表单","dateModified":"2017-01-01T23:58:04+08:00","datePublished":"2017-01-01T23:58:04+08:00","url":"http://www.jfox.info/2017/%E6%96%87%E4%BB%B6%E5%90%84%E7%A7%8D%E4%B8%8A%E4%BC%A0%E7%A6%BB%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A1%A8%E5%8D%95.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/%E6%96%87%E4%BB%B6%E5%90%84%E7%A7%8D%E4%B8%8A%E4%BC%A0%E7%A6%BB%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A1%A8%E5%8D%95.html"},"description":"文件各种上传，离不开的表单","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">文件各种上传，离不开的表单</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T23:58:04+08:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<h1 id="文件各种上传离不开的表单">文件各种上传，离不开的表单</h1>

<p>作为程序员的我们，经常会要用到文件的上传和下载功能。到了需要用的时候，各种查资料。有木有..有木有…。为了方便下次使用，这里来做个总结和备忘。</p>

<h1 id="利用表单实现文件上传">利用表单实现文件上传</h1>

<p>最原始、最简单、最粗暴的文件上传。
前端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//方式1
&lt;form action="/Home/SaveFile1" method="post" enctype="multipart/form-data"&gt;
     &lt;input type="file" class="file1" name="file1" /&gt;
     &lt;button type="submit" class="but1"&gt;上传&lt;/button&gt;
&lt;/form&gt;
</code></pre></div></div>

<p><strong>【注意】</strong></p>

<ul>
  <li>1、需要post提交</li>
  <li>2、enctype=”multipart/form-data” （传输文件）</li>
  <li>3、需要提交的表单元素需要设置 name 属性</li>
</ul>

<p>后台代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public ActionResult SaveFile1()
{
    if (Request.Files.Count &gt; 0)
    {
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Request.Files[0].FileName);
        return Content("保存成功");
    }
    return Content("没有读到文件");
}
</code></pre></div></div>

<h1 id="表单异步上传jqueryform插件">表单异步上传（jquery.form插件）</h1>

<p>虽然上面的方式简单粗暴，但是不够友好。页面必然会刷新。难以实现停留在当前页面，并给出文件上传成功的提示。
随着时间的流逝，技术日新月异。ajax的出现，使得异步文件提交变得更加容易。
下面我们利用jquery.form插件来实现文件的异步上传。
首先我们需要导入<code class="highlighter-rouge">jquery.js</code>和<code class="highlighter-rouge">jquery.form.js</code>
前端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;form id="form2" action="/Home/SaveFile2" method="post" enctype="multipart/form-data"&gt;
    &lt;input type="file" class="file1" name="file1" /&gt;
    &lt;button type="submit" class="but1"&gt;上传1&lt;/button&gt;
    &lt;button type="button" class="but2"&gt;上传2&lt;/button&gt;
&lt;/form&gt;


//方式2（通过ajaxForm绑定ajax操作）
$(function () {
    $('#form2').ajaxForm({
        success: function (responseText) {
            alert(responseText);
        }
    });
});

//方式3（通过ajaxSubmit直接执行ajax操作）
$(function () {
    $(".but2").click(function () {
        $('#form2').ajaxSubmit({
            success: function (responseText) {
                alert(responseText);
            }
        });
    });
});
</code></pre></div></div>

<p>后台代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string SaveFile2()
{
    if (Request.Files.Count &gt; 0)
    {                
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
</code></pre></div></div>

<p>原理：
我们很多时候使用了插件，就不管其他三七二十一呢。
如果有点好奇心，想想这个插件是怎么实现的。随便看了看源码一千五百多行。我的妈呀，不就是个异步上传吗，怎么这么复杂。
难以看出个什么鬼来，直接断点调试下吧。
<img src="cc6d88e.png" alt="" />
原来插件内部有iframe和FormData不同方式来上传，来适应更多版本浏览器。</p>

<h1 id="模拟表单数据上传formdata">模拟表单数据上传（FormData）</h1>

<p>iframe这东西太恶心。我们看到上面可以利用FormData来上传文件，这个是Html 5 才有的。下面我们自己也来试试把。
前端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;input id="fileinfo" type="file" class="notFormFile" /&gt;
&lt;button type="button" class="btnNotForm"&gt;上传4&lt;/button&gt;

//方式4
$(".btnNotForm").click(function () {
    var formData = new FormData();//初始化一个FormData对象
    formData.append("files", $(".notFormFile")[0].files[0]);//将文件塞入FormData
    $.ajax({
        url: "/Home/SaveFile2",
        type: "POST",
        data: formData,
        processData: false,  // 告诉jQuery不要去处理发送的数据
        contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
        success: function (responseText) {
            alert(responseText);
        }
    });
});
</code></pre></div></div>

<p>后的代码：（不变，还是上例代码）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string SaveFile2()
{
    if (Request.Files.Count &gt; 0)
    {                
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
</code></pre></div></div>

<p>我们看到，FormData对象也只是在模拟一个原始的表单格式的数据。那有没有可能不利用表单或表单格式来上传文件呢？答案是肯定的。（下面马上揭晓）
前端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;input type="file"  id="file5" multiple&gt;
&lt;button type="button" class="btnFile5"&gt;上传5&lt;/button&gt;    


//方式5
$(".btnFile5").click(function () {
    $.ajax({
        url: "/Home/SaveFile4",
        type: "POST",
        data: $("#file5")[0].files[0],
        processData: false,  // 告诉jQuery不要去处理发送的数据
        contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
        success: function (responseText) {
            alert(responseText);
        }
    });;       
});       
</code></pre></div></div>

<p>后台代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string SaveFile4()
{
    //这里发现只能得到一个网络流，没有其他信息了。（比如，文件大小、文件格式、文件名等）
    Request.SaveAs(Server.MapPath("~/App_Data/SaveFile4.data") + "", false);
    return "保存成功";
}
</code></pre></div></div>

<p>细心的你发现没有了表单格式，我们除了可以上传文件流数据外，不能再告诉后台其他信息了（如文件格式）。
到这里，我似乎明白了以前上传文件为什么非得要用个form包起来，原来这只是和后台约定的一个传输格式而已。
其实我们单纯的用jq的ajax传输文本数据的时候，最后也是组装成了form格式的数据，如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> $.ajax({
    data: { "userName": "张三" } 
</code></pre></div></div>

<h1 id="分片上传">分片上传</h1>

<p>在知道了上面的各种上传之后，我们是不是就满于现状了呢？no，很多时候我们需要传输大文件，一般服务器都会有一定的大小限制。
某天，你发现了一个激情小电影想要分享个大家。无奈，高清文件太大传不了，怎么办？我们可以化整为零，一部分一部分的传嘛，也就是所谓的分片上传。
前端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;input type="file" id="file6" multiple&gt;
&lt;button type="button" class="btnFile6"&gt;分片上传6&lt;/button&gt;
&lt;div class="result"&gt;&lt;/div&gt;


//方式6
 $(".btnFile6").click(function () { 
     var upload = function (file, skip) {
         var formData = new FormData();//初始化一个FormData对象
         var blockSize = 1000000;//每块的大小
         var nextSize = Math.min((skip + 1) * blockSize, file.size);//读取到结束位置             
         var fileData = file.slice(skip * blockSize, nextSize);//截取 部分文件 块
         formData.append("file", fileData);//将 部分文件 塞入FormData
         formData.append("fileName", file.name);//保存文件名字
         $.ajax({
             url: "/Home/SaveFile6",
             type: "POST",
             data: formData,
             processData: false,  // 告诉jQuery不要去处理发送的数据
             contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
             success: function (responseText) {
                 $(".result").html("已经上传了" + (skip + 1) + "块文件");
                 if (file.size &lt;= nextSize) {//如果上传完成，则跳出继续上传
                     alert("上传完成");
                     return;
                 }
                 upload(file, ++skip);//递归调用
             }
         });
     };

     var file = $("#file6")[0].files[0];
     upload(file, 0);
 }); 
</code></pre></div></div>

<p>后台代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string SaveFile6()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Request.Form["fileName"];
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }
    return "保存成功";
}
</code></pre></div></div>

<p>相对而言，代码量多了一点，复杂了一点。不过相对于网上的其他分片上传的代码应该要简单得多（因为这里没有考虑多文件块同时上传、断点续传。那样就需要在后台把文件块排序，然后上传完成按序合并，然后删除原来的临时文件。有兴趣的同学可以自己试试，稍候在分析上传插件webuploader的时候也会实现）。
效果图：
<img src="2feb2e9.gif" alt="" />
【说明】：如果我们想要上传多个文件怎么办？其实H5中也提供了非常简单的方式。直接在<code class="highlighter-rouge">input</code>里面标记<code class="highlighter-rouge">multiple</code>，<code class="highlighter-rouge">&lt;input type="file" id="file6" multiple&gt;</code>，然后我们后台接收的也是一个数组<code class="highlighter-rouge">Request.Files</code>。</p>

<h1 id="使用html5-拖拽粘贴上传">使用HTML5 拖拽、粘贴上传</h1>

<p>只能说H5真是强大啊，权限越来越大，操作越来越牛逼。
前端代码（拖拽上传）：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;textarea class="divFile7" style="min-width:800px;height:150px" placeholder="请将文件拖拽或直接粘贴到这里"&gt;&lt;/textarea&gt;

//方式7
 $(".divFile7")[0].ondrop = function (event) {

     event.preventDefault();//不要执行与事件关联的默认动作
     var files = event.dataTransfer.files;//获取拖上来的文件

     //以下代码不变
     var formData = new FormData();//初始化一个FormData对象
     formData.append("files", files[0]);//将文件塞入FormData
     $.ajax({
         url: "/Home/SaveFile2",
         type: "POST",
         data: formData,
         processData: false,  // 告诉jQuery不要去处理发送的数据
         contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
         success: function (responseText) {
             alert(responseText);
         }
     });
 };
</code></pre></div></div>

<p>后台代码：
略（和之前的SaveFile2一样）</p>

<p>前端代码（粘贴上传 限图片格式）：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//方式8
$(".divFile7")[0].onpaste = function (event) {
    event.preventDefault();//不要执行与事件关联的默认动作
    var clipboard = event.clipboardData.items[0];//剪贴板数据
    if (clipboard.kind == 'file' || clipboard.type.indexOf('image') &gt; -1) {//判断是图片格式
        var imageFile = clipboard.getAsFile();//获取文件

        //以下代码不变
        var formData = new FormData;
        formData.append('files', imageFile);
        formData.append('fileName', "temp.png");//这里给文件命个名（或者直接在后台保存的时候命名）
        $.ajax({
            url: "/Home/SaveFile8",
            type: "POST",
            data: formData,
            processData: false,  // 告诉jQuery不要去处理发送的数据
            contentType: false,   // 告诉jQuery不要去设置Content-Type请求头
            success: function (responseText) {
                alert(responseText);
            }
        });
    }
};
</code></pre></div></div>

<p>后台代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string SaveFile8()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Request.Form["fileName"];      
    if (Request.Files.Count &gt; 0)
    {
        Request.Files[0].SaveAs(filePath);
        return "保存成功";
    }
    return "没有读到文件";
}
</code></pre></div></div>

<p>效果图：
<img src="8fae50f.gif" alt="" /></p>

<h1 id="上传插件webuploader">上传插件（WebUploader）</h1>

<p>已经列举分析了多种上传文件的方式，我想总有一种适合你。不过，上传这个功能比较通用，而我们自己写的可能好多情况没有考虑到。接下来简单介绍下百度的WebUploader插件。
比起我们自己写的简单上传，它的优势：稳定、兼容性好（有flash切换，所以支持IE）、功能多、并发上传、断点续传（主要还是靠后台配合）。
官网：<a href="https://www.jfox.info/go.php?url=http://fex.baidu.com/webuploader/">http://fex.baidu.com/webuploader/</a>
插件下载：<a href="https://www.jfox.info/go.php?url=https://github.com/fex-team/webuploader/releases/download/0.1.5/webuploader-0.1.5.zip">https://github.com/fex-team/webuploader/releases/download/0.1.5/webuploader-0.1.5.zip</a>
下面开始对WebUploader的使用
第一种，简单粗暴
前端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;div id="picker"&gt;选择文件&lt;/div&gt;
&lt;button id="ctlBtn" class="btn btn-default"&gt;开始上传&lt;/button&gt;


&lt;!--引用webuploader的js和css--&gt;
&lt;link href="~/Scripts/webuploader-0.1.5/webuploader.css" rel="stylesheet" /&gt;
&lt;script src="~/Scripts/webuploader-0.1.5/webuploader.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
    var uploader = WebUploader.create({

        // (如果是新浏览器 可以不用 flash)
        //swf: '/Scripts/webuploader-0.1.5/Uploader.swf',

        // 文件接收服务端。
        server: '/Webuploader/SaveFile',

        // 选择文件的按钮。可选。
        // 内部根据当前运行是创建，可能是input元素，也可能是flash.
        pick: '#picker'
    });

    $("#ctlBtn").click(function () {
        uploader.upload();
    });

    uploader.on('uploadSuccess', function (file) {
        alert("上传成功");
    });

&lt;/script&gt;
</code></pre></div></div>

<p>后台代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string SaveFile()
{
    if (Request.Files.Count &gt; 0)
    {
        Request.Files[0].SaveAs(Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName));
        return "保存成功";
    }
    return "没有读到文件";
}
</code></pre></div></div>

<p>第二种，分片上传。和我们之前自己写的效果差不多。
前端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>var uploader = WebUploader.create({ 
    //兼容老版本IE
    swf: '/Scripts/webuploader-0.1.5/Uploader.swf', 
    // 文件接收服务端。
    server: '/Webuploader/SveFile2', 
    // 开起分片上传。
    chunked: true, 
    //分片大小
    chunkSize: 1000000, 
    //上传并发数
    threads: 1,
    // 选择文件的按钮。 
    pick: '#picker'
});

// 点击触发上传
$("#ctlBtn").click(function () {
    uploader.upload();
});

uploader.on('uploadSuccess', function (file) {
    alert("上传成功");
});
</code></pre></div></div>

<p>后台代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string SveFile2()
{
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = Server.MapPath("~/App_Data/") + Path.GetFileName(Request.Files[0].FileName);
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }
    return "保存成功";
}
</code></pre></div></div>

<p>我们看到了有个参数<code class="highlighter-rouge">threads: 1</code>上传并发数，如果我们改成大于1会怎样？前端会同时发起多个文件片上传。后台就会报错，多个进程同时操作一个文件。
那如果我们想要多线程上传怎么办？改代码吧（主要是后台逻辑）。
前端代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//并发上传（多线程上传）
var uploader = WebUploader.create({
    //兼容老版本IE
    swf: '/Scripts/webuploader-0.1.5/Uploader.swf',
    // 文件接收服务端。
    server: '/Webuploader/SveFile3',
    // 开起分片上传。
    chunked: true,
    //分片大小
    chunkSize: 1000000,
    //上传并发数
    threads: 10,
    // 选择文件的按钮。
    pick: '#picker'
});

// 点击触发上传
$("#ctlBtn").click(function () {
    uploader.upload();
});

uploader.on('uploadSuccess', function (file) {
    //上传完成后，给后台发送一个合并文件的命令
    $.ajax({
        url: "/Webuploader/FileMerge",
        data: { "fileName": file.name },
        type: "post",
        success: function () {
            alert("上传成功");
        }
    });
});
</code></pre></div></div>

<p>后台代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public string SveFile3()
{
    var chunk = Request.Form["chunk"];//当前是第多少片 

    var path = Server.MapPath("~/App_Data/") + Path.GetFileNameWithoutExtension(Request.Files
    if (!Directory.Exists(path))//判断是否存在此路径，如果不存在则创建
    {
        Directory.CreateDirectory(path);
    }
    //保存文件到根目录 App_Data + 获取文件名称和格式
    var filePath = path + "/" + chunk;
    //创建一个追加（FileMode.Append）方式的文件流
    using (FileStream fs = new FileStream(filePath, FileMode.Append, FileAccess.Write))
    {
        using (BinaryWriter bw = new BinaryWriter(fs))
        {
            //读取文件流
            BinaryReader br = new BinaryReader(Request.Files[0].InputStream);
            //将文件留转成字节数组
            byte[] bytes = br.ReadBytes((int)Request.Files[0].InputStream.Length);
            //将字节数组追加到文件
            bw.Write(bytes);
        }
    }           
    return "保存成功";
}

/// &lt;summary&gt;
/// 合并文件
/// &lt;/summary&gt;
/// &lt;param name="path"&gt;&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
public bool FileMerge()
{
    var fileName = Request.Form["fileName"];
    var path = Server.MapPath("~/App_Data/") + Path.GetFileNameWithoutExtension(fileName);

    //这里排序一定要正确，转成数字后排序（字符串会按1 10 11排序，默认10比2小）
    foreach (var filePath in Directory.GetFiles(path).OrderBy(t =&gt; int.Parse(Path.GetFileNameWithoutExtension(t))))
    {
        using (FileStream fs = new FileStream(Server.MapPath("~/App_Data/") + fileName, FileMode.Append, FileAccess.Write))
        {
            byte[] bytes = System.IO.File.ReadAllBytes(filePath);//读取文件到字节数组
            fs.Write(bytes, 0, bytes.Length);//写入文件
        }
        System.IO.File.Delete(filePath);
    }
    Directory.Delete(path);
    return true;
}
</code></pre></div></div>

<p>到这里你以为就结束了吗？错，还有好多情况没有考虑到。如果多个用户上传的文件名字一样会怎样？如何实现断点续传？还没实现选择多个文件？不过，这里不打算继续贴代码了（再贴下去，代码量越来越多了），自己也来练习练习吧。
提供一个思路，上传前先往数据库插入一条数据。数据包含文件要存的路径、文件名（用GUID命名，防止同名文件冲突）、文件MD5（用来识别下次续传和秒传）、临时文件块存放路径、文件是否完整上传成功等信息。
然后如果我们断网后再传，首先获取文件MD5值，看数据库里面有没上传完成的文件，如果有就实现秒传。如果没有，看是不是有上传了部分的。如果有接着传，如果没有则重新传一个新的文件。</p>

<h1 id="总结">总结</h1>

<p>之前我一直很疑惑，为什么上传文件一定要用form包起来，现在算是大概明白了。
最开始在javascript还不流行时，我们就可以直接使用submit按钮提交表单数据了。表单里面可以包含文字和文件。然后随着js和ajax的流行，可以利用ajax直接异步提交部分表单数据。这里开始我就纠结了，为什么ajax可以提交自己组装的数据。那为什么不能直接提交文件呢。这里我错了，ajax提交的并不是随意的数据，最后还是组装成了表单格式（因为后台技术对表单格式数据的支持比较普及）。但是现有的技术还不能通过js组装一个文件格式的表单数据。直到H5中的FormData出现，让前端js组装一个包含文件的表单格式数据成为了可能。所以说表单只是为了满足和后台“约定”的数据格式而已。</p>

<p><strong>相关推荐</strong></p>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/%E6%96%87%E4%BB%B6%E5%90%84%E7%A7%8D%E4%B8%8A%E4%BC%A0%E7%A6%BB%E4%B8%8D%E5%BC%80%E7%9A%84%E8%A1%A8%E5%8D%95.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%B8%A6%E4%BD%A0%E6%9E%84%E5%BB%BAspringbootdocker%E7%9A%84%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8.html">&laquo; 一步步带你构建Spring Boot + Docker的单体应用</a>
  
  
  <a class="next" href="/2017/springboot%E4%BD%BF%E7%94%A8redis%E7%BC%93%E5%AD%98.html">Spring Boot 使用Redis缓存 &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
