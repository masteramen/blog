<!-- build time:Sat Oct 27 2018 21:00:23 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="用 Kotlin 进行函数式 bean 注册Spring Framework 5.0 引入了一种新的方式来注册 bean：使用 lambda 表达式作为 XML 方式或者用 @Configuration 与 @Bean 的 JavaConfig 方式的替代。 简而言之，它能够用 Supplier lambda 表达式充当 FactoryBean 来注册 Bean。例如在 Java 中你这么写：Ge"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="【译】Spring Framework 5.0 中引入 Kotlin 支持"><meta property="og:url" content="http://www.jfox.info/2017/译-spring-framework-5-0-中引入-kotlin-支持.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="用 Kotlin 进行函数式 bean 注册Spring Framework 5.0 引入了一种新的方式来注册 bean：使用 lambda 表达式作为 XML 方式或者用 @Configuration 与 @Bean 的 JavaConfig 方式的替代。 简而言之，它能够用 Supplier lambda 表达式充当 FactoryBean 来注册 Bean。例如在 Java 中你这么写：Ge"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:51:09.589Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="【译】Spring Framework 5.0 中引入 Kotlin 支持"><meta name="twitter:description" content="用 Kotlin 进行函数式 bean 注册Spring Framework 5.0 引入了一种新的方式来注册 bean：使用 lambda 表达式作为 XML 方式或者用 @Configuration 与 @Bean 的 JavaConfig 方式的替代。 简而言之，它能够用 Supplier lambda 表达式充当 FactoryBean 来注册 Bean。例如在 Java 中你这么写：Ge"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/译-spring-framework-5-0-中引入-kotlin-支持.html"><title>【译】Spring Framework 5.0 中引入 Kotlin 支持 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/译-spring-framework-5-0-中引入-kotlin-支持.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">【译】Spring Framework 5.0 中引入 Kotlin 支持</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:50:22+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="用-Kotlin-进行函数式-bean-注册"><a href="#用-Kotlin-进行函数式-bean-注册" class="headerlink" title="用 Kotlin 进行函数式 bean 注册"></a>用 Kotlin 进行函数式 bean 注册</h2><p>Spring Framework 5.0 引入了一种新的方式来注册 bean：使用 lambda 表达式作为 XML 方式或者用 <code>@Configuration</code> 与 <code>@Bean</code> 的 JavaConfig 方式的替代。 简而言之，它能够用 <code>Supplier</code> lambda 表达式充当 <code>FactoryBean</code> 来注册 Bean。</p><p>例如在 Java 中你这么写：</p><pre><code>GenericApplicationContextcontext=newGenericApplicationContext();context.registerBean(Foo.class);context.registerBean(Bar.class,()-&gt;newBar(context.getBean(Foo.class)));
</code></pre><p>而在 Kotlin 中，具体化的类型参数可以让我们简写为：</p><pre><code>valcontext=GenericApplicationContext{registerBean&lt;Foo&gt;()registerBean{Bar(it.getBean&lt;Foo&gt;()){% raw%}}}{% endraw%}
</code></pre><p><code>ApplicationContext</code> 相关的 Kotlin 扩展有 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/kotlin/org/springframework/beans/factory/BeanFactoryExtensions.kt">BeanFactoryExtensions</a>、 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-beans/src/main/kotlin/org/springframework/beans/factory/ListableBeanFactoryExtensions.kt">ListableBeanFactoryExtensions</a>、 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/context/support/GenericApplicationContextExtensions.kt">GenericApplicationContextExtensions</a> 以及 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/context/annotation/AnnotationConfigApplicationContextExtensions.kt">AnnotationConfigApplicationContextExtensions</a>。</p><h2 id="Spring-Web-函数式-API，Kotlin-的方式"><a href="#Spring-Web-函数式-API，Kotlin-的方式" class="headerlink" title="Spring Web 函数式 API，Kotlin 的方式"></a>Spring Web 函数式 API，Kotlin 的方式</h2><p>Spring Framework 5.0 附带了一个 Kotlin 路由 DSL，允许你以干净、惯用的 Kotlin 代码来利用最近宣布的 <a href="https://www.jfox.info/go.php?url=https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework">Spring 函数式 Web API</a>：</p><pre><code>{(&quot;/blog&quot;andaccept(TEXT_HTML)).route{GET(&quot;/&quot;,this@BlogController::findAllView)GET(&quot;/{slug}&quot;,this@BlogController::findOneView)}(&quot;/api/blog&quot;andaccept(APPLICATION_JSON)).route{GET(&quot;/&quot;,this@BlogController::findAll)GET(&quot;/{id}&quot;,this@BlogController::findOne){% raw%}}}{% endraw%}
</code></pre><p>感谢 Yevhenii Melnyk 的早期原型与帮助！你可以参见一个使用 <a href="https://www.jfox.info/go.php?url=https://github.com/mix-it/mixit/blob/master/src/main/kotlin/mixit/controller/BlogController.kt">函数式 web API</a> 的 Spring Boot 应用程序的具体示例，该示例在 <a href="https://www.jfox.info/go.php?url=https://github.com/mix-it/mixit/">https://github.com/mix-it/mixit/</a>。</p><h2 id="利用-Kotlin-的可空性信息"><a href="#利用-Kotlin-的可空性信息" class="headerlink" title="利用 Kotlin 的可空性信息"></a>利用 Kotlin 的可空性信息</h2><p>原本基于 <a href="https://www.jfox.info/go.php?url=https://github.com/rocketraman">Raman Gupta</a> 的社区贡献，Spring 现在利用 <a href="https://www.jfox.info/go.php?url=https://www.kotlincn.net/docs/reference/null-safety.html">Kotlin 空安全支持</a>来确定某个 HTTP 参数是否必需，而无需明确定义 <code>required</code> 属性。 这意味着 <code>@RequestParam name: String?</code> 会被视为非必需而 <code>@RequestParam name: String</code> 视为必需。 Spring Messaging 的 <code>@Header</code> 注解也支持这点。</p><p>类似地，以 <code>@Autowired</code> 或者 <code>@Inject</code> 注入的 Spring bean 使用这一信息来获悉一个 bean 是必需还是非必需。 <code>@Autowired lateinit var foo: Foo</code> 意味着在应用程序上下文中必须注册一个类型为 <code>Foo</code> 的 bean，而对于 <code>@Autowired lateinit var foo: Foo?</code> 则在这样的 bean 不存在时并不会引发错误。</p><h2 id="用于-RestTemplate-与函数式-Web-API-的扩展"><a href="#用于-RestTemplate-与函数式-Web-API-的扩展" class="headerlink" title="用于 RestTemplate 与函数式 Web API 的扩展"></a>用于 RestTemplate 与函数式 Web API 的扩展</h2><p>例如，<a href="https://www.jfox.info/go.php?url=https://www.kotlincn.net/docs/reference/inline-functions.html#%E5%85%B7%E4%BD%93%E5%8C%96%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0">Kotlin 具体化的类型参数</a>为 JVM <a href="https://www.jfox.info/go.php?url=https://docs.oracle.com/javase/tutorial/java/generics/erasure.html">泛型类型擦除</a>提供了一种解决方法，因此我们引入了一些扩展来利用这一优势尽可能提供更好的 API。</p><p>这允许为 <code>RestTemplate</code> 提供便利的 API（感谢 Netflix 的 <a href="https://www.jfox.info/go.php?url=https://github.com/jkschneider">Jon Schneider</a> 对此贡献）。 例如，要在 Java 中检索 <code>Foo</code> 对象的列表，你不得不这样写：</p><pre><code>List&lt;Foo&gt;result=restTemplate.exchange(url,HttpMethod.GET,null,newParameterizedTypeReference&lt;List&lt;Foo&gt;&gt;(){}).getBody();
</code></pre><p>或者，如果你使用一个中间的数组：</p><pre><code>List&lt;Foo&gt;result=Arrays.asList(restTemplate.getForObject(url,Foo[].class));
</code></pre><p>而用 Spring Framework 5 扩展，在 Kotlin 中，你可以这样够写：</p><pre><code>valresult:List&lt;Foo&gt;=restTemplate.getForObject(url)
</code></pre><p>Spring Framework 5.0 中提供的 Web API 的 Kotlin 扩展有 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/kotlin/org/springframework/web/client/RestOperationsExtensions.kt">RestOperationsExtensions</a>、<a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/server/ServerRequestExtensions.kt">ServerRequestExtensions</a>、 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/BodyInsertersExtensions.kt">BodyInsertersExtensions</a>、 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/BodyExtractorsExtensions.kt">BodyExtractorsExtensions</a>、<a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-web-reactive/src/main/kotlin/org/springframework/web/reactive/function/client/ClientResponseExtensions.kt">ClientResponseExtensions</a>、 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/ui/ModelExtensions.kt">ModelExtensions</a> 以及 <a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/kotlin/org/springframework/ui/ModelMapExtensions.kt">ModelMapExtensions</a>。</p><p>这些扩展还提供了支持 Kotlin 原生 <code>KClass</code> 的成员函数，允许你指定 <code>Foo::class</code> 参数而不是 <code>Foo::class.java</code>。</p><h2 id="Reactor-Kotlin-扩展"><a href="#Reactor-Kotlin-扩展" class="headerlink" title="Reactor Kotlin 扩展"></a>Reactor Kotlin 扩展</h2><p><a href="https://www.jfox.info/go.php?url=https://projectreactor.io/">Reactor</a> 是 Spring Framework 5.0 所基于的响应式基础，而在开发响应式 web 应用程序时，你会有很好的机会去使用其 <a href="https://www.jfox.info/go.php?url=https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Mono.html">Mono</a>、 <a href="https://www.jfox.info/go.php?url=https://projectreactor.io/docs/core/release/api/reactor/core/publisher/Flux.html">Flux</a> 以及 <a href="https://www.jfox.info/go.php?url=https://projectreactor.io/docs/test/release/api/reactor/test/StepVerifier.html">StepVerifier</a> API。</p><p>所以如今我们还通过新的 <a href="https://www.jfox.info/go.php?url=https://github.com/reactor/reactor-kotlin-extensions">reactor-kotlin 扩展</a> 项目在 Reactor 中引入 Kotlin 支持！ 它提供了能够通过任何类实例这样写 <code>foo.toMono()</code> 来创建 <code>Mono</code> 实例的扩展，当然很多人倾向于使用 <code>Mono.just(foo)</code>。 它也支持例如通过 <code>stream.toFlux()</code> 从 Java 8 <code>Stream</code> 实例创建 <code>Flux</code>。 还提供了 <code>Iterable</code>、 <code>CompletableFuture</code> 与 <code>Throwable</code> 扩展以及 <code>KClass</code> 基于 Reactor API 的变体。</p><p>目前该项目还在早期阶段，所以如果你发现缺了点什么，不妨<a href="https://www.jfox.info/go.php?url=https://github.com/reactor/reactor-kotlin-extensions/pulls">贡献</a>自己的扩展。</p><h2 id="不再需要将你的-bean-类声明为-open"><a href="#不再需要将你的-bean-类声明为-open" class="headerlink" title="不再需要将你的 bean 类声明为 open"></a>不再需要将你的 bean 类声明为 open</h2><p>当目前为止，当你使用 Kotlin 构建 Spring Boot 应用程序时遇到的少数痛点之一就是，需要为每个由 CGLIB 如 <code>@Configuration</code> 类代理的 Spring bean 类及其成员函数添加 <code>open</code> 关键字。 这一要求的根本原因源于 Kotlin 中<a href="https://www.jfox.info/go.php?url=https://discuss.kotlinlang.org/t/classes-final-by-default/166">类是默认 final</a> 的事实。</p><p>幸运的是，Kotlin 1.0.6 现在提供了一个 <code>kotlin-spring</code> 插件，对于由以下注解之一标注或元标注（meta-annotated）的类，会默认打开该类及其成员函数：</p><ul><li><code>@Component</code></li><li><code>@Async</code></li><li><code>@Transactional</code></li><li><code>@Cacheable</code></li></ul><p>元注解支持意味着用 <code>@Configuration</code>、 <code>@Controller</code>、 <code>@RestController</code>、 <code>@Service</code> 或者 <code>@Repository</code> 标注的类会自动打开，鉴于这些注解都已被 <code>@Component</code> 注解元标注。</p><p>我们已经更新了 <a href="https://www.jfox.info/go.php?url=http://start.spring.io/#!language=kotlin">start.spring.io</a> 默认启用了该插件。 你可以看下<a href="https://www.jfox.info/go.php?url=https://blog.jetbrains.com/kotlin/2016/12/kotlin-1-0-6-is-here/">这篇 Kotlin 1.0.6 的博文</a>了解更多详情，其中包括对 Spring Data 实体非常有用的新的 <code>kotlin-jpa</code> 与 <code>kotlin-noarg</code> 插件。</p><h2 id="基于-Kotlin-的-Gradle-构建配置"><a href="#基于-Kotlin-的-Gradle-构建配置" class="headerlink" title="基于 Kotlin 的 Gradle 构建配置"></a>基于 Kotlin 的 Gradle 构建配置</h2><p>去年 5 月份，Gradle <a href="https://www.jfox.info/go.php?url=https://blog.gradle.org/kotlin-meets-gradle">宣布</a> 除了支持 Groovy 外，他们还将支持用 Kotlin 编写构建及配置文件。 这使在 IDE 中完整的自动补齐与验证成为可能，因为这些文件都是普通的静态类型的 Kotlin 脚本文件。 这可能会成为基于 Kotlin 的项目的自然选择，但这对 Java 项目也同样有价值。</p><p>自去年 5 月以来，<a href="https://www.jfox.info/go.php?url=https://github.com/gradle/gradle-script-kotlin">gradle-script-kotlin</a> 项目不断演进，现在已经可用，请记住以下两条警告：</p><ul><li>你需要 Kotlin 1.1-EAP IDEA 插件来获取自动补齐功能（但是如果你要用 <code>kotlin-spring</code> 插件就要等到 Kotlin <code>1.1-M05</code> 因为 <code>1.1-M04</code> 不能与该插件一起可靠运转）</li></ul><p>【译注】：目前 1.1 已发布，该问题已不存在。</p><ul><li>其文档不够完整，但是 Gradle 团队对 Kotlin Slack 的 #gradle 频道帮助很大。</li></ul><p><a href="https://www.jfox.info/go.php?url=https://github.com/sdeleuze/spring-boot-kotlin-demo">spring-boot-kotlin-demo</a> 以及 <a href="https://www.jfox.info/go.php?url=https://github.com/mix-it/mixit/">mixit</a> 项目都使用这种基于 Kotlin 的 Gradle 构建，所以不妨看看。 我们在<a href="https://www.jfox.info/go.php?url=https://github.com/spring-io/initializr/issues/334">讨论</a>在 start.spring.io 上添加了这项支持。</p><h2 id="基于模版的-Kotlin-脚本"><a href="#基于模版的-Kotlin-脚本" class="headerlink" title="基于模版的 Kotlin 脚本"></a>基于模版的 Kotlin 脚本</h2><p>从 4.3 版开始，Spring 框架提供了一个 <a href="https://www.jfox.info/go.php?url=http://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/web/servlet/view/script/ScriptTemplateView.html">ScriptTemplateView</a>，它使用支持 <a href="https://www.jfox.info/go.php?url=https://www.jcp.org/en/jsr/detail?id=223">JSR-223</a> 的脚本引擎来渲染模版，而 Spring Framework 5.0 会更进一步支持 <a href="https://www.jfox.info/go.php?url=https://jira.spring.io/browse/SPR-15064">i18n 以及模版嵌套</a>。 Kotlin 1.1 提供了这样的支持，并允许渲染基于 Kotlin 的模板，详见<a href="https://www.jfox.info/go.php?url=https://github.com/spring-projects/spring-framework/commit/badde3a479a53e1dd0777dd1bd5b55cb1021cf9e">这次提交</a>。</p><p>这带来了一些有趣的使用场景，例如使用 <a href="https://www.jfox.info/go.php?url=https://github.com/Kotlin/kotlinx.html">kotlinx.html</a> DSL 或者简单使用带有内插的 Kotlin 多行 <code>String</code>来编写类型安全的模版，如这个 <a href="https://www.jfox.info/go.php?url=https://github.com/sdeleuze/kotlin-script-templating">kotlin-script-templating</a> 项目所示。 这可以让你在 IDE 中用完整的自动补齐与重构支持来编写这种模板：</p><pre><code>importio.spring.demo.*&quot;&quot;&quot; ${include(&quot;header&quot;)} &lt;h1&gt;${i18n(&quot;title&quot;)}&lt;/h1&gt; &lt;ul&gt; ${users.joinToLine{ &quot;&lt;li&gt;${i18n(&quot;user&quot;)} ${it.firstname} ${it.lastname}&lt;/li&gt;&quot; {% raw%}}}{% endraw%} &lt;/ul&gt; ${include(&quot;footer&quot;)} &quot;&quot;&quot;
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/一条通用sql因为sq.html" rel="next" title="【一条通用sql因为sq"><i class="fa fa-chevron-left"></i> 【一条通用sql因为sq</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/arduino多任务库processschedule在线程中设置延迟的方法.html" rel="prev" title="arduino多任务库processSchedule在线程中设置延迟的方法">arduino多任务库processSchedule在线程中设置延迟的方法 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#用-Kotlin-进行函数式-bean-注册"><span class="nav-number">1.</span> <span class="nav-text">用 Kotlin 进行函数式 bean 注册</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Web-函数式-API，Kotlin-的方式"><span class="nav-number">2.</span> <span class="nav-text">Spring Web 函数式 API，Kotlin 的方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#利用-Kotlin-的可空性信息"><span class="nav-number">3.</span> <span class="nav-text">利用 Kotlin 的可空性信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用于-RestTemplate-与函数式-Web-API-的扩展"><span class="nav-number">4.</span> <span class="nav-text">用于 RestTemplate 与函数式 Web API 的扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Reactor-Kotlin-扩展"><span class="nav-number">5.</span> <span class="nav-text">Reactor Kotlin 扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不再需要将你的-bean-类声明为-open"><span class="nav-number">6.</span> <span class="nav-text">不再需要将你的 bean 类声明为 open</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-Kotlin-的-Gradle-构建配置"><span class="nav-number">7.</span> <span class="nav-text">基于 Kotlin 的 Gradle 构建配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于模版的-Kotlin-脚本"><span class="nav-number">8.</span> <span class="nav-text">基于模版的 Kotlin 脚本</span></a></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->