<!-- build time:Sat Oct 27 2018 21:00:30 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="今天来聊聊一个接口对接的场景，A厂家有一套HTTP接口需要提供给B厂家使用，由于是外网环境，所以需要有一套安全机制保障，这个时候oauth2就可以作为一个方案。关于oauth2，其实是一个规范，本文重点讲解 spring 对他进行的实现，如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步 理解OAuth 2.0 – 阮一峰 ，这是一篇对于oauth2很好的科普文章。需要对sprin"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="从零开始的Spring Security Oauth2（一）"><meta property="og:url" content="http://www.jfox.info/2017/从零开始的springsecurityoauth2一.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="今天来聊聊一个接口对接的场景，A厂家有一套HTTP接口需要提供给B厂家使用，由于是外网环境，所以需要有一套安全机制保障，这个时候oauth2就可以作为一个方案。关于oauth2，其实是一个规范，本文重点讲解 spring 对他进行的实现，如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步 理解OAuth 2.0 – 阮一峰 ，这是一篇对于oauth2很好的科普文章。需要对sprin"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2017/1500/ff216b8.png"><meta property="og:image" content="http://www.jfox.info/2017/1500/08f74b2.png"><meta property="og:updated_time" content="2018-10-27T12:29:37.399Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="从零开始的Spring Security Oauth2（一）"><meta name="twitter:description" content="今天来聊聊一个接口对接的场景，A厂家有一套HTTP接口需要提供给B厂家使用，由于是外网环境，所以需要有一套安全机制保障，这个时候oauth2就可以作为一个方案。关于oauth2，其实是一个规范，本文重点讲解 spring 对他进行的实现，如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步 理解OAuth 2.0 – 阮一峰 ，这是一篇对于oauth2很好的科普文章。需要对sprin"><meta name="twitter:image" content="http://www.jfox.info/2017/1500/ff216b8.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/从零开始的springsecurityoauth2一.html"><title>从零开始的Spring Security Oauth2（一） | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/从零开始的springsecurityoauth2一.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">从零开始的Spring Security Oauth2（一）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T00:00:00+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>今天来聊聊一个接口对接的场景，A厂家有一套HTTP接口需要提供给B厂家使用，由于是外网环境，所以需要有一套安全机制保障，这个时候oauth2就可以作为一个方案。</p><p>关于oauth2，其实是一个规范，本文重点讲解 <a href="https://www.jfox.info/go.php?url=http://lib.csdn.net/base/javaee">spring</a> 对他进行的实现，如果你还不清楚授权服务器，资源服务器，认证授权等基础概念，可以移步 <a href="https://www.jfox.info/go.php?url=http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html">理解OAuth 2.0 – 阮一峰</a> ，这是一篇对于oauth2很好的科普文章。</p><p>需要对spring security有一定的配置使用经验，用户认证这一块，spring security oauth2建立在spring security的基础之上。第一篇文章主要是讲解使用springboot搭建一个简易的授权，资源服务器，在文末会给出具体代码的github地址。后续文章会进行spring security oauth2的相关源码分析。 <a href="https://www.jfox.info/go.php?url=http://lib.csdn.net/base/java">Java</a> 中的安全框架如shrio，已经有 <a href="https://www.jfox.info/go.php?url=http://jinnianshilongnian.iteye.com/blog/2018936">跟我学shiro – 开涛</a> ，非常成体系地，深入浅出地讲解了apache的这个开源安全框架，但是spring security包括oauth2一直没有成体系的文章，学习它们大多依赖于较少的官方文档，理解一下基本的使用配置；通过零散的博客，了解一下他人的使用经验；打断点，分析内部的工作流程；看源码中的接口设计，以及注释，了解设计者的用意。spring的各个框架都运用了很多的设计模式，在学习源码的过程中，也大概了解了一些套路。spring也在必要的地方添加了适当的注释，避免了源码阅读者对于一些细节设计的理解产生偏差，让我更加感叹，spring不仅仅是一个工具框架，更像是一个艺术品。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>使用oauth2保护你的应用，可以分为简易的分为三个步骤</p><ul><li>配置资源服务器</li><li>配置认证服务器</li><li>配置spring security</li></ul><p>前两点是oauth2的主体内容，但前面我已经描述过了，spring security oauth2是建立在spring security基础之上的，所以有一些体系是公用的。</p><p>oauth2根据使用场景不同，分成了4种模式</p><ul><li>授权码模式（authorization code）</li><li>简化模式（implicit）</li><li>密码模式（resource owner password credentials）</li><li>客户端模式（client credentials）</li></ul><p>本文重点讲解接口对接中常使用的密码模式（以下简称password模式）和客户端模式（以下简称client模式）。授权码模式使用到了回调地址，是最为复杂的方式，通常网站中经常出现的微博，qq第三方登录，都会采用这个形式。简化模式不常用。</p><h2 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h2><p>主要的maven依赖如下</p><pre><code>&lt;!-- 注意是starter,自动配置 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- 不是starter,手动配置 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;
    &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- 将token存储在redis中 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre><p>我们给自己先定个目标，要干什么事？既然说到保护应用，那必须得先有一些资源，我们创建一个endpoint作为提供给外部的接口：</p><pre><code>@RestController
public class TestEndpoints{

    @GetMapping(&quot;/product/{id}&quot;)
    publicStringgetProduct(@PathVariable String id){
        //for debug
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return &quot;product id : &quot; + id;
    }

    @GetMapping(&quot;/order/{id}&quot;)
    publicStringgetOrder(@PathVariable String id){
        //for debug
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return &quot;order id : &quot; + id;
    }

}
</code></pre><p>暴露一个商品查询接口，后续不做安全限制，一个订单查询接口，后续添加访问控制。</p><h2 id="配置资源服务器和授权服务器"><a href="#配置资源服务器和授权服务器" class="headerlink" title="配置资源服务器和授权服务器"></a>配置资源服务器和授权服务器</h2><p>由于是两个oauth2的核心配置，我们放到一个配置类中。</p><p>为了方便下载代码直接运行，我这里将客户端信息放到了内存中，生产中可以配置到 <a href="https://www.jfox.info/go.php?url=http://lib.csdn.net/base/mysql">数据库</a> 中。token的存储一般选择使用 <a href="https://www.jfox.info/go.php?url=http://lib.csdn.net/base/redis">Redis</a> ，一是性能比较好，二是自动过期的机制，符合token的特性。</p><pre><code>@Configuration
public class OAuth2ServerConfig{

    private static final String DEMO_RESOURCE_ID = &quot;order&quot;;

    @Configuration
    @EnableResourceServer
    protected static class ResourceServerConfigurationextends ResourceServerConfigurerAdapter{

        @Override
        public void configure(ResourceServerSecurityConfigurer resources){
            resources.resourceId(DEMO_RESOURCE_ID).stateless(true);
        }

        @Override
        public void configure(HttpSecurity http)throwsException{
            // @formatter:off
            http
                    // Since we want the protected resources to be accessible in the UI as well we need
                    // session creation to be allowed (it&apos;s disabled by default in 2.0.6)
                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
                    .and()
                    .requestMatchers().anyRequest()
                    .and()
                    .anonymous()
                    .and()
                    .authorizeRequests()
// .antMatchers(&quot;/product/**&quot;).access(&quot;#oauth2.hasScope(&apos;select&apos;) and hasRole(&apos;ROLE_USER&apos;)&quot;)
                    .antMatchers(&quot;/order/**&quot;).authenticated();//配置order访问控制，必须认证过后才可以访问
            // @formatter:on
        }
    }


    @Configuration
    @EnableAuthorizationServer
    protected static class AuthorizationServerConfigurationextends AuthorizationServerConfigurerAdapter{

        @Autowired
        AuthenticationManager authenticationManager;
        @Autowired
        RedisConnectionFactory redisConnectionFactory;

        @Override
        public void configure(ClientDetailsServiceConfigurer clients)throwsException{
            //配置两个客户端,一个用于password认证一个用于client认证
            clients.inMemory().withClient(&quot;client_1&quot;)
                    .resourceIds(DEMO_RESOURCE_ID)
                    .authorizedGrantTypes(&quot;client_credentials&quot;, &quot;refresh_token&quot;)
                    .scopes(&quot;select&quot;)
                    .authorities(&quot;client&quot;)
                    .secret(&quot;123456&quot;)
                    .and().withClient(&quot;client_2&quot;)
                    .resourceIds(DEMO_RESOURCE_ID)
                    .authorizedGrantTypes(&quot;password&quot;, &quot;refresh_token&quot;)
                    .scopes(&quot;select&quot;)
                    .authorities(&quot;client&quot;)
                    .secret(&quot;123456&quot;);
        }

        @Override
        public void configure(AuthorizationServerEndpointsConfigurer endpoints)throwsException{
            endpoints
                    .tokenStore(new RedisTokenStore(redisConnectionFactory))
                    .authenticationManager(authenticationManager);
        }

        @Override
        public void configure(AuthorizationServerSecurityConfigurer oauthServer)throwsException{
            //允许表单认证
            oauthServer.allowFormAuthenticationForClients();
        }

    }

}
</code></pre><p>简单说下spring security oauth2的认证思路。</p><ul><li>client模式，没有用户的概念，直接与认证服务器交互，用配置中的客户端信息去申请accessToken，客户端有自己的client_id,client_secret对应于用户的username,password，而客户端也拥有自己的authorities，当采取client模式认证时，对应的权限也就是客户端自己的authorities。</li><li>password模式，自己本身有一套用户体系，在认证时需要带上自己的用户名和密码，以及客户端的client_id,client_secret。此时，accessToken所包含的权限是用户本身的权限，而不是客户端的权限。</li></ul><p>我对于两种模式的理解便是，如果你的系统已经有了一套用户体系，每个用户也有了一定的权限，可以采用password模式；如果仅仅是接口的对接，不考虑用户，则可以使用client模式。</p><h2 id="配置spring-security"><a href="#配置spring-security" class="headerlink" title="配置spring security"></a>配置spring security</h2><p>在spring security的版本迭代中，产生了多种配置方式，建造者模式，适配器模式等等设计模式的使用，spring security内部的认证flow也是错综复杂，在我一开始学习ss也产生了不少困惑，总结了一下配置经验：使用了springboot之后，spring security其实是有不少自动配置的，我们可以仅仅修改自己需要的那一部分，并且遵循一个原则，直接覆盖最需要的那一部分。这一说法比较抽象，举个例子。比如配置内存中的用户认证器。有两种配置方式</p><p>planA：</p><pre><code>@Bean
protectedUserDetailsServiceuserDetailsService(){
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
    manager.createUser(User.withUsername(&quot;user_1&quot;).password(&quot;123456&quot;).authorities(&quot;USER&quot;).build());
    manager.createUser(User.withUsername(&quot;user_2&quot;).password(&quot;123456&quot;).authorities(&quot;USER&quot;).build());
    return manager;
}
</code></pre><p>planB：</p><pre><code>@Configuration
@EnableWebSecurity
public class SecurityConfigurationextends WebSecurityConfigurerAdapter{

    @Override
    protected void configure(AuthenticationManagerBuilder auth)throwsException{
        auth.inMemoryAuthentication()
                .withUser(&quot;user_1&quot;).password(&quot;123456&quot;).authorities(&quot;USER&quot;)
                .and()
                .withUser(&quot;user_2&quot;).password(&quot;123456&quot;).authorities(&quot;USER&quot;);
   }

   @Bean
   @Override
   publicAuthenticationManagerauthenticationManagerBean()throwsException{
       AuthenticationManager manager = super.authenticationManagerBean();
        return manager;
    }
}
</code></pre><p>你最终都能得到配置在内存中的两个用户，前者是直接替换掉了容器中的UserDetailsService，这么做比较直观；后者是替换了AuthenticationManager，当然你还会在SecurityConfiguration 复写其他配置，这么配置最终会由一个委托者去认证。如果你熟悉spring security，会知道AuthenticationManager和AuthenticationProvider以及UserDetailsService的关系，他们都是顶级的接口，实现类之间错综复杂的聚合关系…配置方式千差万别，但理解清楚认证流程，知道各个实现类对应的职责才是掌握spring security的关键。</p><p>下面给出我最终的配置：</p><pre><code>@Configuration
@EnableWebSecurity
public class SecurityConfigurationextends WebSecurityConfigurerAdapter{

    @Bean
    @Override
    protectedUserDetailsServiceuserDetailsService(){
        InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
        manager.createUser(User.withUsername(&quot;user_1&quot;).password(&quot;123456&quot;).authorities(&quot;USER&quot;).build());
        manager.createUser(User.withUsername(&quot;user_2&quot;).password(&quot;123456&quot;).authorities(&quot;USER&quot;).build());
        return manager;
    }

    @Override
    protected void configure(HttpSecurity http)throwsException{
        // @formatter:off
        http
            .requestMatchers().anyRequest()
            .and()
                .authorizeRequests()
                .antMatchers(&quot;/oauth/*&quot;).permitAll();
        // @formatter:on
    }
}
</code></pre><p>重点就是配置了一个UserDetailsService，和ClientDetailsService一样，为了方便运行，使用内存中的用户，实际项目中，一般使用的是数据库保存用户，具体的实现类可以使用JdbcDaoImpl或者JdbcUserDetailsManager。</p><h2 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h2><p>进行如上配置之后，启动springboot应用就可以发现多了一些自动创建的endpoints：</p><pre><code>{[/oauth/authorize]}
{[/oauth/authorize],methods=[POST]
{[/oauth/token],methods=[GET]}
{[/oauth/token],methods=[POST]}
{[/oauth/check_token]}
{[/oauth/error]}
</code></pre><p>重点关注一下/oauth/token，它是获取的token的endpoint。启动springboot应用之后，使用http工具访问 ：</p><ul><li><p>password模式： <code>http://localhost:8080/oauth/token? username=user_1&amp;password=123456&amp; grant_type=password&amp;scope=select&amp; client_id=client_2&amp;client_secret=123456</code> ，响应如下：</p><p>{</p><pre><code>&quot;access_token&quot;:&quot;950a7cc9-5a8a-42c9-a693-40e817b1a4b0&quot;,
&quot;token_type&quot;:&quot;bearer&quot;,
&quot;refresh_token&quot;:&quot;773a0fcd-6023-45f8-8848-e141296cb3cb&quot;,
&quot;expires_in&quot;:27036,
&quot;scope&quot;:&quot;select&quot;
</code></pre><p>}</p></li></ul><ul><li><p>client模式： <code>http://localhost:8080/oauth/token? grant_type=client_credentials&amp; scope=select&amp; client_id=client_1&amp; client_secret=123456</code> ，响应如下：</p><p>{</p><pre><code>&quot;access_token&quot;:&quot;56465b41-429d-436c-ad8d-613d476ff322&quot;,
&quot;token_type&quot;:&quot;bearer&quot;,
&quot;expires_in&quot;:25074,
&quot;scope&quot;:&quot;select&quot;
</code></pre><p>}</p></li></ul><p>在配置中，我们已经配置了对order资源的保护，如果直接访问： <code>http://localhost:8080/order/1</code> ，会得到这样的响应：</p><pre><code>{
    &quot;error&quot;:&quot;unauthorized&quot;,
    &quot;error_description&quot;:&quot;Full authentication is required to access this resource&quot;
}
</code></pre><p>（这样的错误响应可以通过重写配置来修改）</p><p>而对于未受保护的product资源<br><code>http://localhost:8080/product/1</code><br>则可以直接访问，得到响应</p><p><code>product id : 1</code></p><p>携带accessToken参数访问受保护的资源：</p><p>使用password模式获得的token:<br><code>http://localhost:8080/order/1?access_token=950a7cc9-5a8a-42c9-a693-40e817b1a4b0</code><br>得到了之前匿名访问无法获取的资源：</p><p><code>order id : 1</code></p><p>使用client模式获得的token:<br><code>http://localhost:8080/order/1?access_token=56465b41-429d-436c-ad8d-613d476ff322</code><br>同上的响应</p><p><code>order id : 1</code></p><p>我们重点关注一下debug后，对资源访问时系统记录的用户认证信息，可以看到如下的debug信息</p><p>password模式：<br><img src="/2017/1500/ff216b8.png" alt=""><br>client模式：<br><img src="/2017/1500/08f74b2.png" alt=""><br>和我们的配置是一致的，仔细看可以发现两者的身份有些许的不同。想要查看更多的debug信息，可以选择下载demo代码自己查看，为了方便读者调试和验证，我去除了很多复杂的特性，基本实现了一个最简配置，涉及到数据库的地方也尽量配置到了内存中，这点记住在实际使用时一定要修改。</p><p>到这儿，一个简单的oauth2入门示例就完成了，一个简单的配置教程。token的工作原理是什么，它包含了哪些信息？spring内部如何对身份信息进行验证？以及上述的配置到底影响了什么？这些内容会放到后面的文章中去分析。</p><h2 id="示例代码下载"><a href="#示例代码下载" class="headerlink" title="示例代码下载"></a>示例代码下载</h2><p>全部的代码可以在我的github上进行下载，项目使用springboot+maven构建：<br><a href="https://www.jfox.info/go.php?url=https://github.com/lexburner/oauth2-demo">https://github.com/lexburner/oauth2-demo</a><br>如果您有任何想法或问题需要讨论或交流，可进入交流区发表您的想法或问题。</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/ru-he-qu-xiao-shu-dian-qian-liang-wei-bing-si-she-wu-ru.html" rel="prev" title="如何去小数点前两位，并四舍五入。">如何去小数点前两位，并四舍五入。 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#项目准备"><span class="nav-number">2.</span> <span class="nav-text">项目准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置资源服务器和授权服务器"><span class="nav-number">3.</span> <span class="nav-text">配置资源服务器和授权服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#配置spring-security"><span class="nav-number">4.</span> <span class="nav-text">配置spring security</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取token"><span class="nav-number">5.</span> <span class="nav-text">获取token</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#示例代码下载"><span class="nav-number">6.</span> <span class="nav-text">示例代码下载</span></a></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->