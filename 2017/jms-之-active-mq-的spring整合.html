<!-- build time:Sat Oct 27 2018 21:00:23 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="一、与spring整合实现ptp的同步接收消息pom.xml:&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jms --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spr"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="JMS 之 Active MQ 的spring整合"><meta property="og:url" content="http://www.jfox.info/2017/jms-之-active-mq-的spring整合.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="一、与spring整合实现ptp的同步接收消息pom.xml:&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jms --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spr"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.414Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JMS 之 Active MQ 的spring整合"><meta name="twitter:description" content="一、与spring整合实现ptp的同步接收消息pom.xml:&amp;lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jms --&amp;gt;&amp;lt;dependency&amp;gt;&amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;&amp;lt;artifactId&amp;gt;spr"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/jms-之-active-mq-的spring整合.html"><title>JMS 之 Active MQ 的spring整合 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/jms-之-active-mq-的spring整合.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JMS 之 Active MQ 的spring整合</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:50:02+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="一、与spring整合实现ptp的同步接收消息"><a href="#一、与spring整合实现ptp的同步接收消息" class="headerlink" title="一、与spring整合实现ptp的同步接收消息"></a>一、与spring整合实现ptp的同步接收消息</h3><p>pom.xml:</p><pre><code>&lt;!-- https://mvnrepository.com/artifact/org.springframework/spring-jms --&gt;&lt;dependency&gt;&lt;groupId&gt;org.springframework&lt;/groupId&gt;&lt;artifactId&gt;spring-jms&lt;/artifactId&gt;&lt;version&gt;4.3.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.activemq/activemq-pool --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;&lt;artifactId&gt;activemq-pool&lt;/artifactId&gt;&lt;version&gt;5.9.0&lt;/version&gt;&lt;/dependency&gt;
</code></pre><p>spring-jms.xml:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;
xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;
xsi:schemaLocation=&quot;http://activemq.apache.org/schema/core
http://activemq.apache.org/schema/core/activemq-core.xsd
http://www.springframework.org/schema/jms
http://www.springframework.org/schema/jms/spring-jms.xsd
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- ActiveMQConnectionFactory就是JMS中负责创建到ActiveMQ连接的工厂类 --&gt;&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.spring.ActiveMQConnectionFactory&quot;&gt;&lt;property name=&quot;brokerURL&quot; value=&quot;tcp://192.168.0.224:61616&quot;/&gt;&lt;/bean&gt;&lt;!-- 创建连接池 --&gt;&lt;bean id=&quot;pooledConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt;&lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;&lt;property name=&quot;maxConnections&quot; value=&quot;10&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring为我们提供了多个ConnectionFactory，有SingleConnectionFactory和CachingConnectionFactory --&gt;&lt;bean id=&quot;cachingConnectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;&lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;pooledConnectionFactory&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;&lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;&lt;property name=&quot;connectionFactory&quot; ref=&quot;cachingConnectionFactory&quot;/&gt;&lt;/bean&gt;&lt;!--这个是队列目的地，点对点的--&gt;&lt;bean id=&quot;queueDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;&lt;constructor-arg index=&quot;0&quot; value=&quot;spring-queue&quot;/&gt;&lt;/bean&gt;&lt;/beans&gt;
</code></pre><p>ConnectionFactory是用于产生到JMS服务器的链接的，Spring为我们提供了多个ConnectionFactory，有SingleConnectionFactory和CachingConnectionFactory。SingleConnectionFactory对于建立JMS服务器链接的请求会一直返回同一个链接，并且会忽略Connection的close方法调用。CachingConnectionFactory继承了SingleConnectionFactory，所以它拥有SingleConnectionFactory的所有功能，同时它还新增了缓存功能，它可以缓存Session、MessageProducer和MessageConsumer。这里我们使用CachingConnectionFactory来作为示例。</p><p>消息生产者：</p><pre><code>package com.jalja.org.jms.spring;
import javax.jms.Destination;
import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.Session;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.MessageCreator;
publicclass SpringJmsSend {
    publicstaticvoid main(String[] args) {
        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;spring-jms.xml&quot;);
        JmsTemplate jmsTemplate=(JmsTemplate) context.getBean(&quot;jmsTemplate&quot;);
        Destination queueDestination=(Destination) context.getBean(&quot;queueDestination&quot;);
        jmsTemplate.send(queueDestination, new MessageCreator(){
            @Override
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage(&quot;Hello spring JMS&quot;);
            }
        });
    }
}
</code></pre><p>消费者：</p><pre><code>package com.jalja.org.jms.spring;
import javax.jms.Destination;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.jms.core.JmsTemplate;
publicclass SpringJmsReceive {
publicstaticvoid main(String[] args) {
    ApplicationContext context=new ClassPathXmlApplicationContext(&quot;spring-jms.xml&quot;);
    JmsTemplate jmsTemplate=(JmsTemplate) context.getBean(&quot;jmsTemplate&quot;);
    Destination queueDestination=(Destination) context.getBean(&quot;queueDestination&quot;);
    String msg=(String) jmsTemplate.receiveAndConvert(queueDestination);
    System.out.println(msg);
　　}
}
</code></pre><h3 id="二、PTP的异步调用"><a href="#二、PTP的异步调用" class="headerlink" title="二、PTP的异步调用"></a>二、PTP的异步调用</h3><p>我们在spring中直接配置异步接收消息的监听器，这样就相当于在spring中配置了消费者，在接受消息的时候就不必要启动消费者了。</p><p>spring-jms.xml:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;
xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;
xsi:schemaLocation=&quot;http://activemq.apache.org/schema/core
http://activemq.apache.org/schema/core/activemq-core.xsd
http://www.springframework.org/schema/jms
http://www.springframework.org/schema/jms/spring-jms.xsd
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- ActiveMQConnectionFactory就是JMS中负责创建到ActiveMQ连接的工厂类 --&gt;&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.spring.ActiveMQConnectionFactory&quot;&gt;&lt;property name=&quot;brokerURL&quot; value=&quot;tcp://192.168.0.224:61616&quot;/&gt;&lt;/bean&gt;&lt;!-- 创建连接池 --&gt;&lt;bean id=&quot;pooledConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt;&lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;&lt;property name=&quot;maxConnections&quot; value=&quot;10&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring为我们提供了多个ConnectionFactory，有SingleConnectionFactory和CachingConnectionFactory --&gt;&lt;bean id=&quot;cachingConnectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;&lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;pooledConnectionFactory&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;&lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;&lt;property name=&quot;connectionFactory&quot; ref=&quot;cachingConnectionFactory&quot;/&gt;&lt;/bean&gt;&lt;!--这个是队列目的地，点对点的--&gt;&lt;bean id=&quot;queueDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;&lt;constructor-arg index=&quot;0&quot; value=&quot;spring-queue&quot;/&gt;&lt;/bean&gt;&lt;!-- 消息监听器 --&gt;&lt;bean id=&quot;myMessageListener&quot; class=&quot;com.jalja.org.jms.spring.yb.MyMessageListener&quot;/&gt;&lt;!-- 消息监听容器 --&gt;&lt;bean id=&quot;jmsContainer&quot;  class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&gt;&lt;property name=&quot;connectionFactory&quot; ref=&quot;cachingConnectionFactory&quot;/&gt;&lt;property name=&quot;destination&quot; ref=&quot;queueDestination&quot;/&gt;&lt;property name=&quot;messageListener&quot; ref=&quot;myMessageListener&quot;/&gt;&lt;/bean&gt;&lt;/beans&gt;
</code></pre><p>生产者往指定目的地Destination发送消息后，接下来就是消费者对指定目的地的消息进行消费了。那么消费者是如何知道有生产者发送消息到指定目的地Destination了呢？这是通过Spring为我们封装的消息监听容器MessageListenerContainer实现的，它负责接收信息，并把接收到的信息分发给真正的MessageListener进行处理。每个消费者对应每个目的地都需要有对应的MessageListenerContainer。对于消息监听容器而言，除了要知道监听哪个目的地之外，还需要知道到哪里去监听，也就是说它还需要知道去监听哪个JMS服务器，这是通过在配置MessageConnectionFactory的时候往里面注入一个ConnectionFactory来实现的。所以我们在配置一个MessageListenerContainer的时候有三个属性必须指定，一个是表示从哪里监听的ConnectionFactory；一个是表示监听什么的Destination；一个是接收到消息以后进行消息处理的MessageListener。Spring一共为我们提供了两种类型的MessageListenerContainer，SimpleMessageListenerContainer和DefaultMessageListenerContainer。<br>SimpleMessageListenerContainer：SimpleMessageListenerContainer会在一开始的时候就创建一个会话session和消费者Consumer，并且会使用标准的JMS MessageConsumer.setMessageListener()方法注册监听器让JMS提供者调用监听器的回调函数。它不会动态的适应运行时需要和参与外部的事务管理。兼容性方面，它非常接近于独立的JMS规范，但一般不兼容Java EE的JMS限制。</p><p><strong>DefaultMessageListenerContainer：</strong>在大多数情况下我们还是使用的DefaultMessageListenerContainer，跟SimpleMessageListenerContainer相比，DefaultMessageListenerContainer会动态的适应运行时需要，并且能够参与外部的事务管理。它很好的平衡了对JMS提供者要求低、先进功能如事务参与和兼容Java EE环境。</p><p>消息生产者：</p><pre><code>publicstaticvoid main(String[] args) {
        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;spring-jms.xml&quot;);
        JmsTemplate jmsTemplate=(JmsTemplate) context.getBean(&quot;jmsTemplate&quot;);
        Destination queueDestination=(Destination) context.getBean(&quot;queueDestination&quot;);
        System.out.println(&quot;异步调用执行开始&quot;);
        jmsTemplate.send(queueDestination, new MessageCreator(){
            @Override
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage(&quot;Hello spring JMS&quot;);
            }
        });
        System.out.println(&quot;异步调用执行结束&quot;);
    }
</code></pre><p>消息监听器：MyMessageListener</p><pre><code>publicclass MyMessageListener implements MessageListener{
    @Override
    publicvoid onMessage(Message message) {
        TextMessage msg= (TextMessage) message;
        try {
            System.out.println(&quot;你好：&quot;+msg.getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>启动消息生产者 监听器的执行结果是：</p><pre><code>异步调用执行开始
异步调用执行结束
你好：Hello spring JMS
</code></pre><h3 id="三、发布订阅-同步接收"><a href="#三、发布订阅-同步接收" class="headerlink" title="三、发布订阅 同步接收"></a>三、发布订阅 同步接收</h3><p>spring-jms.xml:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xmlns:jms=&quot;http://www.springframework.org/schema/jms&quot;
xmlns:amq=&quot;http://activemq.apache.org/schema/core&quot;
xsi:schemaLocation=&quot;http://activemq.apache.org/schema/core
http://activemq.apache.org/schema/core/activemq-core.xsd
http://www.springframework.org/schema/jms
http://www.springframework.org/schema/jms/spring-jms.xsd
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- ActiveMQConnectionFactory就是JMS中负责创建到ActiveMQ连接的工厂类 --&gt;&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.spring.ActiveMQConnectionFactory&quot;&gt;&lt;property name=&quot;brokerURL&quot; value=&quot;tcp://192.168.0.224:61616&quot;/&gt;&lt;/bean&gt;&lt;!-- 创建连接池 --&gt;&lt;bean id=&quot;pooledConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt;&lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&gt;&lt;property name=&quot;maxConnections&quot; value=&quot;10&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring为我们提供了多个ConnectionFactory，有SingleConnectionFactory和CachingConnectionFactory --&gt;&lt;bean id=&quot;cachingConnectionFactory&quot; class=&quot;org.springframework.jms.connection.CachingConnectionFactory&quot;&gt;&lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;pooledConnectionFactory&quot;/&gt;&lt;/bean&gt;&lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt;&lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&gt;&lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt;&lt;property name=&quot;connectionFactory&quot; ref=&quot;cachingConnectionFactory&quot;/&gt;&lt;/bean&gt;&lt;!--这个是队列目的地，发布订阅--&gt;&lt;bean id=&quot;topicDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;&gt;&lt;constructor-arg index=&quot;0&quot; value=&quot;spring-Topic&quot;/&gt;&lt;/bean&gt;&lt;/beans&gt;
</code></pre><p>生产者：</p><pre><code>publicstaticvoid main(String[] args) {
        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;spring-jms.xml&quot;);
        JmsTemplate jmsTemplate=(JmsTemplate) context.getBean(&quot;jmsTemplate&quot;);
        Destination topicDestination=(Destination) context.getBean(&quot;topicDestination&quot;);
        jmsTemplate.send(topicDestination, new MessageCreator(){
            @Override
            public Message createMessage(Session session) throws JMSException {
                return session.createTextMessage(&quot;Hello spring JMS topicDestination&quot;);
            }
        });
    }
</code></pre><p>消费者：</p><pre><code>publicclass SpringJmsSubscriber {
    publicstaticvoid main(String[] args) {
        ApplicationContext context=new ClassPathXmlApplicationContext(&quot;spring-jms.xml&quot;);
        JmsTemplate jmsTemplate=(JmsTemplate) context.getBean(&quot;jmsTemplate&quot;);
        Destination topicDestination=(Destination) context.getBean(&quot;topicDestination&quot;);
        String msg=(String) jmsTemplate.receiveAndConvert(topicDestination);
        System.out.println(msg);
    }
}
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/短信发送接口被恶意访问的网络攻击事件-三-定位恶.html" rel="next" title="短信发送接口被恶意访问的网络攻击事件(三)定位恶意IP的日志分析脚本"><i class="fa fa-chevron-left"></i> 短信发送接口被恶意访问的网络攻击事件(三)定位恶意IP的日志分析脚本</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/java数据类型-2-自动封装拆箱.html" rel="prev" title="Java数据类型(2)——自动封装拆箱">Java数据类型(2)——自动封装拆箱 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#一、与spring整合实现ptp的同步接收消息"><span class="nav-number">1.</span> <span class="nav-text">一、与spring整合实现ptp的同步接收消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二、PTP的异步调用"><span class="nav-number">2.</span> <span class="nav-text">二、PTP的异步调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三、发布订阅-同步接收"><span class="nav-number">3.</span> <span class="nav-text">三、发布订阅 同步接收</span></a></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->