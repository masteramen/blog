<!-- build time:Sat Oct 27 2018 21:00:17 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="butterknife解决的问题项目地址: https://github.com/JakeWharton/butterknifegithub原文是这样介绍的Field and method binding for Android views which uses annotation processing to generate boilerplate code for you.翻译过来就是：用注"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="注解库之ButterKnife"><meta property="og:url" content="http://www.jfox.info/2017/注解库之butterknife.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="butterknife解决的问题项目地址: https://github.com/JakeWharton/butterknifegithub原文是这样介绍的Field and method binding for Android views which uses annotation processing to generate boilerplate code for you.翻译过来就是：用注"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2017/1415/07d61e5.png"><meta property="og:updated_time" content="2018-10-27T12:29:39.638Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="注解库之ButterKnife"><meta name="twitter:description" content="butterknife解决的问题项目地址: https://github.com/JakeWharton/butterknifegithub原文是这样介绍的Field and method binding for Android views which uses annotation processing to generate boilerplate code for you.翻译过来就是：用注"><meta name="twitter:image" content="http://www.jfox.info/2017/1415/07d61e5.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/注解库之butterknife.html"><title>注解库之ButterKnife | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/注解库之butterknife.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">注解库之ButterKnife</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:58:35+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="butterknife解决的问题"><a href="#butterknife解决的问题" class="headerlink" title="butterknife解决的问题"></a>butterknife解决的问题</h2><p>项目地址: <a href="https://www.jfox.info/go.php?url=https://github.com/JakeWharton/butterknife">https://github.com/JakeWharton/butterknife</a></p><p>github原文是这样介绍的</p><p>Field and method binding for Android views which uses annotation processing to generate boilerplate code for you.</p><p>翻译过来就是：</p><p><code>用注解处理器为程序在编译期生成一些样板代码，用于把一些属性字段和回调方法绑定到 Android 的 View</code>,即专门为Android View设计的绑定注解，专业解决各种findViewById。</p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>在主工程中：</p><pre><code>dependencies {
    compile &apos;com.jakewharton:butterknife:8.5.1&apos;
    annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.5.1&apos;
}
</code></pre><p>在Library中</p><pre><code>buildscript {
  repositories {
    mavenCentral()
   }
  dependencies {
    classpath &apos;com.jakewharton:butterknife-gradle-plugin:8.7.0&apos;
  }
}
</code></pre><p>然后在moudle中</p><pre><code>apply plugin: &apos;com.android.library&apos;
apply plugin: &apos;com.jakewharton.butterknife&apos;
</code></pre><h4 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h4><p><strong>Actvity中</strong></p><p>对一个成员变量使用@BindView注解，并传入一个View ID， ButterKnife 就能够帮你找到对应的View，并自动的进行转换（将View转换为特定的子类）：</p><p><strong>资源绑定</strong></p><p>绑定资源到类成员上可以使用@BindBool、@BindColor、@BindDimen、@BindDrawable、@BindInt、@BindString。使用时对应的注解需要传入对应的id资源，例如@BindString你需要传入R.string.id_string的字符串的资源id。</p><p>Butter Knife提供了bind的几个重载，只要传入跟布局，便可以在任何对象中使用注解绑定</p><p><strong>Fragment中</strong></p><pre><code>publicclassFancyFragmentextendsFragment {@BindView(R.id.button1)
        Button button1;
        @BindView(R.id.button2)
        Button button2;

        @Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
            View view = inflater.inflate(R.layout.fancy_fragment, container, false);
            ButterKnife.bind(this, view); // TODO Use fields... return view; } }

        }
</code></pre><p><strong>Adapter中</strong></p><pre><code>publicclassMyAdapterextendsBaseAdapter {@Overridepublic View getView(int position, View view, ViewGroup parent) {
            ViewHolder holder;
            if (view != null) {
                holder = (ViewHolder) view.getTag();
            } else {
                view = inflater.inflate(R.layout.whatever, parent, false);
                holder = new ViewHolder(view);
                view.setTag(holder);
            }
            holder.name.setText(&quot;John Doe&quot;); // etc... return view; } static class ViewHolder { @BindView(R.id.title) TextView name; @BindView(R.id.job_title) TextView jobTitle; public ViewHolder(View view) { 
                ButterKnife.bind(this, view); 
            } 

        }
    }
</code></pre><p><strong>监听器绑定</strong></p><p>监听器能够自动的绑定到特定的执行方法上：</p><pre><code>@OnClick(R.id.submit)
    publicvoidsubmit(View view) {
      // TODO submit data to server...
    }
</code></pre><h4 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h4><p><strong>重置绑定</strong></p><p>Fragment的生命周期与Activity不同。在Fragment中，如果你在onCreateView中使用绑定，那么你需要在onDestroyView中设置所有view为null。为此，ButterKnife返回一个Unbinder实例以便于你进行这项处理。在合适的生命周期回调中调用unbind函数就可完成重置。</p><pre><code>publicclassFancyFragmentextendsFragment {@BindView(R.id.button1)
        Button button1;
        @BindView(R.id.button2)
        Button button2;
        private Unbinder unbinder;

        @Overridepublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
            View view = inflater.inflate(R.layout.fancy_fragment, container, false);
            unbinder = ButterKnife.bind(this, view); // TODO Use fields... return view;
        }

        @OverridepublicvoidonDestroyView() {
            super.onDestroyView();
            unbinder.unbind();
        }
    }
</code></pre><p><strong>可选绑定</strong></p><p>在默认情况下， @bind和监听器的绑定都是必须的，如果目标view没有找到的话，Butter Knife将会抛出个异常。</p><p>如果你并不想使用这样的默认行为而是想创建一个可选的绑定，那么你只需要在变量上使用@Nullable注解或在函数上使用@Option注解。</p><p>注意：任何名为@Nullable的注解都可以使用在变量上。但还时强烈建议使用Android注解库中的@Nullable。使用这个库对你的代码有很多好处，关于该库的详情，可以点击此处</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>注意：</p><ul><li>Activity ButterKnife.bind(this);必须在setContentView();之后，且父类bind绑定后，子类不需要再bind</li><li>Fragment ButterKnife.bind(this, mRootView);</li><li>属性布局不能用private or static 修饰，否则会报错</li><li>setContentView()不能通过注解实现。</li><li>ButterKnife已经更新到版本8.0.1了，以前的版本中叫做@InjectView了，而现在改用叫@Bind，更加贴合语义。</li><li>在Fragment生命周期中，onDestoryView也需要Butterknife.unbind(this)</li><li>在Libbray中使用R2.id.xxx</li></ul><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>讲到butterknife的原理。这里不得不提一下一般这种注入框架都是运行时注解，即声明注解的生命周期为RUNTIME，然后在运行的时候通过反射完成注入，这种方式虽然简单，但是这种方式多多少少会有性能的损耗。那么有没有一种方法能解决这种性能的损耗呢？ 没错，答案肯定是有的，那就是Butterknife用的APT(Annotation Processing Tool)编译时解析技术。千万不要说成反射了。</p><p>这里大致介绍下APT原理</p><p>声明注解的生命周期为CLASS，然后继承<code>AbstractProcessor</code>类，在编译时编译器会扫描所有带有你要处理的注解的类，然后再调用AbstractProcessor#process 方法，对注解进行处理，在注解处理的时候使用javappoet动态生成固定的模板代码(findviewById、onClick)然后在运行时直接调用bind方法完成绑定就可以了。 详细的APT介绍参看<a href="https://www.jfox.info/go.php?url=http://blog.csdn.net/xsf50717/article/details/54318874">http://blog.csdn.net/xsf50717/article/details/54318874</a></p><p><strong>Java Annotation Processing</strong></p><p><code>Annotation processing 是javac中用于编译时扫描和解析Java注解的工具</code></p><p>你可以定义注解，并且自定义解析器来处理他们，Annotation processing是在编译阶段执行的，它的原理就是读入Java源代码，解析注解，然后生成新的Java代码。新生成的Java代码最后被编译成Java字节码，注解解析器（Annotation Processor）不能改变读入的Java 类，比如不能加入或删除Java方法</p><p>下面是java编译代码的整个过程，可以帮助我们理解注解解析过程</p><p><img src="/2017/1415/07d61e5.png" alt=""></p><p><strong>ButterKnife工作流程</strong></p><p>当你编译你的Android工程时，ButterKnife工程中ButterKnifeProcessor类的process()方法会执行以下操作：</p><ul><li>开始它会扫描Java代码中所有的ButterKnife注解@Bind、@OnClick、@OnItemClicked等</li><li>当它发现一个类中含有任何一个注解时，ButterKnifeProcessor会帮你生成一个Java类，名字类似$$ViewBinder，这个新生成的类实现了ViewBinder接口</li><li>这个ViewBinder类中包含了所有对应的代码，比如@Bind注解对应findViewById(), @OnClick对应了view.setOnClickListener()等等</li><li>最后当Activity启动ButterKnife.bind(this)执行时，ButterKnife会去加载对应的ViewBinder类调用它们的bind()方法</li></ul><p>在butterknife源码 <code>butterknife-compiler#ButterKnifeProcessor</code><a href="https://www.jfox.info/go.php?url=https://github.com/JakeWharton/butterknife/blob/e9cfe921bbb03d40f619d8c86ce49f9e1bc711c5/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java">https://github.com/JakeWharton/butterknife/blob/e9cfe921bbb03d40f619d8c86ce49f9e1bc711c5/butterknife-compiler/src/main/java/butterknife/compiler/ButterKnifeProcessor.java</a></p><p>注解处理器</p><p>包含以下几个重要的方法</p><p>初始化 得到Element、Type、Filer等工具类</p><ul><li>getSupportedAnnotationTypes()</li></ul><p>描述注解处理器需要处理的注解</p><p><code>扫面分析注解</code>，结合javapoet生成代码</p><p>因此<code>process</code>时核心</p><pre><code>@Overridepublicbooleanprocess(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env) {
        Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);

        for (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) {
          TypeElement typeElement = entry.getKey();
          BindingSet binding = entry.getValue();

          JavaFile javaFile = binding.brewJava(sdk, debuggable);
          try {
            javaFile.writeTo(filer);
          } catch (IOException e) {
            error(typeElement, &quot;Unable to write binding for type %s: %s&quot;, typeElement, e.getMessage());
          }
        }

        returnfalse;
      }
</code></pre><p>主要做了两件事</p><ul><li>findAndParseTargets<br>获得TypeElement -&gt; BindingSet的映射关系，TypeElement指的是类或接口，在本文所举的栗子中是MainActivity。BindingSet里包含了生成代码时的一些参数。</li><li>运用JavaPoet框架来生成代码<br>生成的代码类形式为xxxx_ViewBinding</li></ul><p><strong>findAndParseTargets</strong></p><pre><code>private Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) {
    Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = new LinkedHashMap&lt;&gt;();
    Set&lt;TypeElement&gt; erasedTargetNames = new LinkedHashSet&lt;&gt;();

    // 建立view与R的id的关系
    scanForRClasses(env);

    // 省略部分代码// 解析BindView注解for (Element element : env.getElementsAnnotatedWith(BindView.class)) {
      // we don&apos;t SuperficialValidation.validateElement(element)// so that an unresolved View type can be generated by later processing roundstry {
        parseBindView(element, builderMap, erasedTargetNames);
      } catch (Exception e) {
        logParsingError(element, BindView.class, e);
      }
    }

    // 省略部分代码// 将Map.Entry&lt;TypeElement, BindingSet.Builder&gt;转化为Map&lt;TypeElement, BindingSet&gt;
    Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =
        new ArrayDeque&lt;&gt;(builderMap.entrySet());
    Map&lt;TypeElement, BindingSet&gt; bindingMap = new LinkedHashMap&lt;&gt;();
    while (!entries.isEmpty()) {
      Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();

      TypeElement type = entry.getKey();
      BindingSet.Builder builder = entry.getValue();

      TypeElement parentType = findParentType(type, erasedTargetNames);
      if (parentType == null) {
        bindingMap.put(type, builder.build());
      } else {
        BindingSet parentBinding = bindingMap.get(parentType);
        if (parentBinding != null) {
          builder.setParent(parentBinding);
          bindingMap.put(type, builder.build());
        } else {
          // Has a superclass binding but we haven&apos;t built it yet. Re-enqueue for later.
          entries.addLast(entry);
        }
      }
    }

    return bindingMap;
  }
</code></pre><p>用来建立View与id的关系，首先根据element获取到包名，再利用RClassScanner寻找到R文件，在R文件里利用IdScanner寻找到内部类id，在id类里利用VarScanner寻找到tvTitle的id</p><p>解析各种注解，这里以BindView为例。</p><pre><code>privatevoidparseBindView(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,
      Set&lt;TypeElement&gt; erasedTargetNames) {
    // 得到包含注解所属的TypeElement，例如MainActivity
    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();

    // isInaccessibleViaGeneratedCode检验enclosingElement(MainActivity)是类、不是private，检验element不是private活着static// isBindingInWrongPackage检验enclosingElement的包名是不是系统相关的类boolean hasError = isInaccessibleViaGeneratedCode(BindView.class, &quot;fields&quot;, element) || isBindingInWrongPackage(BindView.class, element);

    TypeMirror elementType = element.asType();
    if (elementType.getKind() == TypeKind.TYPEVAR) {
      TypeVariable typeVariable = (TypeVariable) elementType;
      elementType = typeVariable.getUpperBound();
    }
    Name qualifiedName = enclosingElement.getQualifiedName();
    Name simpleName = element.getSimpleName();
    // 判断element是View的子类或者接口if (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) {
      if (elementType.getKind() == TypeKind.ERROR) {
        note(element, &quot;@%s field with unresolved type (%s) &quot;
                + &quot;must elsewhere be generated as a View or interface. (%s.%s)&quot;,
            BindView.class.getSimpleName(), elementType, qualifiedName, simpleName);
      } else {
        error(element, &quot;@%s fields must extend from View or be an interface. (%s.%s)&quot;,
            BindView.class.getSimpleName(), qualifiedName, simpleName);
        hasError = true;
      }
    }

    if (hasError) {
      return;
    }

    // Assemble information on the field.int id = element.getAnnotation(BindView.class).value();

    BindingSet.Builder builder = builderMap.get(enclosingElement);
    QualifiedId qualifiedId = elementToQualifiedId(element, id);
    if (builder != null) {
      String existingBindingName = builder.findExistingBindingName(getId(qualifiedId));
      // 检查是否绑定过此idif (existingBindingName != null) {
        error(element, &quot;Attempt to use @%s for an already bound ID %d on &apos;%s&apos;. (%s.%s)&quot;,
            BindView.class.getSimpleName(), id, existingBindingName,
            enclosingElement.getQualifiedName(), element.getSimpleName());
        return;
      }
    } else {
      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);
    }

    String name = simpleName.toString();
    TypeName type = TypeName.get(elementType);
    boolean required = isFieldRequired(element);

    builder.addField(getId(qualifiedId), new FieldViewBinding(name, type, required));

    // Add the type-erased version to the valid binding targets set.
    erasedTargetNames.add(enclosingElement);
  }
</code></pre><p>parseBindView先检测是否有错误，然后将name(变量名，例如tvTitle)、type(类名，例如TextView)、required(是否有@nullable注解)封装成FieldViewBinding放到builder里面。</p><p>最后使用JavaPoet框架生成代码，关于javaPoet的使用可以参考<a href="https://www.jfox.info/go.php?url=http://blog.csdn.net/XSF50717/article/details/54318891">http://blog.csdn.net/XSF50717/article/details/54318891</a></p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/一种基于kafkastorm实现的日志记录方法三.html" rel="next" title="一种基于kafka+storm实现的日志记录方法(三)"><i class="fa fa-chevron-left"></i> 一种基于kafka+storm实现的日志记录方法(三)</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/mybatis的简单使用调用mapper接口.html" rel="prev" title="mybatis的简单使用调用mapper接口">mybatis的简单使用调用mapper接口 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#butterknife解决的问题"><span class="nav-number">1.</span> <span class="nav-text">butterknife解决的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何使用"><span class="nav-number">2.</span> <span class="nav-text">如何使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常规使用"><span class="nav-number">2.0.1.</span> <span class="nav-text">常规使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进阶使用"><span class="nav-number">2.0.2.</span> <span class="nav-text">进阶使用</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#注意事项"><span class="nav-number">3.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#原理分析"><span class="nav-number">4.</span> <span class="nav-text">原理分析</span></a></li></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->