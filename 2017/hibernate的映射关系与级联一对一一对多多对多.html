<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Hibernate的映射关系与级联（一对一、一对多、多对多） | Java面试</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Hibernate的映射关系与级联（一对一、一对多、多对多）" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="长期专业踩坑……怪物猎人要登陆switch了 1、外键注意： 被引用的列必须是其所在表的主键或者唯一列（此处的department表的dept_name) 引用列 和 被引用列应该数据类型一致，并且最好长度一致 如果存在数据，那么引用列中 不能 存在 被引用列中没有的数据 2、配置注意： 一的那边配置了，多的那边不配置，叫单向一对多 一的那边配置了，多的那边也配置，叫双向一对多 一的那边不配置，多的那边配置了，报错 3、字段重复注意： 因为是一给多加字段，所以在多的一边加的字段不要重复，会报错 4、级联删除注意： 在数据库中直接删除级联的表，要先删除子表，再删除主表，一开始就删除主表是不行的，因为他被子表给引用着 5、级联插入注意 级联之后，从表插不进去，为什么？ 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的，有父亲才有孩子 6、测试的时候不要被之前的表数据给阻碍，所以每次测试前请删除相关的表 如果删除表的时候数据库工具一直在转圈，像死机了一样关闭不行，又不动，操作不了，其实是因为你的Eclipse还在开着刚才运行的代码，每一个都是独立的线程，数据库工具会因为等待其关闭而处于阻塞状态，在Eclipse的Console界面可以看到右上角有红点，表示在运行中，把所有的红点都关掉就可以了 //删除 DROP TABLE IF EXISTS `toy_son`; DROP TABLE IF EXISTS `son`; DROP TABLE IF EXISTS `toy`; DROP TABLE IF EXISTS `father`; DROP TABLE IF EXISTS `mother`; DROP TABLE IF EXISTS `father`; //查询 select * from father; select * from mother; select * from son; select * from toy; select * from toy_son; 7、其实cascade不是必须的，你使用了cascade就可以只保存主表，从表会跟着保存，你不设置cascade，就需要自己手动保存从表 8、我在下面要用的表的表关系 一个父亲有多个孩子 一个父亲有一个妻子 多个孩子有多个玩具 9、先来个总结 1、主键一对多 以一的那方主键作为来个表之间的桥梁，所以是将一那方的字段插到多那方 2、非主键一对多 以一的那方的某个字段作为来个表之间的桥梁，所以是将一那方的字段插到多那方 3、主键多对多 两个表都给出主键，插到一个第三方表，这样产生关系，在第三方表就可以通过我的主键查到与我相关的你的主键，再通过你的主键去查你表里的数据 4、非主键多对多 两个表都给出某一个字段，插到一个第三方表，这样产生关系，在第三方表就可以通过我的字段查到与我相关的你的字段，再通过你的字段去查你表里的数据 5、主键一对一 不需要在对方的表里插字段，因为是一一对应的，所以我的主键的值就是你主键的值 6、非主键一对一 7、双向 你的表里有与我相关的字段可以查到我，我的表里也有你的字段可以查到你对应的数据 8、单向 你的表里没有与我相关的字段，在你的表里查不到我，但是我的表里有你的字段，可以查到你对应的数据 二、示例 1、主键一对多示例 2、非主键一对多示例 3、主键多对多示例 4、非主键多对多示例 5、主键一对一示例 6、非主键一对一示例 7、双向示例 8、单向示例 下面的xml示例都会省略头部声明，完整的xx.hbm.xml参考如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 1、主键一对多示例 儿子与父亲的联系在于父亲的f_id，因为f_id是唯一可以识别父亲的标识，所以将父亲的主键f_id作为外键给儿子，以后凭f_id就可以找到父亲对应的儿子啦 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;property name=&quot;s_f_id&quot; type=&quot;int&quot; column=&quot;S_F_ID&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 2、非主键一对多示例 以上面的代码为基础，上面提到了父亲的主键f_id作为外键给儿子，以后凭f_id就可以找到父亲对应的儿子，那么如果父亲给的外键不是主键呢？比如f_name，父亲的名字 使用非主键作为外键，这个外键必须是唯一不可重复的，所以要设置unique=”true” 在一的那边使用属性property-ref，即是 /** 父亲配置 */ 3、主键多对多示例 多对多的时候，要记住，不是简单给个字段对方而已，要建一个中间表，将双方的外键放上去 /** 儿子表的实体 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 儿子的玩具,一个儿子可以拥有多个玩具 */ private Set toys = new HashSet(); } /** 玩具表的实体 / public class Toy { /** 玩具的id，主键 */ private int t_id; /** 玩具的名字 */ private String t_name; /** 每个玩具可以被多个人拥有/ private Set sons = new HashSet(); } /** 测试代码 */ public class Test { @SuppressWarnings(“unchecked”) public static void main(String[] args) { /** 玩具 */ Toy toy = new Toy(); toy.setT_name(“t1”); /** 儿子 */ Son son = new Son(); son.setS_name(“s1”); /** 级联 因为在Son配置表中配置了 所以级联让Toy来处理，增加了Toy的话，可以把玩具赋给相应的孩子 */ toy.getSons().add(son); son.getToys().add(toy); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了儿子，儿子名下的玩具也会被保存 */ System.out.println(&quot;Son:&quot;+session.save(son)); /** 提交事务 */ session.getTransaction().commit(); } } 4、非主键多对多示例 上面是主键多对多示例，所以使用主键id作为外键，这次是非主键作为外键，所以我们使用名字name作为外键 &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 这次要用这个s_name作为外键，所以要加一个unique=&quot;true&quot; 让其变为唯一可以代表这个儿子的标识 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!-- &lt;key column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot;&gt;&lt;/key&gt; 解析： column=&quot;S_NAME&quot;： 在TOY_SON表中创建一个字段名字叫S_NAME property-ref=&quot;s_name&quot;： 这个字段的类型或者值请参考Son配置表的property name=&quot;s_name&quot; ———————————————————————————————————————————————————— &lt;many-to-many column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot; 解析： column=&quot;T_NAME&quot;： 在TOY_SON表中创建一个字段名字叫T_NAME property-ref=&quot;t_name&quot;： 这个字段的类型或者值请参考Toy配置表的property name=&quot;t_name&quot; --&gt; &lt;set name=&quot;toys&quot; table=&quot;TOY_SON&quot; inverse=&quot;true&quot; cascade=&quot;all&quot; &gt; &lt;key column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot;&gt;&lt;/key&gt; &lt;many-to-many column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot; class=&quot;com.iamzhuwh.more2more.Toy&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Toy&quot; table=&quot;TOY&quot;&gt; &lt;id name=&quot;t_id&quot; column=&quot;T_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 这次要用这个t_name作为外键，所以要加一个unique=&quot;true&quot; 让其变为唯一可以代表这个玩具的标识 --&gt; &lt;property name=&quot;t_name&quot; type=&quot;string&quot; column=&quot;T_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!-- &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; 解析： column=&quot;T_NAME&quot;： 在TOY_SON表中创建一个字段名字叫T_NAME property-ref=&quot;t_name&quot;： 这个字段的类型或者值请参考Toy配置表的property name=&quot;t_name&quot; ———————————————————————————————————————————————————— &lt;many-to-many column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot; 解析： column=&quot;S_NAME&quot;： 在TOY_SON表中创建一个字段名字叫S_NAME property-ref=&quot;s_name&quot;： 这个字段的类型或者值请参考Son配置表的property name=&quot;s_name&quot; --&gt; &lt;set name=&quot;sons&quot; table=&quot;TOY_SON&quot;&gt; &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; &lt;many-to-many column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot; class=&quot;com.iamzhuwh.more2more.Son&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 5、主键一对一示例 这个一对一，你查看数据库表，是没有多出字段的，为什么？因为是一一对应的，比如我用我的id就可以找到你的id，因为是一一对应，所以不需要在你的表里插一个我的id 对比一堆多，一的那边会在多的那边插入一个字段，比如id，来表示两者之间存在关系，通过这个id我就可以查找到跟我关联的你的表的数据 使用one to one 的方式展示主键一对一示例 /** 孩子他爸 */ public class Father { /** 丈夫的id，主键 */ private int f_id; /** 丈夫的名字 */ private String f_name; /** 只有一个妻子*/ private Mother mother; } /** 孩子他妈 */ public class Mother { /** 妻子的id，主键 */ private int m_id; /** 妻子的名字 */ private String m_name; /** 只有一个丈夫 */ private Father father; } &lt;!-- 孩子他爸的配置 --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2one&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;!-- 父母是一对一的，一个丈夫对应一个妻子,所以在丈夫中引入妻子 &lt;one-to-one name=&quot;mother&quot; 这里就是配置了妻子的信息 name=&quot;mother&quot;代表在Father.java中创建了一个叫mother的变量 参考Father.java： /** 只有一个妻子*/ private Mother mother; property-ref=&quot;m_id&quot;代表引用Mother中的m_id作为外键 参考Mother.hbm.xml： &lt;id name=&quot;m_id&quot; column=&quot;M_ID&quot;&gt; --&gt; &lt;one-to-one name=&quot;mother&quot; property-ref=&quot;m_id&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 孩子他妈的配置 --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2one&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Mother&quot; table=&quot;MOTHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;m_id&quot; column=&quot;M_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;m_name&quot; type=&quot;string&quot; column=&quot;M_NAME&quot;/&gt; &lt;!-- 父母是一对一的，一个丈夫对应一个妻子,所以在妻子中引入丈夫 &lt;one-to-one name=&quot;father&quot; 这里就是配置了丈夫的信息 name=&quot;father&quot;代表在Mother.java中创建了一个叫father的变量 参考Mother.java： /** 只有一个丈夫 */ private Father father; property-ref=&quot;f_id&quot;代表引用Father中的f_id作为外键 参考Father.hbm.xml： &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; --&gt; &lt;one-to-one name=&quot;father&quot; property-ref=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2one.Father&quot;&gt;&lt;/one-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 孩子爸 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 孩子妈 */ Mother mother = new Mother(); mother.setM_name(&quot;m1&quot;); /** 级联 增加丈夫，也可以增加妻子 */ father.setMother(mother); mother.setFather(father); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为在孩子他爸的配置表里面配置了cascade=&quot;all&quot;， 所以这里只需要保存孩子爸，孩子妈就会因为级联而被保存 如果没有cascade，则孩子妈需要手动保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } } 使用many to one 的方式展示主键一对一示例 还是在上面的基础上改，改父亲配置表里面的孩子妈配置，将one to one改为more to one，给more to one的字段配置唯一约束unique，它的效果就相当于变成one to one了 &lt;!-- 修改孩子妈配置表 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;F_ID&quot; class=&quot;com.iamzhuwh.one2one.Father&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; &lt;!-- 孩子爸配置表还是不变 --&gt; &lt;one-to-one name=&quot;mother&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; 6、非主键一对一示例 按上面的经验，在使用one to one的基础上，修改为非主键一对一，以名字作为外键，设置名字唯一的约束unique，其他不变 使用one to one 的方式展示非主键一对一示例 &lt;!-- 孩子爸配置表 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!--引用孩子妈的名字作为外键， property-ref=&quot;m_name&quot; --&gt; &lt;one-to-one name=&quot;mother&quot; property-ref=&quot;m_name&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; &lt;!-- 孩子妈配置表 --&gt; &lt;property name=&quot;m_name&quot; type=&quot;string&quot; column=&quot;M_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!--引用孩子爸的名字作为外键， property-ref=&quot;f_name&quot; --&gt; &lt;one-to-one name=&quot;father&quot; property-ref=&quot;f_name&quot; class=&quot;com.iamzhuwh.one2one.Father&quot;&gt;&lt;/one-to-one&gt; 使用many to one 的方式展示非主键一对一示例 &lt;!-- 在上面的进程上修改孩子妈配置表 &lt;one-to-one变&lt;many-to-one --&gt; &lt;many-to-one name=&quot;father&quot; property-ref=&quot;f_name&quot; class=&quot;com.iamzhuwh.one2one.Father&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; 7、双向示例 这个是一对多的双向示例，双向就是说通过我可以查到你，通过你可以查到我 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;property name=&quot;s_f_id&quot; type=&quot;int&quot; column=&quot;S_F_ID&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 8、单向示例 这个是一对多的单向示例，单向就是说通过我可以查到你，你却查不到我 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 因为现在是单向，所以直接把这里给去掉，这样在父亲表就找不到儿子的踪影了，但是在儿子表可以找到父亲的id &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 三、踩坑 问题1 Foreign key (FK_9jbtfsoc50vbxnpaladvwbd50:SON [s_id])) must have same number of columns as the referenced primary key (SON [t_id,s_id]) 添加property-ref即可，如： &lt;key column=&quot;S_ID&quot; property-ref=&quot;s_id&quot;&gt;&lt;/key&gt; 问题2 Field ‘S_ID’ doesn’t have a default value 或者 Field ‘T_ID’ doesn’t have a default value 我的原因是跟inverse相关，也有人说是在数据库给字段加默认值，或者是主键不要native，但是我的主键本来就是非空且自增，不可能是默认值或者native的问题 问题3 object references an unsaved transient instance – save the transient instance before flushing: com.iamzhuwh.more2more.Son son做级联，却保存toy，所以报错，应该是save（son），然后根据级联，son会将里面的toy拿出来保存 问题4 注意两个事情：(以下面代码为例) 首先这里定义了一个字段： &lt;property name=&quot;t_name&quot; type=&quot;string&quot; column=&quot;T_NAME&quot; unique=&quot;true&quot;/&gt; name=”t_name”是用来在这个配置表中代表这个字段的 column=”T_NAME”是用来代表在数据库中要展示的字段名 所以这里要这样引用： &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; 在数据库定义一个字段叫T_NAME 这个字段的值引用在本配置文件中配置的t_name的信息 四、课外知识 1、为什么会有怎么多种关系？ 一对多、多对一、单向、双向是针对不同的情况和业务需求已定的，其实本质是一样的，只是操作的方式不同 1、什么是单向与双向？ 例如：领导叫我查用户与包裹的信息 单向一对多： 用户A对于多个包裹，领导叫我在用户表查找用户A的地址，我就查呗 其实我查询包裹上的信息也可以查到用户A的地址，但是没必要，因为领导说了，到用户表去查 又或者我没有查询包裹信息的权限，所以只有从用户表查 单向多对一： 多个包裹对于用户A，领导叫我在包裹信息表里面查用户A的地址，我就查呗 其实我查询用户表上的信息也可以查到用户A的地址，但是没必要，因为领导说了，到包裹信息表去查 又或者我没有查询用户表的权限，所以只有从包裹信息表查 双向一对多/双向多对一： 领导又来了，叫我查用户A的地址，不管我怎么查，我从用户表可以查到，从包裹信息表也可以查到 懂了么？ 这就是针对不同的业务需求决定使用哪种映射关系，但是本质都是可以查到目标信息 2、什么是一对多与多对一？ 例如：用户与包裹 用户A买了一堆的东西，那就是一个用户对应多个包裹，也就是一对多 一堆的包裹的收件人都是用户A，那就是多个包裹对应一个用户，也就是多对一 3、主键与外键 a、什么是主键 解释： 一张表中的一条数据，可能会包含多个属性，比如姓名、性别 已知一张表有多条数据，用什么来区分每条数据？就是用主键了 不为空的，不重复的，能代表一条数据的，叫主键 什么东西可以作为主键？ 一般是XX_id，从1开始自动递增，保证不重复 也可以是一组属性，比如姓名、年龄、性别加起来作为一个主键 例子： 例如一个人，身份证号码可以作为他的唯一标示，也就是主键 例如一台电视，品牌、型号、序列号加起来可以作为它的唯一标示，也就是主键 b、什么是外键 解释： 在自己的表中，有一个字段，可以确定另一张表的数据的唯一性，叫外键 这个字段，对另一张表来说，叫主键，对自己的这张表来说，叫外键 a表与b表，a表中的某一个字段可以区分b表的每一条数据，这个字段就是a表的外键，是b表的主键 例子： 比如一件快递包裹 在天猫商家的系统里，有这个包裹的购买人id、订单号、电话、快递单号等信息，主键是订单号，通过订单号区分每一个订单 在快递公司的系统里，有这个包裹的快递单号、收件人、电话、地址等信息，主键是快递单号，通过快递单号区分每一个包裹 对快递公司来说，这个快递单号是主键 对天猫商家来说，这个快递单号是外键 我通过订单号可以查到所有订单信息，然后从中找到快递单号，然后在快递表里查快递单号，就可以查到包裹的物流信息 c、区别 主键 唯一标识一条记录，不能有重复的，不允许为空 用来保证数据完整性 一张表主键只能有一个 外键 表的外键是给另一张表使用的，这个外键在另一张表里可以重复,可以是空值。但是在自己表里必须是唯一的，不然你怎么么代表自己表里的一条数据 用来和其他表创建联系用的 一个表可以有多个外键 4、一对一 a、单向一对一主键关联 简单来说，我的主键，就是我的外键，也就是你的主键，一样的值 单向的意思就是，只可以我用我的外键查你，你不查我 b、双向一对一主键关联 简单来说，我的主键，就是我的外键，也就是你的主键，一样的值 双向的意思就是，我可以查你，你可以查我 c、单向一对一外键关联 简单来说，我的主键很宝贵，不给你，那么我的其他字段呢，可以作为我的外键，给你当主键用 单向的意思就是，只可以我用我的外键查你，你不查我 d、双向一对一外键关联 简单来说，我的主键很宝贵，不给你，那么我的其他字段呢，可以作为我的外键，给你当主键用 双向的意思就是，我可以查你，你可以查我 e、一对一外键关联的注意点 因为是一对一，所以是唯一的，所以我的外键也要是唯一的，所以要设置属性unique=true 那为什么一对一主键关联不需要设置这个属性呢，因为两边都是主键啊，主键本来就是唯一且非空的 2、什么是级联 比如主表改了数据，子表相关的数据也会跟着变化，这就是级联 例如用户表里面，用户的地址改了，那么包裹的地址也要跟着变化 用实体类来说，Father就是那个主表，里面有一个set集合的变量，son就是set集合中的一个元素，所以是father.getSon().add(son); – cascade参数 cascade=”all 所有情况下均进行关联操作,包括save、update、delete cascade=”none” cascade=”save-update” 仅save、update、saveOrUpdate时进行关联操作 cascade=”delete” cascade=”all-delete-orphan” 用户对应多个包裹，其中一个包裹，用户不要了，这个包裹就被干掉了 当一个节点在对象图中成为孤儿节点时，删除该节点（摘自百度） – inverse参数 这个参数决定谁来维护这个关联关系，它只在主表的那个配置文件里面配置 什么是关联关系，即是主表更新了，主表要去更新一下子表吗？还是让子表自己更新？ inverse=”false”，代表指定Father维护这个关联关系，即主表更新的同时，子表也更新了，然后主表还要更新一下子表 比如有Father表，有f_id，Son表，也有f_id，因为两个是关联的嘛，然后更新Father表，Son表也会一起更新，但是这个时候Son表的f_id是空的，因为Father表还没更新完 待Father表更新完了，然后Son表也更新完了，Father表会将新增的那个f_id扔给Son表去update一下刚才空的f_id inverse=”true”，代表指定Son维护这个关联关系，即主表更新后，子表再更新更新 比如有Father表，有f_id，Son表，也有f_id，因为两个是关联的嘛，然后更新Father表，Son表是不会有动静的，待Father表更新完了，把f_id扔给Son表，然后Son表再默默的更新自己的信息 懂了不，再看例子 Father表配置 &lt;set name=&quot;son&quot; inverse=&quot;true&quot; cascade=&quot;all&quot; &gt; Hibernate: insert into FATHER (F_NAME) values (?) //inverse=”true”，代表指定Son维护这个关联关系，即主表更新了，子表自己更新 Hibernate: insert into SON (S_NAME, f_id) values (?, ?) Father表配置 &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; Hibernate: insert into FATHER (F_NAME) values (?) Hibernate: insert into SON (S_NAME, f_id) values (?, ?) //这里多了一次更新操作，为啥？ //因为inverse=”false”，代表指定Father维护这个关联关系，即主表更新了，子表更新了，主表还要去更新一下子表 //所以主表更新了自己之后，又去更新了一下子表的F_ID Hibernate: update SON set f_id=? where S_ID=? cascade与inverse 这个时候，大家可能又懵逼了，什么鬼啊，cascade=all的时候，不是已经级联了吗，不是主表更新子表也跟着更新了吗？！！ 其实是这样的，主表更新，子表也跟着更新，这个是cascade级联的作用 粗暴的理解：让主表还是从表去控制子表的更新，这个是inverse的作用。配合上面的例子慢慢体会 3、主键的类别： Assigned 由用户生成主键值，并且要在save()之前指定否则会抛出异常 Hilo 使用高低位算法生成主键，高低位算法使用一个高位值和一个低位值，然后把算法得到的两个值拼接起来作为数据库中的唯一主键 Increment 对主键值采取自动增长的方式生成新的主键值，但要求底层数据库的主键类型为long,int等数值型。主键按数值顺序递增，增量为1。 主键值由Hibernate本身维护，适用于所有的数据库，不适合多进程并发更新数据库 Identity 根据底层数据库，来支持自动增长 例如MySQl中是auto_increment, SQL Server 中是Identity Sequence Native 根据不同的底层数据库自动选择Identity、Sequence、Hilo主键生成方式 便于程序移植，项目中如果用到多个数据库时，可以使用这种方式。 UUID 使用128位UUID算法生成主键，能够保证网络环境下的主键唯一性，也就能够保证在不同数据库及不同服务器下主键的唯一性 Foreign GUID 用于一对一关系中。GUID主键生成方式使用了一种特殊算法，保证生成主键的唯一性，支持SQL Server和MySQL" />
<meta property="og:description" content="长期专业踩坑……怪物猎人要登陆switch了 1、外键注意： 被引用的列必须是其所在表的主键或者唯一列（此处的department表的dept_name) 引用列 和 被引用列应该数据类型一致，并且最好长度一致 如果存在数据，那么引用列中 不能 存在 被引用列中没有的数据 2、配置注意： 一的那边配置了，多的那边不配置，叫单向一对多 一的那边配置了，多的那边也配置，叫双向一对多 一的那边不配置，多的那边配置了，报错 3、字段重复注意： 因为是一给多加字段，所以在多的一边加的字段不要重复，会报错 4、级联删除注意： 在数据库中直接删除级联的表，要先删除子表，再删除主表，一开始就删除主表是不行的，因为他被子表给引用着 5、级联插入注意 级联之后，从表插不进去，为什么？ 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的，有父亲才有孩子 6、测试的时候不要被之前的表数据给阻碍，所以每次测试前请删除相关的表 如果删除表的时候数据库工具一直在转圈，像死机了一样关闭不行，又不动，操作不了，其实是因为你的Eclipse还在开着刚才运行的代码，每一个都是独立的线程，数据库工具会因为等待其关闭而处于阻塞状态，在Eclipse的Console界面可以看到右上角有红点，表示在运行中，把所有的红点都关掉就可以了 //删除 DROP TABLE IF EXISTS `toy_son`; DROP TABLE IF EXISTS `son`; DROP TABLE IF EXISTS `toy`; DROP TABLE IF EXISTS `father`; DROP TABLE IF EXISTS `mother`; DROP TABLE IF EXISTS `father`; //查询 select * from father; select * from mother; select * from son; select * from toy; select * from toy_son; 7、其实cascade不是必须的，你使用了cascade就可以只保存主表，从表会跟着保存，你不设置cascade，就需要自己手动保存从表 8、我在下面要用的表的表关系 一个父亲有多个孩子 一个父亲有一个妻子 多个孩子有多个玩具 9、先来个总结 1、主键一对多 以一的那方主键作为来个表之间的桥梁，所以是将一那方的字段插到多那方 2、非主键一对多 以一的那方的某个字段作为来个表之间的桥梁，所以是将一那方的字段插到多那方 3、主键多对多 两个表都给出主键，插到一个第三方表，这样产生关系，在第三方表就可以通过我的主键查到与我相关的你的主键，再通过你的主键去查你表里的数据 4、非主键多对多 两个表都给出某一个字段，插到一个第三方表，这样产生关系，在第三方表就可以通过我的字段查到与我相关的你的字段，再通过你的字段去查你表里的数据 5、主键一对一 不需要在对方的表里插字段，因为是一一对应的，所以我的主键的值就是你主键的值 6、非主键一对一 7、双向 你的表里有与我相关的字段可以查到我，我的表里也有你的字段可以查到你对应的数据 8、单向 你的表里没有与我相关的字段，在你的表里查不到我，但是我的表里有你的字段，可以查到你对应的数据 二、示例 1、主键一对多示例 2、非主键一对多示例 3、主键多对多示例 4、非主键多对多示例 5、主键一对一示例 6、非主键一对一示例 7、双向示例 8、单向示例 下面的xml示例都会省略头部声明，完整的xx.hbm.xml参考如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 1、主键一对多示例 儿子与父亲的联系在于父亲的f_id，因为f_id是唯一可以识别父亲的标识，所以将父亲的主键f_id作为外键给儿子，以后凭f_id就可以找到父亲对应的儿子啦 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;property name=&quot;s_f_id&quot; type=&quot;int&quot; column=&quot;S_F_ID&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 2、非主键一对多示例 以上面的代码为基础，上面提到了父亲的主键f_id作为外键给儿子，以后凭f_id就可以找到父亲对应的儿子，那么如果父亲给的外键不是主键呢？比如f_name，父亲的名字 使用非主键作为外键，这个外键必须是唯一不可重复的，所以要设置unique=”true” 在一的那边使用属性property-ref，即是 /** 父亲配置 */ 3、主键多对多示例 多对多的时候，要记住，不是简单给个字段对方而已，要建一个中间表，将双方的外键放上去 /** 儿子表的实体 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 儿子的玩具,一个儿子可以拥有多个玩具 */ private Set toys = new HashSet(); } /** 玩具表的实体 / public class Toy { /** 玩具的id，主键 */ private int t_id; /** 玩具的名字 */ private String t_name; /** 每个玩具可以被多个人拥有/ private Set sons = new HashSet(); } /** 测试代码 */ public class Test { @SuppressWarnings(“unchecked”) public static void main(String[] args) { /** 玩具 */ Toy toy = new Toy(); toy.setT_name(“t1”); /** 儿子 */ Son son = new Son(); son.setS_name(“s1”); /** 级联 因为在Son配置表中配置了 所以级联让Toy来处理，增加了Toy的话，可以把玩具赋给相应的孩子 */ toy.getSons().add(son); son.getToys().add(toy); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了儿子，儿子名下的玩具也会被保存 */ System.out.println(&quot;Son:&quot;+session.save(son)); /** 提交事务 */ session.getTransaction().commit(); } } 4、非主键多对多示例 上面是主键多对多示例，所以使用主键id作为外键，这次是非主键作为外键，所以我们使用名字name作为外键 &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 这次要用这个s_name作为外键，所以要加一个unique=&quot;true&quot; 让其变为唯一可以代表这个儿子的标识 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!-- &lt;key column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot;&gt;&lt;/key&gt; 解析： column=&quot;S_NAME&quot;： 在TOY_SON表中创建一个字段名字叫S_NAME property-ref=&quot;s_name&quot;： 这个字段的类型或者值请参考Son配置表的property name=&quot;s_name&quot; ———————————————————————————————————————————————————— &lt;many-to-many column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot; 解析： column=&quot;T_NAME&quot;： 在TOY_SON表中创建一个字段名字叫T_NAME property-ref=&quot;t_name&quot;： 这个字段的类型或者值请参考Toy配置表的property name=&quot;t_name&quot; --&gt; &lt;set name=&quot;toys&quot; table=&quot;TOY_SON&quot; inverse=&quot;true&quot; cascade=&quot;all&quot; &gt; &lt;key column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot;&gt;&lt;/key&gt; &lt;many-to-many column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot; class=&quot;com.iamzhuwh.more2more.Toy&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Toy&quot; table=&quot;TOY&quot;&gt; &lt;id name=&quot;t_id&quot; column=&quot;T_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 这次要用这个t_name作为外键，所以要加一个unique=&quot;true&quot; 让其变为唯一可以代表这个玩具的标识 --&gt; &lt;property name=&quot;t_name&quot; type=&quot;string&quot; column=&quot;T_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!-- &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; 解析： column=&quot;T_NAME&quot;： 在TOY_SON表中创建一个字段名字叫T_NAME property-ref=&quot;t_name&quot;： 这个字段的类型或者值请参考Toy配置表的property name=&quot;t_name&quot; ———————————————————————————————————————————————————— &lt;many-to-many column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot; 解析： column=&quot;S_NAME&quot;： 在TOY_SON表中创建一个字段名字叫S_NAME property-ref=&quot;s_name&quot;： 这个字段的类型或者值请参考Son配置表的property name=&quot;s_name&quot; --&gt; &lt;set name=&quot;sons&quot; table=&quot;TOY_SON&quot;&gt; &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; &lt;many-to-many column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot; class=&quot;com.iamzhuwh.more2more.Son&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 5、主键一对一示例 这个一对一，你查看数据库表，是没有多出字段的，为什么？因为是一一对应的，比如我用我的id就可以找到你的id，因为是一一对应，所以不需要在你的表里插一个我的id 对比一堆多，一的那边会在多的那边插入一个字段，比如id，来表示两者之间存在关系，通过这个id我就可以查找到跟我关联的你的表的数据 使用one to one 的方式展示主键一对一示例 /** 孩子他爸 */ public class Father { /** 丈夫的id，主键 */ private int f_id; /** 丈夫的名字 */ private String f_name; /** 只有一个妻子*/ private Mother mother; } /** 孩子他妈 */ public class Mother { /** 妻子的id，主键 */ private int m_id; /** 妻子的名字 */ private String m_name; /** 只有一个丈夫 */ private Father father; } &lt;!-- 孩子他爸的配置 --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2one&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;!-- 父母是一对一的，一个丈夫对应一个妻子,所以在丈夫中引入妻子 &lt;one-to-one name=&quot;mother&quot; 这里就是配置了妻子的信息 name=&quot;mother&quot;代表在Father.java中创建了一个叫mother的变量 参考Father.java： /** 只有一个妻子*/ private Mother mother; property-ref=&quot;m_id&quot;代表引用Mother中的m_id作为外键 参考Mother.hbm.xml： &lt;id name=&quot;m_id&quot; column=&quot;M_ID&quot;&gt; --&gt; &lt;one-to-one name=&quot;mother&quot; property-ref=&quot;m_id&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 孩子他妈的配置 --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2one&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Mother&quot; table=&quot;MOTHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;m_id&quot; column=&quot;M_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;m_name&quot; type=&quot;string&quot; column=&quot;M_NAME&quot;/&gt; &lt;!-- 父母是一对一的，一个丈夫对应一个妻子,所以在妻子中引入丈夫 &lt;one-to-one name=&quot;father&quot; 这里就是配置了丈夫的信息 name=&quot;father&quot;代表在Mother.java中创建了一个叫father的变量 参考Mother.java： /** 只有一个丈夫 */ private Father father; property-ref=&quot;f_id&quot;代表引用Father中的f_id作为外键 参考Father.hbm.xml： &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; --&gt; &lt;one-to-one name=&quot;father&quot; property-ref=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2one.Father&quot;&gt;&lt;/one-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 孩子爸 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 孩子妈 */ Mother mother = new Mother(); mother.setM_name(&quot;m1&quot;); /** 级联 增加丈夫，也可以增加妻子 */ father.setMother(mother); mother.setFather(father); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为在孩子他爸的配置表里面配置了cascade=&quot;all&quot;， 所以这里只需要保存孩子爸，孩子妈就会因为级联而被保存 如果没有cascade，则孩子妈需要手动保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } } 使用many to one 的方式展示主键一对一示例 还是在上面的基础上改，改父亲配置表里面的孩子妈配置，将one to one改为more to one，给more to one的字段配置唯一约束unique，它的效果就相当于变成one to one了 &lt;!-- 修改孩子妈配置表 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;F_ID&quot; class=&quot;com.iamzhuwh.one2one.Father&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; &lt;!-- 孩子爸配置表还是不变 --&gt; &lt;one-to-one name=&quot;mother&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; 6、非主键一对一示例 按上面的经验，在使用one to one的基础上，修改为非主键一对一，以名字作为外键，设置名字唯一的约束unique，其他不变 使用one to one 的方式展示非主键一对一示例 &lt;!-- 孩子爸配置表 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!--引用孩子妈的名字作为外键， property-ref=&quot;m_name&quot; --&gt; &lt;one-to-one name=&quot;mother&quot; property-ref=&quot;m_name&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; &lt;!-- 孩子妈配置表 --&gt; &lt;property name=&quot;m_name&quot; type=&quot;string&quot; column=&quot;M_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!--引用孩子爸的名字作为外键， property-ref=&quot;f_name&quot; --&gt; &lt;one-to-one name=&quot;father&quot; property-ref=&quot;f_name&quot; class=&quot;com.iamzhuwh.one2one.Father&quot;&gt;&lt;/one-to-one&gt; 使用many to one 的方式展示非主键一对一示例 &lt;!-- 在上面的进程上修改孩子妈配置表 &lt;one-to-one变&lt;many-to-one --&gt; &lt;many-to-one name=&quot;father&quot; property-ref=&quot;f_name&quot; class=&quot;com.iamzhuwh.one2one.Father&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; 7、双向示例 这个是一对多的双向示例，双向就是说通过我可以查到你，通过你可以查到我 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;property name=&quot;s_f_id&quot; type=&quot;int&quot; column=&quot;S_F_ID&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 8、单向示例 这个是一对多的单向示例，单向就是说通过我可以查到你，你却查不到我 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 因为现在是单向，所以直接把这里给去掉，这样在父亲表就找不到儿子的踪影了，但是在儿子表可以找到父亲的id &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 三、踩坑 问题1 Foreign key (FK_9jbtfsoc50vbxnpaladvwbd50:SON [s_id])) must have same number of columns as the referenced primary key (SON [t_id,s_id]) 添加property-ref即可，如： &lt;key column=&quot;S_ID&quot; property-ref=&quot;s_id&quot;&gt;&lt;/key&gt; 问题2 Field ‘S_ID’ doesn’t have a default value 或者 Field ‘T_ID’ doesn’t have a default value 我的原因是跟inverse相关，也有人说是在数据库给字段加默认值，或者是主键不要native，但是我的主键本来就是非空且自增，不可能是默认值或者native的问题 问题3 object references an unsaved transient instance – save the transient instance before flushing: com.iamzhuwh.more2more.Son son做级联，却保存toy，所以报错，应该是save（son），然后根据级联，son会将里面的toy拿出来保存 问题4 注意两个事情：(以下面代码为例) 首先这里定义了一个字段： &lt;property name=&quot;t_name&quot; type=&quot;string&quot; column=&quot;T_NAME&quot; unique=&quot;true&quot;/&gt; name=”t_name”是用来在这个配置表中代表这个字段的 column=”T_NAME”是用来代表在数据库中要展示的字段名 所以这里要这样引用： &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; 在数据库定义一个字段叫T_NAME 这个字段的值引用在本配置文件中配置的t_name的信息 四、课外知识 1、为什么会有怎么多种关系？ 一对多、多对一、单向、双向是针对不同的情况和业务需求已定的，其实本质是一样的，只是操作的方式不同 1、什么是单向与双向？ 例如：领导叫我查用户与包裹的信息 单向一对多： 用户A对于多个包裹，领导叫我在用户表查找用户A的地址，我就查呗 其实我查询包裹上的信息也可以查到用户A的地址，但是没必要，因为领导说了，到用户表去查 又或者我没有查询包裹信息的权限，所以只有从用户表查 单向多对一： 多个包裹对于用户A，领导叫我在包裹信息表里面查用户A的地址，我就查呗 其实我查询用户表上的信息也可以查到用户A的地址，但是没必要，因为领导说了，到包裹信息表去查 又或者我没有查询用户表的权限，所以只有从包裹信息表查 双向一对多/双向多对一： 领导又来了，叫我查用户A的地址，不管我怎么查，我从用户表可以查到，从包裹信息表也可以查到 懂了么？ 这就是针对不同的业务需求决定使用哪种映射关系，但是本质都是可以查到目标信息 2、什么是一对多与多对一？ 例如：用户与包裹 用户A买了一堆的东西，那就是一个用户对应多个包裹，也就是一对多 一堆的包裹的收件人都是用户A，那就是多个包裹对应一个用户，也就是多对一 3、主键与外键 a、什么是主键 解释： 一张表中的一条数据，可能会包含多个属性，比如姓名、性别 已知一张表有多条数据，用什么来区分每条数据？就是用主键了 不为空的，不重复的，能代表一条数据的，叫主键 什么东西可以作为主键？ 一般是XX_id，从1开始自动递增，保证不重复 也可以是一组属性，比如姓名、年龄、性别加起来作为一个主键 例子： 例如一个人，身份证号码可以作为他的唯一标示，也就是主键 例如一台电视，品牌、型号、序列号加起来可以作为它的唯一标示，也就是主键 b、什么是外键 解释： 在自己的表中，有一个字段，可以确定另一张表的数据的唯一性，叫外键 这个字段，对另一张表来说，叫主键，对自己的这张表来说，叫外键 a表与b表，a表中的某一个字段可以区分b表的每一条数据，这个字段就是a表的外键，是b表的主键 例子： 比如一件快递包裹 在天猫商家的系统里，有这个包裹的购买人id、订单号、电话、快递单号等信息，主键是订单号，通过订单号区分每一个订单 在快递公司的系统里，有这个包裹的快递单号、收件人、电话、地址等信息，主键是快递单号，通过快递单号区分每一个包裹 对快递公司来说，这个快递单号是主键 对天猫商家来说，这个快递单号是外键 我通过订单号可以查到所有订单信息，然后从中找到快递单号，然后在快递表里查快递单号，就可以查到包裹的物流信息 c、区别 主键 唯一标识一条记录，不能有重复的，不允许为空 用来保证数据完整性 一张表主键只能有一个 外键 表的外键是给另一张表使用的，这个外键在另一张表里可以重复,可以是空值。但是在自己表里必须是唯一的，不然你怎么么代表自己表里的一条数据 用来和其他表创建联系用的 一个表可以有多个外键 4、一对一 a、单向一对一主键关联 简单来说，我的主键，就是我的外键，也就是你的主键，一样的值 单向的意思就是，只可以我用我的外键查你，你不查我 b、双向一对一主键关联 简单来说，我的主键，就是我的外键，也就是你的主键，一样的值 双向的意思就是，我可以查你，你可以查我 c、单向一对一外键关联 简单来说，我的主键很宝贵，不给你，那么我的其他字段呢，可以作为我的外键，给你当主键用 单向的意思就是，只可以我用我的外键查你，你不查我 d、双向一对一外键关联 简单来说，我的主键很宝贵，不给你，那么我的其他字段呢，可以作为我的外键，给你当主键用 双向的意思就是，我可以查你，你可以查我 e、一对一外键关联的注意点 因为是一对一，所以是唯一的，所以我的外键也要是唯一的，所以要设置属性unique=true 那为什么一对一主键关联不需要设置这个属性呢，因为两边都是主键啊，主键本来就是唯一且非空的 2、什么是级联 比如主表改了数据，子表相关的数据也会跟着变化，这就是级联 例如用户表里面，用户的地址改了，那么包裹的地址也要跟着变化 用实体类来说，Father就是那个主表，里面有一个set集合的变量，son就是set集合中的一个元素，所以是father.getSon().add(son); – cascade参数 cascade=”all 所有情况下均进行关联操作,包括save、update、delete cascade=”none” cascade=”save-update” 仅save、update、saveOrUpdate时进行关联操作 cascade=”delete” cascade=”all-delete-orphan” 用户对应多个包裹，其中一个包裹，用户不要了，这个包裹就被干掉了 当一个节点在对象图中成为孤儿节点时，删除该节点（摘自百度） – inverse参数 这个参数决定谁来维护这个关联关系，它只在主表的那个配置文件里面配置 什么是关联关系，即是主表更新了，主表要去更新一下子表吗？还是让子表自己更新？ inverse=”false”，代表指定Father维护这个关联关系，即主表更新的同时，子表也更新了，然后主表还要更新一下子表 比如有Father表，有f_id，Son表，也有f_id，因为两个是关联的嘛，然后更新Father表，Son表也会一起更新，但是这个时候Son表的f_id是空的，因为Father表还没更新完 待Father表更新完了，然后Son表也更新完了，Father表会将新增的那个f_id扔给Son表去update一下刚才空的f_id inverse=”true”，代表指定Son维护这个关联关系，即主表更新后，子表再更新更新 比如有Father表，有f_id，Son表，也有f_id，因为两个是关联的嘛，然后更新Father表，Son表是不会有动静的，待Father表更新完了，把f_id扔给Son表，然后Son表再默默的更新自己的信息 懂了不，再看例子 Father表配置 &lt;set name=&quot;son&quot; inverse=&quot;true&quot; cascade=&quot;all&quot; &gt; Hibernate: insert into FATHER (F_NAME) values (?) //inverse=”true”，代表指定Son维护这个关联关系，即主表更新了，子表自己更新 Hibernate: insert into SON (S_NAME, f_id) values (?, ?) Father表配置 &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; Hibernate: insert into FATHER (F_NAME) values (?) Hibernate: insert into SON (S_NAME, f_id) values (?, ?) //这里多了一次更新操作，为啥？ //因为inverse=”false”，代表指定Father维护这个关联关系，即主表更新了，子表更新了，主表还要去更新一下子表 //所以主表更新了自己之后，又去更新了一下子表的F_ID Hibernate: update SON set f_id=? where S_ID=? cascade与inverse 这个时候，大家可能又懵逼了，什么鬼啊，cascade=all的时候，不是已经级联了吗，不是主表更新子表也跟着更新了吗？！！ 其实是这样的，主表更新，子表也跟着更新，这个是cascade级联的作用 粗暴的理解：让主表还是从表去控制子表的更新，这个是inverse的作用。配合上面的例子慢慢体会 3、主键的类别： Assigned 由用户生成主键值，并且要在save()之前指定否则会抛出异常 Hilo 使用高低位算法生成主键，高低位算法使用一个高位值和一个低位值，然后把算法得到的两个值拼接起来作为数据库中的唯一主键 Increment 对主键值采取自动增长的方式生成新的主键值，但要求底层数据库的主键类型为long,int等数值型。主键按数值顺序递增，增量为1。 主键值由Hibernate本身维护，适用于所有的数据库，不适合多进程并发更新数据库 Identity 根据底层数据库，来支持自动增长 例如MySQl中是auto_increment, SQL Server 中是Identity Sequence Native 根据不同的底层数据库自动选择Identity、Sequence、Hilo主键生成方式 便于程序移植，项目中如果用到多个数据库时，可以使用这种方式。 UUID 使用128位UUID算法生成主键，能够保证网络环境下的主键唯一性，也就能够保证在不同数据库及不同服务器下主键的唯一性 Foreign GUID 用于一对一关系中。GUID主键生成方式使用了一种特殊算法，保证生成主键的唯一性，支持SQL Server和MySQL" />
<link rel="canonical" href="http://www.jfox.info/2017/hibernate%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%A7%E8%81%94%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E5%A4%9A.html" />
<meta property="og:url" content="http://www.jfox.info/2017/hibernate%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%A7%E8%81%94%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E5%A4%9A.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T15:56:48+00:00" />
<script type="application/ld+json">
{"description":"长期专业踩坑……怪物猎人要登陆switch了 1、外键注意： 被引用的列必须是其所在表的主键或者唯一列（此处的department表的dept_name) 引用列 和 被引用列应该数据类型一致，并且最好长度一致 如果存在数据，那么引用列中 不能 存在 被引用列中没有的数据 2、配置注意： 一的那边配置了，多的那边不配置，叫单向一对多 一的那边配置了，多的那边也配置，叫双向一对多 一的那边不配置，多的那边配置了，报错 3、字段重复注意： 因为是一给多加字段，所以在多的一边加的字段不要重复，会报错 4、级联删除注意： 在数据库中直接删除级联的表，要先删除子表，再删除主表，一开始就删除主表是不行的，因为他被子表给引用着 5、级联插入注意 级联之后，从表插不进去，为什么？ 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的，有父亲才有孩子 6、测试的时候不要被之前的表数据给阻碍，所以每次测试前请删除相关的表 如果删除表的时候数据库工具一直在转圈，像死机了一样关闭不行，又不动，操作不了，其实是因为你的Eclipse还在开着刚才运行的代码，每一个都是独立的线程，数据库工具会因为等待其关闭而处于阻塞状态，在Eclipse的Console界面可以看到右上角有红点，表示在运行中，把所有的红点都关掉就可以了 //删除 DROP TABLE IF EXISTS `toy_son`; DROP TABLE IF EXISTS `son`; DROP TABLE IF EXISTS `toy`; DROP TABLE IF EXISTS `father`; DROP TABLE IF EXISTS `mother`; DROP TABLE IF EXISTS `father`; //查询 select * from father; select * from mother; select * from son; select * from toy; select * from toy_son; 7、其实cascade不是必须的，你使用了cascade就可以只保存主表，从表会跟着保存，你不设置cascade，就需要自己手动保存从表 8、我在下面要用的表的表关系 一个父亲有多个孩子 一个父亲有一个妻子 多个孩子有多个玩具 9、先来个总结 1、主键一对多 以一的那方主键作为来个表之间的桥梁，所以是将一那方的字段插到多那方 2、非主键一对多 以一的那方的某个字段作为来个表之间的桥梁，所以是将一那方的字段插到多那方 3、主键多对多 两个表都给出主键，插到一个第三方表，这样产生关系，在第三方表就可以通过我的主键查到与我相关的你的主键，再通过你的主键去查你表里的数据 4、非主键多对多 两个表都给出某一个字段，插到一个第三方表，这样产生关系，在第三方表就可以通过我的字段查到与我相关的你的字段，再通过你的字段去查你表里的数据 5、主键一对一 不需要在对方的表里插字段，因为是一一对应的，所以我的主键的值就是你主键的值 6、非主键一对一 7、双向 你的表里有与我相关的字段可以查到我，我的表里也有你的字段可以查到你对应的数据 8、单向 你的表里没有与我相关的字段，在你的表里查不到我，但是我的表里有你的字段，可以查到你对应的数据 二、示例 1、主键一对多示例 2、非主键一对多示例 3、主键多对多示例 4、非主键多对多示例 5、主键一对一示例 6、非主键一对一示例 7、双向示例 8、单向示例 下面的xml示例都会省略头部声明，完整的xx.hbm.xml参考如下： &lt;?xml version=&quot;1.0&quot;?&gt; &lt;!DOCTYPE hibernate-mapping PUBLIC &quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot; &quot;http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd&quot;&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 1、主键一对多示例 儿子与父亲的联系在于父亲的f_id，因为f_id是唯一可以识别父亲的标识，所以将父亲的主键f_id作为外键给儿子，以后凭f_id就可以找到父亲对应的儿子啦 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;property name=&quot;s_f_id&quot; type=&quot;int&quot; column=&quot;S_F_ID&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 2、非主键一对多示例 以上面的代码为基础，上面提到了父亲的主键f_id作为外键给儿子，以后凭f_id就可以找到父亲对应的儿子，那么如果父亲给的外键不是主键呢？比如f_name，父亲的名字 使用非主键作为外键，这个外键必须是唯一不可重复的，所以要设置unique=”true” 在一的那边使用属性property-ref，即是 /** 父亲配置 */ 3、主键多对多示例 多对多的时候，要记住，不是简单给个字段对方而已，要建一个中间表，将双方的外键放上去 /** 儿子表的实体 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 儿子的玩具,一个儿子可以拥有多个玩具 */ private Set toys = new HashSet(); } /** 玩具表的实体 / public class Toy { /** 玩具的id，主键 */ private int t_id; /** 玩具的名字 */ private String t_name; /** 每个玩具可以被多个人拥有/ private Set sons = new HashSet(); } /** 测试代码 */ public class Test { @SuppressWarnings(“unchecked”) public static void main(String[] args) { /** 玩具 */ Toy toy = new Toy(); toy.setT_name(“t1”); /** 儿子 */ Son son = new Son(); son.setS_name(“s1”); /** 级联 因为在Son配置表中配置了 所以级联让Toy来处理，增加了Toy的话，可以把玩具赋给相应的孩子 */ toy.getSons().add(son); son.getToys().add(toy); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了儿子，儿子名下的玩具也会被保存 */ System.out.println(&quot;Son:&quot;+session.save(son)); /** 提交事务 */ session.getTransaction().commit(); } } 4、非主键多对多示例 上面是主键多对多示例，所以使用主键id作为外键，这次是非主键作为外键，所以我们使用名字name作为外键 &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 这次要用这个s_name作为外键，所以要加一个unique=&quot;true&quot; 让其变为唯一可以代表这个儿子的标识 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!-- &lt;key column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot;&gt;&lt;/key&gt; 解析： column=&quot;S_NAME&quot;： 在TOY_SON表中创建一个字段名字叫S_NAME property-ref=&quot;s_name&quot;： 这个字段的类型或者值请参考Son配置表的property name=&quot;s_name&quot; ———————————————————————————————————————————————————— &lt;many-to-many column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot; 解析： column=&quot;T_NAME&quot;： 在TOY_SON表中创建一个字段名字叫T_NAME property-ref=&quot;t_name&quot;： 这个字段的类型或者值请参考Toy配置表的property name=&quot;t_name&quot; --&gt; &lt;set name=&quot;toys&quot; table=&quot;TOY_SON&quot; inverse=&quot;true&quot; cascade=&quot;all&quot; &gt; &lt;key column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot;&gt;&lt;/key&gt; &lt;many-to-many column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot; class=&quot;com.iamzhuwh.more2more.Toy&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.more2more&quot;&gt; &lt;class name=&quot;Toy&quot; table=&quot;TOY&quot;&gt; &lt;id name=&quot;t_id&quot; column=&quot;T_ID&quot;&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 这次要用这个t_name作为外键，所以要加一个unique=&quot;true&quot; 让其变为唯一可以代表这个玩具的标识 --&gt; &lt;property name=&quot;t_name&quot; type=&quot;string&quot; column=&quot;T_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!-- &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; 解析： column=&quot;T_NAME&quot;： 在TOY_SON表中创建一个字段名字叫T_NAME property-ref=&quot;t_name&quot;： 这个字段的类型或者值请参考Toy配置表的property name=&quot;t_name&quot; ———————————————————————————————————————————————————— &lt;many-to-many column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot; 解析： column=&quot;S_NAME&quot;： 在TOY_SON表中创建一个字段名字叫S_NAME property-ref=&quot;s_name&quot;： 这个字段的类型或者值请参考Son配置表的property name=&quot;s_name&quot; --&gt; &lt;set name=&quot;sons&quot; table=&quot;TOY_SON&quot;&gt; &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; &lt;many-to-many column=&quot;S_NAME&quot; property-ref=&quot;s_name&quot; class=&quot;com.iamzhuwh.more2more.Son&quot;&gt;&lt;/many-to-many&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; 5、主键一对一示例 这个一对一，你查看数据库表，是没有多出字段的，为什么？因为是一一对应的，比如我用我的id就可以找到你的id，因为是一一对应，所以不需要在你的表里插一个我的id 对比一堆多，一的那边会在多的那边插入一个字段，比如id，来表示两者之间存在关系，通过这个id我就可以查找到跟我关联的你的表的数据 使用one to one 的方式展示主键一对一示例 /** 孩子他爸 */ public class Father { /** 丈夫的id，主键 */ private int f_id; /** 丈夫的名字 */ private String f_name; /** 只有一个妻子*/ private Mother mother; } /** 孩子他妈 */ public class Mother { /** 妻子的id，主键 */ private int m_id; /** 妻子的名字 */ private String m_name; /** 只有一个丈夫 */ private Father father; } &lt;!-- 孩子他爸的配置 --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2one&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;!-- 父母是一对一的，一个丈夫对应一个妻子,所以在丈夫中引入妻子 &lt;one-to-one name=&quot;mother&quot; 这里就是配置了妻子的信息 name=&quot;mother&quot;代表在Father.java中创建了一个叫mother的变量 参考Father.java： /** 只有一个妻子*/ private Mother mother; property-ref=&quot;m_id&quot;代表引用Mother中的m_id作为外键 参考Mother.hbm.xml： &lt;id name=&quot;m_id&quot; column=&quot;M_ID&quot;&gt; --&gt; &lt;one-to-one name=&quot;mother&quot; property-ref=&quot;m_id&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 孩子他妈的配置 --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2one&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Mother&quot; table=&quot;MOTHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;m_id&quot; column=&quot;M_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;m_name&quot; type=&quot;string&quot; column=&quot;M_NAME&quot;/&gt; &lt;!-- 父母是一对一的，一个丈夫对应一个妻子,所以在妻子中引入丈夫 &lt;one-to-one name=&quot;father&quot; 这里就是配置了丈夫的信息 name=&quot;father&quot;代表在Mother.java中创建了一个叫father的变量 参考Mother.java： /** 只有一个丈夫 */ private Father father; property-ref=&quot;f_id&quot;代表引用Father中的f_id作为外键 参考Father.hbm.xml： &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; --&gt; &lt;one-to-one name=&quot;father&quot; property-ref=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2one.Father&quot;&gt;&lt;/one-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 孩子爸 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 孩子妈 */ Mother mother = new Mother(); mother.setM_name(&quot;m1&quot;); /** 级联 增加丈夫，也可以增加妻子 */ father.setMother(mother); mother.setFather(father); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为在孩子他爸的配置表里面配置了cascade=&quot;all&quot;， 所以这里只需要保存孩子爸，孩子妈就会因为级联而被保存 如果没有cascade，则孩子妈需要手动保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } } 使用many to one 的方式展示主键一对一示例 还是在上面的基础上改，改父亲配置表里面的孩子妈配置，将one to one改为more to one，给more to one的字段配置唯一约束unique，它的效果就相当于变成one to one了 &lt;!-- 修改孩子妈配置表 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;F_ID&quot; class=&quot;com.iamzhuwh.one2one.Father&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; &lt;!-- 孩子爸配置表还是不变 --&gt; &lt;one-to-one name=&quot;mother&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; 6、非主键一对一示例 按上面的经验，在使用one to one的基础上，修改为非主键一对一，以名字作为外键，设置名字唯一的约束unique，其他不变 使用one to one 的方式展示非主键一对一示例 &lt;!-- 孩子爸配置表 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!--引用孩子妈的名字作为外键， property-ref=&quot;m_name&quot; --&gt; &lt;one-to-one name=&quot;mother&quot; property-ref=&quot;m_name&quot; cascade=&quot;all&quot; class=&quot;com.iamzhuwh.one2one.Mother&quot;&gt;&lt;/one-to-one&gt; &lt;!-- 孩子妈配置表 --&gt; &lt;property name=&quot;m_name&quot; type=&quot;string&quot; column=&quot;M_NAME&quot; unique=&quot;true&quot;/&gt; &lt;!--引用孩子爸的名字作为外键， property-ref=&quot;f_name&quot; --&gt; &lt;one-to-one name=&quot;father&quot; property-ref=&quot;f_name&quot; class=&quot;com.iamzhuwh.one2one.Father&quot;&gt;&lt;/one-to-one&gt; 使用many to one 的方式展示非主键一对一示例 &lt;!-- 在上面的进程上修改孩子妈配置表 &lt;one-to-one变&lt;many-to-one --&gt; &lt;many-to-one name=&quot;father&quot; property-ref=&quot;f_name&quot; class=&quot;com.iamzhuwh.one2one.Father&quot; unique=&quot;true&quot;&gt;&lt;/many-to-one&gt; 7、双向示例 这个是一对多的双向示例，双向就是说通过我可以查到你，通过你可以查到我 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;property name=&quot;s_f_id&quot; type=&quot;int&quot; column=&quot;S_F_ID&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 8、单向示例 这个是一对多的单向示例，单向就是说通过我可以查到你，你却查不到我 /** 父亲 */ public class Father { /** 父亲的id，主键 */ private int f_id; /** 父亲的名字 */ private String f_name; /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/ private Set son = new HashSet(); } /** 儿子 */ public class Son { /** 儿子的id，主键 */ private int s_id; /** 儿子的名字 */ private String s_name; /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/ private Father father; } /** 父亲配置文件，Father.hbm.xml */ &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类：com.iamzhuwh.one2more.Father 定义class标签， &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; name是实体类名字， table是你要创建的表名 包名：package=&quot;com.iamzhuwh.one2more&quot; --&gt; &lt;class name=&quot;Father&quot; table=&quot;FATHER&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;f_id&quot; column=&quot;F_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;f_name&quot; type=&quot;string&quot; column=&quot;F_NAME&quot;/&gt; &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 --&gt; &lt;key column=&quot;f_id&quot;&gt;&lt;/key&gt; &lt;one-to-many class=&quot;com.iamzhuwh.one2more.Son&quot;/&gt; &lt;/set&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; &lt;!-- 儿子配置文件，Son.hbm.xml --&gt; &lt;hibernate-mapping package=&quot;com.iamzhuwh.one2more&quot;&gt; &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt; &lt;class name=&quot;Son&quot; table=&quot;SON&quot;&gt; &lt;!-- id是主键，自增 --&gt; &lt;id name=&quot;s_id&quot; column=&quot;S_ID&quot;&gt; &lt;!-- 主键配置 --&gt; &lt;generator class=&quot;native&quot;/&gt; &lt;/id&gt; &lt;!-- 其他字段 --&gt; &lt;property name=&quot;s_name&quot; type=&quot;string&quot; column=&quot;S_NAME&quot;/&gt; &lt;!-- 一的一方的外键column=&quot;f_id&quot; 儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识 因为现在是单向，所以直接把这里给去掉，这样在父亲表就找不到儿子的踪影了，但是在儿子表可以找到父亲的id &lt;many-to-one name=&quot;father&quot; column=&quot;f_id&quot; class=&quot;com.iamzhuwh.one2more.Father&quot;&gt; &lt;/many-to-one&gt; --&gt; &lt;/class&gt; &lt;/hibernate-mapping&gt; /** 测试代码 */ public class Test { @SuppressWarnings(&quot;unchecked&quot;) public static void main(String[] args) { /** 父亲 */ Father father = new Father(); father.setF_name(&quot;f1&quot;); /** 儿子 */ Son son = new Son(); son.setS_name(&quot;s1&quot;); /** 级联 增加了父亲的话，可以在这个父亲的名下增加相应的孩子 但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？ 这就是级联，都是连在一起的 */ father.getSon().add(son); /** 获取连接 */ SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); session.beginTransaction(); /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */ System.out.println(&quot;Father:&quot;+session.save(father)); /** 提交事务 */ session.getTransaction().commit(); } 三、踩坑 问题1 Foreign key (FK_9jbtfsoc50vbxnpaladvwbd50:SON [s_id])) must have same number of columns as the referenced primary key (SON [t_id,s_id]) 添加property-ref即可，如： &lt;key column=&quot;S_ID&quot; property-ref=&quot;s_id&quot;&gt;&lt;/key&gt; 问题2 Field ‘S_ID’ doesn’t have a default value 或者 Field ‘T_ID’ doesn’t have a default value 我的原因是跟inverse相关，也有人说是在数据库给字段加默认值，或者是主键不要native，但是我的主键本来就是非空且自增，不可能是默认值或者native的问题 问题3 object references an unsaved transient instance – save the transient instance before flushing: com.iamzhuwh.more2more.Son son做级联，却保存toy，所以报错，应该是save（son），然后根据级联，son会将里面的toy拿出来保存 问题4 注意两个事情：(以下面代码为例) 首先这里定义了一个字段： &lt;property name=&quot;t_name&quot; type=&quot;string&quot; column=&quot;T_NAME&quot; unique=&quot;true&quot;/&gt; name=”t_name”是用来在这个配置表中代表这个字段的 column=”T_NAME”是用来代表在数据库中要展示的字段名 所以这里要这样引用： &lt;key column=&quot;T_NAME&quot; property-ref=&quot;t_name&quot;&gt;&lt;/key&gt; 在数据库定义一个字段叫T_NAME 这个字段的值引用在本配置文件中配置的t_name的信息 四、课外知识 1、为什么会有怎么多种关系？ 一对多、多对一、单向、双向是针对不同的情况和业务需求已定的，其实本质是一样的，只是操作的方式不同 1、什么是单向与双向？ 例如：领导叫我查用户与包裹的信息 单向一对多： 用户A对于多个包裹，领导叫我在用户表查找用户A的地址，我就查呗 其实我查询包裹上的信息也可以查到用户A的地址，但是没必要，因为领导说了，到用户表去查 又或者我没有查询包裹信息的权限，所以只有从用户表查 单向多对一： 多个包裹对于用户A，领导叫我在包裹信息表里面查用户A的地址，我就查呗 其实我查询用户表上的信息也可以查到用户A的地址，但是没必要，因为领导说了，到包裹信息表去查 又或者我没有查询用户表的权限，所以只有从包裹信息表查 双向一对多/双向多对一： 领导又来了，叫我查用户A的地址，不管我怎么查，我从用户表可以查到，从包裹信息表也可以查到 懂了么？ 这就是针对不同的业务需求决定使用哪种映射关系，但是本质都是可以查到目标信息 2、什么是一对多与多对一？ 例如：用户与包裹 用户A买了一堆的东西，那就是一个用户对应多个包裹，也就是一对多 一堆的包裹的收件人都是用户A，那就是多个包裹对应一个用户，也就是多对一 3、主键与外键 a、什么是主键 解释： 一张表中的一条数据，可能会包含多个属性，比如姓名、性别 已知一张表有多条数据，用什么来区分每条数据？就是用主键了 不为空的，不重复的，能代表一条数据的，叫主键 什么东西可以作为主键？ 一般是XX_id，从1开始自动递增，保证不重复 也可以是一组属性，比如姓名、年龄、性别加起来作为一个主键 例子： 例如一个人，身份证号码可以作为他的唯一标示，也就是主键 例如一台电视，品牌、型号、序列号加起来可以作为它的唯一标示，也就是主键 b、什么是外键 解释： 在自己的表中，有一个字段，可以确定另一张表的数据的唯一性，叫外键 这个字段，对另一张表来说，叫主键，对自己的这张表来说，叫外键 a表与b表，a表中的某一个字段可以区分b表的每一条数据，这个字段就是a表的外键，是b表的主键 例子： 比如一件快递包裹 在天猫商家的系统里，有这个包裹的购买人id、订单号、电话、快递单号等信息，主键是订单号，通过订单号区分每一个订单 在快递公司的系统里，有这个包裹的快递单号、收件人、电话、地址等信息，主键是快递单号，通过快递单号区分每一个包裹 对快递公司来说，这个快递单号是主键 对天猫商家来说，这个快递单号是外键 我通过订单号可以查到所有订单信息，然后从中找到快递单号，然后在快递表里查快递单号，就可以查到包裹的物流信息 c、区别 主键 唯一标识一条记录，不能有重复的，不允许为空 用来保证数据完整性 一张表主键只能有一个 外键 表的外键是给另一张表使用的，这个外键在另一张表里可以重复,可以是空值。但是在自己表里必须是唯一的，不然你怎么么代表自己表里的一条数据 用来和其他表创建联系用的 一个表可以有多个外键 4、一对一 a、单向一对一主键关联 简单来说，我的主键，就是我的外键，也就是你的主键，一样的值 单向的意思就是，只可以我用我的外键查你，你不查我 b、双向一对一主键关联 简单来说，我的主键，就是我的外键，也就是你的主键，一样的值 双向的意思就是，我可以查你，你可以查我 c、单向一对一外键关联 简单来说，我的主键很宝贵，不给你，那么我的其他字段呢，可以作为我的外键，给你当主键用 单向的意思就是，只可以我用我的外键查你，你不查我 d、双向一对一外键关联 简单来说，我的主键很宝贵，不给你，那么我的其他字段呢，可以作为我的外键，给你当主键用 双向的意思就是，我可以查你，你可以查我 e、一对一外键关联的注意点 因为是一对一，所以是唯一的，所以我的外键也要是唯一的，所以要设置属性unique=true 那为什么一对一主键关联不需要设置这个属性呢，因为两边都是主键啊，主键本来就是唯一且非空的 2、什么是级联 比如主表改了数据，子表相关的数据也会跟着变化，这就是级联 例如用户表里面，用户的地址改了，那么包裹的地址也要跟着变化 用实体类来说，Father就是那个主表，里面有一个set集合的变量，son就是set集合中的一个元素，所以是father.getSon().add(son); – cascade参数 cascade=”all 所有情况下均进行关联操作,包括save、update、delete cascade=”none” cascade=”save-update” 仅save、update、saveOrUpdate时进行关联操作 cascade=”delete” cascade=”all-delete-orphan” 用户对应多个包裹，其中一个包裹，用户不要了，这个包裹就被干掉了 当一个节点在对象图中成为孤儿节点时，删除该节点（摘自百度） – inverse参数 这个参数决定谁来维护这个关联关系，它只在主表的那个配置文件里面配置 什么是关联关系，即是主表更新了，主表要去更新一下子表吗？还是让子表自己更新？ inverse=”false”，代表指定Father维护这个关联关系，即主表更新的同时，子表也更新了，然后主表还要更新一下子表 比如有Father表，有f_id，Son表，也有f_id，因为两个是关联的嘛，然后更新Father表，Son表也会一起更新，但是这个时候Son表的f_id是空的，因为Father表还没更新完 待Father表更新完了，然后Son表也更新完了，Father表会将新增的那个f_id扔给Son表去update一下刚才空的f_id inverse=”true”，代表指定Son维护这个关联关系，即主表更新后，子表再更新更新 比如有Father表，有f_id，Son表，也有f_id，因为两个是关联的嘛，然后更新Father表，Son表是不会有动静的，待Father表更新完了，把f_id扔给Son表，然后Son表再默默的更新自己的信息 懂了不，再看例子 Father表配置 &lt;set name=&quot;son&quot; inverse=&quot;true&quot; cascade=&quot;all&quot; &gt; Hibernate: insert into FATHER (F_NAME) values (?) //inverse=”true”，代表指定Son维护这个关联关系，即主表更新了，子表自己更新 Hibernate: insert into SON (S_NAME, f_id) values (?, ?) Father表配置 &lt;set name=&quot;son&quot; inverse=&quot;false&quot; cascade=&quot;all&quot; &gt; Hibernate: insert into FATHER (F_NAME) values (?) Hibernate: insert into SON (S_NAME, f_id) values (?, ?) //这里多了一次更新操作，为啥？ //因为inverse=”false”，代表指定Father维护这个关联关系，即主表更新了，子表更新了，主表还要去更新一下子表 //所以主表更新了自己之后，又去更新了一下子表的F_ID Hibernate: update SON set f_id=? where S_ID=? cascade与inverse 这个时候，大家可能又懵逼了，什么鬼啊，cascade=all的时候，不是已经级联了吗，不是主表更新子表也跟着更新了吗？！！ 其实是这样的，主表更新，子表也跟着更新，这个是cascade级联的作用 粗暴的理解：让主表还是从表去控制子表的更新，这个是inverse的作用。配合上面的例子慢慢体会 3、主键的类别： Assigned 由用户生成主键值，并且要在save()之前指定否则会抛出异常 Hilo 使用高低位算法生成主键，高低位算法使用一个高位值和一个低位值，然后把算法得到的两个值拼接起来作为数据库中的唯一主键 Increment 对主键值采取自动增长的方式生成新的主键值，但要求底层数据库的主键类型为long,int等数值型。主键按数值顺序递增，增量为1。 主键值由Hibernate本身维护，适用于所有的数据库，不适合多进程并发更新数据库 Identity 根据底层数据库，来支持自动增长 例如MySQl中是auto_increment, SQL Server 中是Identity Sequence Native 根据不同的底层数据库自动选择Identity、Sequence、Hilo主键生成方式 便于程序移植，项目中如果用到多个数据库时，可以使用这种方式。 UUID 使用128位UUID算法生成主键，能够保证网络环境下的主键唯一性，也就能够保证在不同数据库及不同服务器下主键的唯一性 Foreign GUID 用于一对一关系中。GUID主键生成方式使用了一种特殊算法，保证生成主键的唯一性，支持SQL Server和MySQL","@type":"BlogPosting","url":"http://www.jfox.info/2017/hibernate%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%A7%E8%81%94%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E5%A4%9A.html","headline":"Hibernate的映射关系与级联（一对一、一对多、多对多）","dateModified":"2017-01-01T15:56:48+00:00","datePublished":"2017-01-01T15:56:48+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/hibernate%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%A7%E8%81%94%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E5%A4%9A.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Hibernate的映射关系与级联（一对一、一对多、多对多）</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T15:56:48+00:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>长期专业踩坑……怪物猎人要登陆switch了</p>

<h4 id="1外键注意">1、外键注意：</h4>

<ul>
  <li>被引用的列必须是其所在表的主键或者唯一列（此处的department表的dept_name)</li>
  <li>引用列 和 被引用列应该数据类型一致，并且最好长度一致</li>
  <li>如果存在数据，那么引用列中 不能 存在 被引用列中没有的数据</li>
</ul>

<h4 id="2配置注意">2、配置注意：</h4>

<ul>
  <li>一的那边配置了，多的那边不配置，叫单向一对多</li>
  <li>一的那边配置了，多的那边也配置，叫双向一对多</li>
  <li>一的那边不配置，多的那边配置了，报错</li>
</ul>

<h4 id="3字段重复注意">3、字段重复注意：</h4>

<ul>
  <li>因为是一给多加字段，所以在多的一边加的字段不要重复，会报错</li>
</ul>

<h4 id="4级联删除注意">4、级联删除注意：</h4>

<ul>
  <li>在数据库中直接删除级联的表，要先删除子表，再删除主表，一开始就删除主表是不行的，因为他被子表给引用着</li>
</ul>

<h4 id="5级联插入注意">5、级联插入注意</h4>

<ul>
  <li>
    <p>级联之后，从表插不进去，为什么？</p>
  </li>
  <li>增加了父亲的话，可以在这个父亲的名下增加相应的孩子</li>
  <li>但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？</li>
  <li>这就是级联，都是连在一起的，有父亲才有孩子</li>
</ul>

<h4 id="6测试的时候不要被之前的表数据给阻碍所以每次测试前请删除相关的表">6、测试的时候不要被之前的表数据给阻碍，所以每次测试前请删除相关的表</h4>

<p>如果删除表的时候数据库工具一直在转圈，像死机了一样关闭不行，又不动，操作不了，其实是因为你的Eclipse还在开着刚才运行的代码，每一个都是独立的线程，数据库工具会因为等待其关闭而处于阻塞状态，在Eclipse的Console界面可以看到右上角有红点，表示在运行中，把所有的红点都关掉就可以了</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//删除
DROP TABLE IF EXISTS `toy_son`;
DROP TABLE IF EXISTS `son`;
DROP TABLE IF EXISTS `toy`;
DROP TABLE IF EXISTS `father`;
DROP TABLE IF EXISTS `mother`;
DROP TABLE IF EXISTS `father`;

//查询
select * from father;
select * from mother;
select * from son;
select * from toy;
select * from toy_son;
</code></pre></div></div>

<h4 id="7其实cascade不是必须的你使用了cascade就可以只保存主表从表会跟着保存你不设置cascade就需要自己手动保存从表">7、其实cascade不是必须的，你使用了cascade就可以只保存主表，从表会跟着保存，你不设置cascade，就需要自己手动保存从表</h4>

<h4 id="8我在下面要用的表的表关系">8、我在下面要用的表的表关系</h4>

<ul>
  <li>
    <p>一个父亲有多个孩子</p>
  </li>
  <li>
    <p>一个父亲有一个妻子</p>
  </li>
  <li>
    <p>多个孩子有多个玩具</p>
  </li>
</ul>

<h4 id="9先来个总结">9、先来个总结</h4>

<ul>
  <li>
    <p>1、主键一对多</p>
  </li>
  <li>
    <p>以一的那方主键作为来个表之间的桥梁，所以是将一那方的字段插到多那方</p>
  </li>
  <li>
    <p>2、非主键一对多</p>
  </li>
  <li>
    <p>以一的那方的某个字段作为来个表之间的桥梁，所以是将一那方的字段插到多那方</p>
  </li>
  <li>
    <p>3、主键多对多</p>
  </li>
  <li>
    <p>两个表都给出主键，插到一个第三方表，这样产生关系，在第三方表就可以通过我的主键查到与我相关的你的主键，再通过你的主键去查你表里的数据</p>
  </li>
  <li>
    <p>4、非主键多对多</p>
  </li>
  <li>
    <p>两个表都给出某一个字段，插到一个第三方表，这样产生关系，在第三方表就可以通过我的字段查到与我相关的你的字段，再通过你的字段去查你表里的数据</p>
  </li>
  <li>
    <p>5、主键一对一</p>
  </li>
  <li>
    <p>不需要在对方的表里插字段，因为是一一对应的，所以我的主键的值就是你主键的值</p>
  </li>
  <li>
    <p>6、非主键一对一</p>
  </li>
  <li>
    <p>7、双向</p>
  </li>
  <li>
    <p>你的表里有与我相关的字段可以查到我，我的表里也有你的字段可以查到你对应的数据</p>
  </li>
  <li>
    <p>8、单向</p>
  </li>
  <li>
    <p>你的表里没有与我相关的字段，在你的表里查不到我，但是我的表里有你的字段，可以查到你对应的数据</p>
  </li>
</ul>

<h2 id="二示例">二、示例</h2>

<ul>
  <li>1、主键一对多示例</li>
  <li>2、非主键一对多示例</li>
  <li>3、主键多对多示例</li>
  <li>4、非主键多对多示例</li>
  <li>5、主键一对一示例</li>
  <li>6、非主键一对一示例</li>
  <li>7、双向示例</li>
  <li>8、单向示例</li>
</ul>

<h4 id="下面的xml示例都会省略头部声明完整的xxhbmxml参考如下">下面的xml示例都会省略头部声明，完整的xx.hbm.xml参考如下：</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?xml version="1.0"?&gt;</span>
<span class="cp">&lt;!DOCTYPE hibernate-mapping PUBLIC
        "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
        "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span>

<span class="nt">&lt;hibernate-mapping</span> <span class="na">package=</span><span class="s">"com.iamzhuwh.more2more"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;class</span> <span class="na">name=</span><span class="s">"Father"</span> <span class="na">table=</span><span class="s">"FATHER"</span><span class="nt">&gt;</span>
         <span class="nt">&lt;id</span> <span class="na">name=</span><span class="s">"f_id"</span> <span class="na">column=</span><span class="s">"F_ID"</span><span class="nt">&gt;</span>
             <span class="nt">&lt;generator</span> <span class="na">class=</span><span class="s">"native"</span><span class="nt">/&gt;</span>
         <span class="nt">&lt;/id&gt;</span>
         <span class="nt">&lt;property</span> <span class="na">name=</span><span class="s">"f_name"</span> <span class="na">type=</span><span class="s">"string"</span> <span class="na">column=</span><span class="s">"F_NAME"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;/class&gt;</span>
<span class="nt">&lt;/hibernate-mapping&gt;</span>
</code></pre></div></div>

<h2 id="1主键一对多示例">1、主键一对多示例</h2>

<h4 id="儿子与父亲的联系在于父亲的f_id因为f_id是唯一可以识别父亲的标识所以将父亲的主键f_id作为外键给儿子以后凭f_id就可以找到父亲对应的儿子啦">儿子与父亲的联系在于父亲的f_id，因为f_id是唯一可以识别父亲的标识，所以将父亲的主键f_id作为外键给儿子，以后凭f_id就可以找到父亲对应的儿子啦</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/** 父亲 */
public class Father {
    /** 父亲的id，主键 */
    private int f_id;
    /** 父亲的名字 */
    private String f_name;
    /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/
    private Set son = new HashSet();
}

/** 儿子 */
public class Son {
    /** 儿子的id，主键 */
    private int s_id;
    /** 儿子的名字 */
    private String s_name;
    /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/
    private Father father;
}

/** 父亲配置文件，Father.hbm.xml */
&lt;hibernate-mapping package="com.iamzhuwh.one2more"&gt;
    &lt;!-- 
        对应的实体类：com.iamzhuwh.one2more.Father
        定义class标签，  &lt;class name="Father" table="FATHER"&gt;
            name是实体类名字，
            table是你要创建的表名
        包名：package="com.iamzhuwh.one2more"
    --&gt;
    &lt;class name="Father" table="FATHER"&gt;
        &lt;!-- id是主键，自增 --&gt;
         &lt;id name="f_id" column="F_ID"&gt;
             &lt;!-- 主键配置 --&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 其他字段 --&gt;
         &lt;property name="f_name" type="string" column="F_NAME"/&gt;
         &lt;set name="son" inverse="false" cascade="all" &gt;
            &lt;!-- 
                一的一方的外键column="f_id" 
                儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识
            --&gt;
            &lt;key column="f_id"&gt;&lt;/key&gt;
            &lt;one-to-many class="com.iamzhuwh.one2more.Son"/&gt;
         &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;

&lt;!-- 儿子配置文件，Son.hbm.xml --&gt;
&lt;hibernate-mapping package="com.iamzhuwh.one2more"&gt;
    &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt;
    &lt;class name="Son" table="SON"&gt;
        &lt;!-- id是主键，自增 --&gt;
         &lt;id name="s_id" column="S_ID"&gt;
             &lt;!-- 主键配置 --&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 其他字段 --&gt;
         &lt;property name="s_name" type="string" column="S_NAME"/&gt;
         &lt;property name="s_f_id" type="int" column="S_F_ID"/&gt;
         &lt;!-- 
            一的一方的外键column="f_id"
            儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识
          --&gt;
         &lt;many-to-one name="father" column="f_id" class="com.iamzhuwh.one2more.Father"&gt;
         &lt;/many-to-one&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;

/** 测试代码 */
public class Test {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        /** 父亲 */
        Father father = new Father();
        father.setF_name("f1");
        /** 儿子 */
        Son son = new Son();
        son.setS_name("s1");
        /** 
            级联  
            增加了父亲的话，可以在这个父亲的名下增加相应的孩子
            但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？
            这就是级联，都是连在一起的
         */
        father.getSon().add(son);
        /** 获取连接 */
        SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        session.beginTransaction();
        /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */
        System.out.println("Father:"+session.save(father));
        /** 提交事务 */
        session.getTransaction().commit();
    }
</code></pre></div></div>

<h2 id="2非主键一对多示例">2、非主键一对多示例</h2>

<h4 id="以上面的代码为基础上面提到了父亲的主键f_id作为外键给儿子以后凭f_id就可以找到父亲对应的儿子那么如果父亲给的外键不是主键呢比如f_name父亲的名字">以上面的代码为基础，上面提到了父亲的主键f_id作为外键给儿子，以后凭f_id就可以找到父亲对应的儿子，那么如果父亲给的外键不是主键呢？比如f_name，父亲的名字</h4>

<ul>
  <li>使用非主键作为外键，这个外键必须是唯一不可重复的，所以要设置unique=”true”</li>
  <li>
    <p>在一的那边使用属性property-ref，即是</p>

    <p>/** 父亲配置 */</p>
    <hibernate-mapping package="com.iamzhuwh.one2more">
      <!-- 对应的实体类，name是实体类名字，table是你要创建的表名 -->
      <class name="Father" table="FATHER">
          <!-- id是主键，自增 -->
           <id name="f_id" column="F_ID">
               <!-- 主键配置 -->
               <generator class="native" />
           </id>
           <!-- 
                  这里变一下
                  unique="true"
           -->
           <property name="f_name" type="string" column="F_NAME" unique="true" />
           <set name="son" inverse="false" cascade="all">
              <!-- 
                  **** 重要 ****
                  这里变一下 property-ref="f_name"
                  用父亲表的父亲名字f_name作为外键，赋予给儿子
                  key column="s_f_name"，这句话只是给加在儿子表的那个字段起个名字叫s_f_name而已
                  使用property-ref="f_name"才是真正将f_name的值赋予给s_f_name
              -->
              <key column="s_f_name" property-ref="f_name"></key>
              <one-to-many class="com.iamzhuwh.one2more.Son" />
           </set>
      </class>
  </hibernate-mapping>
    <p><!-- 儿子配置 --></p>
    <hibernate-mapping package="com.iamzhuwh.one2more">
      <!-- 对应的实体类，name是实体类名字，table是你要创建的表名 -->
      <class name="Son" table="SON">
          <!-- id是主键，自增 -->
           <id name="s_id" column="S_ID">
               <!-- 主键配置 -->
               <generator class="native" />
           </id>
           <!-- 其他字段 -->
           <property name="s_name" type="string" column="S_NAME" />
           <property name="s_f_id" type="int" column="S_F_ID" />
           <!-- 
                  这里变一下，column="s_f_name"
            -->
           <many-to-one name="father" column="s_f_name" class="com.iamzhuwh.one2more.Father">
           </many-to-one>
      </class>
  </hibernate-mapping>
  </li>
</ul>

<h2 id="3主键多对多示例">3、主键多对多示例</h2>

<ul>
  <li>
    <p>多对多的时候，要记住，不是简单给个字段对方而已，要建一个中间表，将双方的外键放上去</p>

    <p>/** 儿子表的实体 */
  public class Son {
      /** 儿子的id，主键 */
      private int s_id;
      /** 儿子的名字 */
      private String s_name;
      /** 儿子的玩具,一个儿子可以拥有多个玩具 */
      private Set toys = new HashSet();
  }</p>

    <p>/** 玩具表的实体 <em>/
  public class Toy {
      /** 玩具的id，主键 */
      private int t_id;
      /** 玩具的名字 */
      private String t_name;
      /** 每个玩具可以被多个人拥有</em>/
      private Set sons = new HashSet();
  }</p>

    <p><!-- 儿子表的配置 --></p>
    <hibernate-mapping package="com.iamzhuwh.more2more">
      <!-- SON表 -->
      <class name="Son" table="SON">
          <!-- 主键，自增 -->
           <id name="s_id" column="S_ID">
               <generator class="native" />
           </id>
           <!-- 其他字段 -->
           <property name="s_name" type="string" column="S_NAME" />
          <!-- 
              儿子可以有多个玩具，所以将儿子的s_id作为外键，<key column="S_ID"></key>
              玩具可以有多个主人，所以将玩具的t_id作为外键，<many-to-many column="T_ID"
              如果让玩具表来处理级联的增删改，需要在玩具的Set标签中配置inverse与cascade
              **** 重点 ****
                  这个table填的是TOY_SON！！！<set name="toys" table="TOY_SON"
                  根据上面一对多的经验，我们是要外键给对方，所以这里填的应该是对方的表名才对吧？
                  但是这里为啥填的是TOY_SON？为啥不是TOY或者SON？
    
              因为要新建一张第三方叫TOY_SON的表，来存放儿子与玩具的外键
    
              <set name="toys"，这里填的是你在Son.java中配置的Set集合的名字：
              private Set toys = new HashSet();/** 儿子的玩具,一个儿子可以拥有多个玩具*/
           -->
          <set name="toys" table="TOY_SON" inverse="true" cascade="all">
              <!-- column="S_ID"，代表是Son给出的外键是S_ID -->
              <key column="S_ID"></key>
              <many-to-many column="T_ID" class="com.iamzhuwh.more2more.Toy"></many-to-many>
               <!-- column="T_ID"，代表是com.iamzhuwh.more2more.Toy给出的外键是T_ID -->
          </set>
      </class>
  </hibernate-mapping>

    <p><!-- 玩具表的配置 --></p>
    <hibernate-mapping package="com.iamzhuwh.more2more">
      <!-- TOY表 -->
      <class name="Toy" table="TOY">
          <!-- id是主键，自增 -->
           <id name="t_id" column="T_ID">
               <!-- 主键配置 -->
               <generator class="native" />
           </id>
           <!-- 其他字段 -->
           <property name="t_name" type="string" column="T_NAME" />
          <!-- 
              玩具可以有多个主人，所以将玩具的t_id作为外键，<key column="T_ID"></key>
              儿子可以有多个玩具，所以将儿子的s_id作为外键，<many-to-many column="S_ID"
              **** 注意 ****
              如果让玩具表来处理级联的增删改，需要在玩具的Set标签中配置inverse与cascade
              但是上面已经让儿子来处理了，所以在玩具这里不用配置inverse与cascade
              **** 重点 ****
                  这个table填的是TOY_SON！！！<set name="sons" table="TOY_SON">
                  根据上面一对多的经验，我们是要外键给对方，所以这里填的应该是对方的表名才对吧？
                  但是这里为啥填的是TOY_SON？为啥不是TOY或者SON？
    
              因为要新建一张第三方叫TOY_SON的表，来存放儿子与玩具的外键
    
              <set name="sons"，这里填的是你在Toy.java中配置的Set集合的名字：
              private Set sons = new HashSet();/** 每个玩具可以被多个人拥有*/
           -->
          <set name="sons" table="TOY_SON">
              <!-- column="T_ID"，代表Toy给出的外键是T_ID -->
              <key column="T_ID"></key>
              <many-to-many column="S_ID" class="com.iamzhuwh.more2more.Son"></many-to-many>
               <!-- column="S_ID"，代表是Son给出的外键是S_ID -->
          </set>
      </class>
  </hibernate-mapping>

    <p>/** 测试代码 */
  public class Test {
      @SuppressWarnings(“unchecked”)
      public static void main(String[] args) {
          /** 玩具 */
          Toy toy = new Toy();
          toy.setT_name(“t1”);
          /** 儿子 */
          Son son = new Son();
          son.setS_name(“s1”);
          /** 级联<br />
              因为在Son配置表中配置了<set name="toys" table="TOY_SON" inverse="true" cascade="all">
              所以级联让Toy来处理，增加了Toy的话，可以把玩具赋给相应的孩子
           */
          toy.getSons().add(son);
          son.getToys().add(toy);
          /** 获取连接 */
          SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
          Session session = sessionFactory.getCurrentSession();
          session.beginTransaction();
          /** 因为是连在一起的，所以保存了儿子，儿子名下的玩具也会被保存 */
          System.out.println("Son:"+session.save(son));
          /** 提交事务 */
          session.getTransaction().commit();
      }
  }</set></p>
  </li>
</ul>

<h2 id="4非主键多对多示例">4、非主键多对多示例</h2>

<p>上面是主键多对多示例，所以使用主键id作为外键，这次是非主键作为外键，所以我们使用名字name作为外键</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;hibernate-mapping package="com.iamzhuwh.more2more"&gt;
    &lt;class name="Son" table="SON"&gt;
         &lt;id name="s_id" column="S_ID"&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 
             这次要用这个s_name作为外键，所以要加一个unique="true"
             让其变为唯一可以代表这个儿子的标识
         --&gt;
         &lt;property name="s_name" type="string" column="S_NAME" unique="true"/&gt;

        &lt;!-- 
            &lt;key column="S_NAME" property-ref="s_name"&gt;&lt;/key&gt;
            解析：
            column="S_NAME"：
                在TOY_SON表中创建一个字段名字叫S_NAME
            property-ref="s_name"：
                这个字段的类型或者值请参考Son配置表的property name="s_name"
            ————————————————————————————————————————————————————
            &lt;many-to-many column="T_NAME" property-ref="t_name"
            解析：
            column="T_NAME"：
                在TOY_SON表中创建一个字段名字叫T_NAME
            property-ref="t_name"：
                这个字段的类型或者值请参考Toy配置表的property name="t_name"
         --&gt;
        &lt;set name="toys" table="TOY_SON" inverse="true" cascade="all" &gt;
            &lt;key column="S_NAME" property-ref="s_name"&gt;&lt;/key&gt;
            &lt;many-to-many column="T_NAME" property-ref="t_name" class="com.iamzhuwh.more2more.Toy"&gt;&lt;/many-to-many&gt;
        &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;


&lt;hibernate-mapping package="com.iamzhuwh.more2more"&gt;
    &lt;class name="Toy" table="TOY"&gt;
         &lt;id name="t_id" column="T_ID"&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 
             这次要用这个t_name作为外键，所以要加一个unique="true"
             让其变为唯一可以代表这个玩具的标识
         --&gt;
         &lt;property name="t_name" type="string" column="T_NAME" unique="true"/&gt;
         &lt;!-- 
            &lt;key column="T_NAME" property-ref="t_name"&gt;&lt;/key&gt;
            解析：
            column="T_NAME"：
                在TOY_SON表中创建一个字段名字叫T_NAME
            property-ref="t_name"：
                这个字段的类型或者值请参考Toy配置表的property name="t_name"
            ————————————————————————————————————————————————————
            &lt;many-to-many column="S_NAME" property-ref="s_name"
            解析：
            column="S_NAME"：
                在TOY_SON表中创建一个字段名字叫S_NAME
            property-ref="s_name"：
                这个字段的类型或者值请参考Son配置表的property name="s_name"
         --&gt;
        &lt;set name="sons" table="TOY_SON"&gt;
            &lt;key column="T_NAME" property-ref="t_name"&gt;&lt;/key&gt;
            &lt;many-to-many column="S_NAME" property-ref="s_name" class="com.iamzhuwh.more2more.Son"&gt;&lt;/many-to-many&gt;
        &lt;/set&gt;

    &lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre></div></div>

<h2 id="5主键一对一示例">5、主键一对一示例</h2>

<p>这个一对一，你查看数据库表，是没有多出字段的，为什么？因为是一一对应的，比如我用我的id就可以找到你的id，因为是一一对应，所以不需要在你的表里插一个我的id</p>

<p>对比一堆多，一的那边会在多的那边插入一个字段，比如id，来表示两者之间存在关系，通过这个id我就可以查找到跟我关联的你的表的数据</p>

<h4 id="使用one-to-one-的方式展示主键一对一示例">使用one to one 的方式展示主键一对一示例</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/** 孩子他爸 */
public class Father {
    /** 丈夫的id，主键 */
    private int f_id;
    /** 丈夫的名字 */
    private String f_name;
    /** 只有一个妻子*/
    private Mother mother;
}

/** 孩子他妈 */
public class Mother {
    /** 妻子的id，主键 */
    private int m_id;
    /** 妻子的名字 */
    private String m_name;
    /** 只有一个丈夫 */
    private Father father;
}

&lt;!-- 孩子他爸的配置 --&gt;
&lt;hibernate-mapping package="com.iamzhuwh.one2one"&gt;
    &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt;
    &lt;class name="Father" table="FATHER"&gt;
        &lt;!-- id是主键，自增 --&gt;
         &lt;id name="f_id" column="F_ID"&gt;
             &lt;!-- 主键配置 --&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 其他字段 --&gt;
         &lt;property name="f_name" type="string" column="F_NAME"/&gt;
         &lt;!-- 
            父母是一对一的，一个丈夫对应一个妻子,所以在丈夫中引入妻子
            &lt;one-to-one name="mother"
            这里就是配置了妻子的信息
            name="mother"代表在Father.java中创建了一个叫mother的变量
                参考Father.java：
                /** 只有一个妻子*/
                private Mother mother;
            property-ref="m_id"代表引用Mother中的m_id作为外键
                参考Mother.hbm.xml：
                &lt;id name="m_id" column="M_ID"&gt;
         --&gt;
         &lt;one-to-one name="mother" property-ref="m_id" cascade="all" class="com.iamzhuwh.one2one.Mother"&gt;&lt;/one-to-one&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;

&lt;!-- 孩子他妈的配置 --&gt;
&lt;hibernate-mapping package="com.iamzhuwh.one2one"&gt;
    &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt;
    &lt;class name="Mother" table="MOTHER"&gt;
        &lt;!-- id是主键，自增 --&gt;
         &lt;id name="m_id" column="M_ID"&gt;
             &lt;!-- 主键配置 --&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 其他字段 --&gt;
         &lt;property name="m_name" type="string" column="M_NAME"/&gt;
         &lt;!-- 
            父母是一对一的，一个丈夫对应一个妻子,所以在妻子中引入丈夫
            &lt;one-to-one name="father"
            这里就是配置了丈夫的信息
            name="father"代表在Mother.java中创建了一个叫father的变量
                参考Mother.java：
                /** 只有一个丈夫 */
                private Father father;
           property-ref="f_id"代表引用Father中的f_id作为外键
                参考Father.hbm.xml：
                &lt;id name="f_id" column="F_ID"&gt;
         --&gt;
         &lt;one-to-one name="father" property-ref="f_id" class="com.iamzhuwh.one2one.Father"&gt;&lt;/one-to-one&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;

/** 测试代码 */
public class Test {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        /** 孩子爸 */
        Father father = new Father();
        father.setF_name("f1");
        /** 孩子妈 */
        Mother mother = new Mother();
        mother.setM_name("m1");
        /** 级联  
            增加丈夫，也可以增加妻子
         */
        father.setMother(mother);
        mother.setFather(father);
        /** 获取连接 */
        SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        session.beginTransaction();
        /** 
            因为在孩子他爸的配置表里面配置了cascade="all"，
            所以这里只需要保存孩子爸，孩子妈就会因为级联而被保存
            如果没有cascade，则孩子妈需要手动保存
        */
        System.out.println("Father:"+session.save(father));
        /** 提交事务 */
        session.getTransaction().commit();
    }
}
</code></pre></div></div>

<h4 id="使用many-to-one-的方式展示主键一对一示例">使用many to one 的方式展示主键一对一示例</h4>

<p>还是在上面的基础上改，改父亲配置表里面的孩子妈配置，将one to one改为more to one，给more to one的字段配置唯一约束unique，它的效果就相当于变成one to one了</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- 修改孩子妈配置表 --&gt;
&lt;many-to-one name="father" column="F_ID" class="com.iamzhuwh.one2one.Father" unique="true"&gt;&lt;/many-to-one&gt;
&lt;!-- 孩子爸配置表还是不变 --&gt;
 &lt;one-to-one name="mother" cascade="all" class="com.iamzhuwh.one2one.Mother"&gt;&lt;/one-to-one&gt;
</code></pre></div></div>

<h2 id="6非主键一对一示例">6、非主键一对一示例</h2>

<p>按上面的经验，在使用one to one的基础上，修改为非主键一对一，以名字作为外键，设置名字唯一的约束unique，其他不变</p>

<h4 id="使用one-to-one-的方式展示非主键一对一示例">使用one to one 的方式展示非主键一对一示例</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- 孩子爸配置表 --&gt;
&lt;property name="f_name" type="string" column="F_NAME" unique="true"/&gt;
&lt;!--引用孩子妈的名字作为外键， property-ref="m_name" --&gt;
&lt;one-to-one name="mother" property-ref="m_name" cascade="all" class="com.iamzhuwh.one2one.Mother"&gt;&lt;/one-to-one&gt;

&lt;!-- 孩子妈配置表 --&gt;      
&lt;property name="m_name" type="string" column="M_NAME" unique="true"/&gt;
&lt;!--引用孩子爸的名字作为外键， property-ref="f_name" --&gt;
&lt;one-to-one name="father" property-ref="f_name" class="com.iamzhuwh.one2one.Father"&gt;&lt;/one-to-one&gt;
</code></pre></div></div>

<h4 id="使用many-to-one-的方式展示非主键一对一示例">使用many to one 的方式展示非主键一对一示例</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;!-- 在上面的进程上修改孩子妈配置表 &lt;one-to-one变&lt;many-to-one --&gt;   
&lt;many-to-one name="father" property-ref="f_name" class="com.iamzhuwh.one2one.Father" unique="true"&gt;&lt;/many-to-one&gt;
</code></pre></div></div>

<h2 id="7双向示例">7、双向示例</h2>

<p>这个是一对多的双向示例，双向就是说通过我可以查到你，通过你可以查到我</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/** 父亲 */
public class Father {
    /** 父亲的id，主键 */
    private int f_id;
    /** 父亲的名字 */
    private String f_name;
    /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/
    private Set son = new HashSet();
}

/** 儿子 */
public class Son {
    /** 儿子的id，主键 */
    private int s_id;
    /** 儿子的名字 */
    private String s_name;
    /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/
    private Father father;
}

/** 父亲配置文件，Father.hbm.xml */
&lt;hibernate-mapping package="com.iamzhuwh.one2more"&gt;
    &lt;!-- 
        对应的实体类：com.iamzhuwh.one2more.Father
        定义class标签，  &lt;class name="Father" table="FATHER"&gt;
            name是实体类名字，
            table是你要创建的表名
        包名：package="com.iamzhuwh.one2more"
    --&gt;
    &lt;class name="Father" table="FATHER"&gt;
        &lt;!-- id是主键，自增 --&gt;
         &lt;id name="f_id" column="F_ID"&gt;
             &lt;!-- 主键配置 --&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 其他字段 --&gt;
         &lt;property name="f_name" type="string" column="F_NAME"/&gt;
         &lt;set name="son" inverse="false" cascade="all" &gt;
            &lt;!-- 
                一的一方的外键column="f_id" 
                儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识
            --&gt;
            &lt;key column="f_id"&gt;&lt;/key&gt;
            &lt;one-to-many class="com.iamzhuwh.one2more.Son"/&gt;
         &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;

&lt;!-- 儿子配置文件，Son.hbm.xml --&gt;
&lt;hibernate-mapping package="com.iamzhuwh.one2more"&gt;
    &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt;
    &lt;class name="Son" table="SON"&gt;
        &lt;!-- id是主键，自增 --&gt;
         &lt;id name="s_id" column="S_ID"&gt;
             &lt;!-- 主键配置 --&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 其他字段 --&gt;
         &lt;property name="s_name" type="string" column="S_NAME"/&gt;
         &lt;property name="s_f_id" type="int" column="S_F_ID"/&gt;
         &lt;!-- 
            一的一方的外键column="f_id"
            儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识
          --&gt;
         &lt;many-to-one name="father" column="f_id" class="com.iamzhuwh.one2more.Father"&gt;
         &lt;/many-to-one&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;

/** 测试代码 */
public class Test {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        /** 父亲 */
        Father father = new Father();
        father.setF_name("f1");
        /** 儿子 */
        Son son = new Son();
        son.setS_name("s1");
        /** 
            级联  
            增加了父亲的话，可以在这个父亲的名下增加相应的孩子
            但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？
            这就是级联，都是连在一起的
         */
        father.getSon().add(son);
        /** 获取连接 */
        SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        session.beginTransaction();
        /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */
        System.out.println("Father:"+session.save(father));
        /** 提交事务 */
        session.getTransaction().commit();
    }
</code></pre></div></div>

<h2 id="8单向示例">8、单向示例</h2>

<p>这个是一对多的单向示例，单向就是说通过我可以查到你，你却查不到我</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/** 父亲 */
public class Father {
    /** 父亲的id，主键 */
    private int f_id;
    /** 父亲的名字 */
    private String f_name;
    /** 可能有多个儿子，所以是集合,对应配置文件的&lt;set one-to-many&gt;*/
    private Set son = new HashSet();
}

/** 儿子 */
public class Son {
    /** 儿子的id，主键 */
    private int s_id;
    /** 儿子的名字 */
    private String s_name;
    /** 只有一个父亲,对应配置文件的&lt;many-to-one&gt;*/
    private Father father;
}

/** 父亲配置文件，Father.hbm.xml */
&lt;hibernate-mapping package="com.iamzhuwh.one2more"&gt;
    &lt;!-- 
        对应的实体类：com.iamzhuwh.one2more.Father
        定义class标签，  &lt;class name="Father" table="FATHER"&gt;
            name是实体类名字，
            table是你要创建的表名
        包名：package="com.iamzhuwh.one2more"
    --&gt;
    &lt;class name="Father" table="FATHER"&gt;
        &lt;!-- id是主键，自增 --&gt;
         &lt;id name="f_id" column="F_ID"&gt;
             &lt;!-- 主键配置 --&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 其他字段 --&gt;
         &lt;property name="f_name" type="string" column="F_NAME"/&gt;
         &lt;set name="son" inverse="false" cascade="all" &gt;
            &lt;!-- 
                一的一方的外键column="f_id" 
                儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识
            --&gt;
            &lt;key column="f_id"&gt;&lt;/key&gt;
            &lt;one-to-many class="com.iamzhuwh.one2more.Son"/&gt;
         &lt;/set&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;

&lt;!-- 儿子配置文件，Son.hbm.xml --&gt;
&lt;hibernate-mapping package="com.iamzhuwh.one2more"&gt;
    &lt;!-- 对应的实体类，name是实体类名字，table是你要创建的表名 --&gt;
    &lt;class name="Son" table="SON"&gt;
        &lt;!-- id是主键，自增 --&gt;
         &lt;id name="s_id" column="S_ID"&gt;
             &lt;!-- 主键配置 --&gt;
             &lt;generator class="native"/&gt;
         &lt;/id&gt;
         &lt;!-- 其他字段 --&gt;
         &lt;property name="s_name" type="string" column="S_NAME"/&gt;
         &lt;!-- 
                一的一方的外键column="f_id"
                儿子与父亲的联系在于父亲的f_id，因为主键f_id是唯一可以识别父亲的标识
                因为现在是单向，所以直接把这里给去掉，这样在父亲表就找不到儿子的踪影了，但是在儿子表可以找到父亲的id
                &lt;many-to-one name="father" column="f_id" class="com.iamzhuwh.one2more.Father"&gt;
                &lt;/many-to-one&gt;
         --&gt;
    &lt;/class&gt;
&lt;/hibernate-mapping&gt;

/** 测试代码 */
public class Test {
    @SuppressWarnings("unchecked")
    public static void main(String[] args) {
        /** 父亲 */
        Father father = new Father();
        father.setF_name("f1");
        /** 儿子 */
        Son son = new Son();
        son.setS_name("s1");
        /** 
            级联  
            增加了父亲的话，可以在这个父亲的名下增加相应的孩子
            但是你随便增加孩子却不行，孩子必须有父亲，没有父亲的孩子哪里来的？石头蹦？孙悟空？
            这就是级联，都是连在一起的
         */
        father.getSon().add(son);
        /** 获取连接 */
        SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();
        Session session = sessionFactory.getCurrentSession();
        session.beginTransaction();
        /** 因为是连在一起的，所以保存了父亲，父亲名下的孩子也会被保存 */
        System.out.println("Father:"+session.save(father));
        /** 提交事务 */
        session.getTransaction().commit();
    }
</code></pre></div></div>

<h2 id="三踩坑">三、踩坑</h2>

<h4 id="问题1">问题1</h4>

<ul>
  <li>Foreign key (FK_9jbtfsoc50vbxnpaladvwbd50:SON [s_id])) must have same number of columns as the referenced primary key (SON [t_id,s_id])</li>
  <li>添加property-ref即可，如： 
<code class="highlighter-rouge">&lt;key column="S_ID" property-ref="s_id"&gt;&lt;/key&gt;</code></li>
</ul>

<h4 id="问题2">问题2</h4>

<ul>
  <li>
    <p>Field ‘S_ID’ doesn’t have a default value 或者 Field ‘T_ID’ doesn’t have a default value</p>
  </li>
  <li>
    <p>我的原因是跟inverse相关，也有人说是在数据库给字段加默认值，或者是主键不要native，但是我的主键本来就是非空且自增，不可能是默认值或者native的问题</p>
  </li>
</ul>

<h4 id="问题3">问题3</h4>

<ul>
  <li>object references an unsaved transient instance – save the transient instance before flushing: com.iamzhuwh.more2more.Son</li>
  <li>son做级联，却保存toy，所以报错，应该是save（son），然后根据级联，son会将里面的toy拿出来保存</li>
</ul>

<h4 id="问题4">问题4</h4>

<p>注意两个事情：(以下面代码为例)</p>

<ul>
  <li>
    <p>首先这里定义了一个字段：</p>
  </li>
  <li><code class="highlighter-rouge">&lt;property name="t_name" type="string" column="T_NAME" unique="true"/&gt;</code></li>
  <li>name=”t_name”是用来在这个配置表中代表这个字段的</li>
  <li>
    <p>column=”T_NAME”是用来代表在数据库中要展示的字段名</p>
  </li>
  <li>
    <p>所以这里要这样引用：</p>
  </li>
  <li><code class="highlighter-rouge">&lt;key column="T_NAME" property-ref="t_name"&gt;&lt;/key&gt;</code></li>
  <li>在数据库定义一个字段叫T_NAME</li>
  <li>
    <p>这个字段的值引用在本配置文件中配置的t_name的信息</p>

    <class name="Toy" table="TOY">
           <id name="t_id" column="T_ID">
               <generator class="native" />
           </id>
           <property name="t_name" type="string" column="T_NAME" unique="true" />
          <set name="sons" table="TOY_SON">
              <key column="T_NAME" property-ref="t_name"></key>
              <many-to-many column="S_NAME" class="com.iamzhuwh.more2more.Son"></many-to-many>
          </set>

</class>
  </li>
</ul>
<h2 id="四课外知识">四、课外知识</h2>

<h2 id="1为什么会有怎么多种关系">1、为什么会有怎么多种关系？</h2>

<p>一对多、多对一、单向、双向是针对不同的情况和业务需求已定的，其实本质是一样的，只是操作的方式不同</p>

<ul>
  <li>
    <p>1、什么是单向与双向？</p>
  </li>
  <li>
    <p>例如：领导叫我查用户与包裹的信息</p>
  </li>
  <li>
    <p>单向一对多：</p>
  </li>
  <li>用户A对于多个包裹，领导叫我在用户表查找用户A的地址，我就查呗</li>
  <li>其实我查询包裹上的信息也可以查到用户A的地址，但是没必要，因为领导说了，到用户表去查</li>
  <li>
    <p>又或者我没有查询包裹信息的权限，所以只有从用户表查</p>
  </li>
  <li>
    <p>单向多对一：</p>
  </li>
  <li>多个包裹对于用户A，领导叫我在包裹信息表里面查用户A的地址，我就查呗</li>
  <li>其实我查询用户表上的信息也可以查到用户A的地址，但是没必要，因为领导说了，到包裹信息表去查</li>
  <li>
    <p>又或者我没有查询用户表的权限，所以只有从包裹信息表查</p>
  </li>
  <li>
    <p>双向一对多/双向多对一：</p>
  </li>
  <li>
    <p>领导又来了，叫我查用户A的地址，不管我怎么查，我从用户表可以查到，从包裹信息表也可以查到</p>
  </li>
  <li>
    <p>懂了么？</p>
  </li>
  <li>
    <p>这就是针对不同的业务需求决定使用哪种映射关系，但是本质都是可以查到目标信息</p>
  </li>
  <li>
    <p>2、什么是一对多与多对一？</p>
  </li>
  <li>
    <p>例如：用户与包裹</p>
  </li>
  <li>用户A买了一堆的东西，那就是一个用户对应多个包裹，也就是一对多</li>
  <li>
    <p>一堆的包裹的收件人都是用户A，那就是多个包裹对应一个用户，也就是多对一</p>
  </li>
  <li>
    <p>3、主键与外键</p>
  </li>
  <li>
    <p>a、什么是主键</p>
  </li>
  <li>
    <p>解释：</p>
  </li>
  <li>一张表中的一条数据，可能会包含多个属性，比如姓名、性别</li>
  <li>已知一张表有多条数据，用什么来区分每条数据？就是用主键了</li>
  <li>不为空的，不重复的，能代表一条数据的，叫主键</li>
  <li>
    <p>什么东西可以作为主键？</p>
  </li>
  <li>一般是XX_id，从1开始自动递增，保证不重复</li>
  <li>
    <p>也可以是一组属性，比如姓名、年龄、性别加起来作为一个主键</p>
  </li>
  <li>
    <p>例子：</p>
  </li>
  <li>例如一个人，身份证号码可以作为他的唯一标示，也就是主键</li>
  <li>
    <p>例如一台电视，品牌、型号、序列号加起来可以作为它的唯一标示，也就是主键</p>
  </li>
  <li>
    <p>b、什么是外键</p>
  </li>
  <li>
    <p>解释：</p>
  </li>
  <li>在自己的表中，有一个字段，可以确定另一张表的数据的唯一性，叫外键</li>
  <li>这个字段，对另一张表来说，叫主键，对自己的这张表来说，叫外键</li>
  <li>
    <p>a表与b表，a表中的某一个字段可以区分b表的每一条数据，这个字段就是a表的外键，是b表的主键</p>
  </li>
  <li>
    <p>例子：</p>
  </li>
  <li>比如一件快递包裹</li>
  <li>在天猫商家的系统里，有这个包裹的购买人id、订单号、电话、快递单号等信息，主键是订单号，通过订单号区分每一个订单</li>
  <li>在快递公司的系统里，有这个包裹的快递单号、收件人、电话、地址等信息，主键是快递单号，通过快递单号区分每一个包裹</li>
  <li>对快递公司来说，这个快递单号是主键</li>
  <li>对天猫商家来说，这个快递单号是外键</li>
  <li>
    <p>我通过订单号可以查到所有订单信息，然后从中找到快递单号，然后在快递表里查快递单号，就可以查到包裹的物流信息</p>
  </li>
  <li>
    <p>c、区别</p>
  </li>
  <li>
    <p>主键</p>
  </li>
  <li>唯一标识一条记录，不能有重复的，不允许为空</li>
  <li>用来保证数据完整性</li>
  <li>
    <p>一张表主键只能有一个</p>
  </li>
  <li>
    <p>外键</p>
  </li>
  <li>表的外键是给另一张表使用的，这个外键在另一张表里可以重复,可以是空值。但是在自己表里必须是唯一的，不然你怎么么代表自己表里的一条数据</li>
  <li>用来和其他表创建联系用的</li>
  <li>
    <p>一个表可以有多个外键</p>
  </li>
  <li>
    <p>4、一对一</p>
  </li>
  <li>
    <p>a、单向一对一主键关联</p>
  </li>
  <li>简单来说，我的主键，就是我的外键，也就是你的主键，一样的值</li>
  <li>
    <p>单向的意思就是，只可以我用我的外键查你，你不查我</p>
  </li>
  <li>
    <p>b、双向一对一主键关联</p>
  </li>
  <li>简单来说，我的主键，就是我的外键，也就是你的主键，一样的值</li>
  <li>
    <p>双向的意思就是，我可以查你，你可以查我</p>
  </li>
  <li>
    <p>c、单向一对一外键关联</p>
  </li>
  <li>简单来说，我的主键很宝贵，不给你，那么我的其他字段呢，可以作为我的外键，给你当主键用</li>
  <li>
    <p>单向的意思就是，只可以我用我的外键查你，你不查我</p>
  </li>
  <li>
    <p>d、双向一对一外键关联</p>
  </li>
  <li>简单来说，我的主键很宝贵，不给你，那么我的其他字段呢，可以作为我的外键，给你当主键用</li>
  <li>
    <p>双向的意思就是，我可以查你，你可以查我</p>
  </li>
  <li>
    <p>e、一对一外键关联的注意点</p>
  </li>
  <li>因为是一对一，所以是唯一的，所以我的外键也要是唯一的，所以要设置属性unique=true</li>
  <li>那为什么一对一主键关联不需要设置这个属性呢，因为两边都是主键啊，主键本来就是唯一且非空的</li>
</ul>

<h2 id="2什么是级联">2、什么是级联</h2>

<ul>
  <li>
    <p>比如主表改了数据，子表相关的数据也会跟着变化，这就是级联</p>
  </li>
  <li>例如用户表里面，用户的地址改了，那么包裹的地址也要跟着变化</li>
  <li>用实体类来说，Father就是那个主表，里面有一个set集合的变量，son就是set集合中的一个元素，所以是father.getSon().add(son);</li>
</ul>

<h2 id="-cascade参数">– cascade参数</h2>

<ul>
  <li>
    <p>cascade=”all</p>
  </li>
  <li>
    <p>所有情况下均进行关联操作,包括save、update、delete</p>
  </li>
  <li>
    <p>cascade=”none”</p>
  </li>
  <li>
    <p>cascade=”save-update”</p>
  </li>
  <li>
    <p>仅save、update、saveOrUpdate时进行关联操作</p>
  </li>
  <li>
    <p>cascade=”delete”</p>
  </li>
  <li>
    <p>cascade=”all-delete-orphan”</p>
  </li>
  <li>用户对应多个包裹，其中一个包裹，用户不要了，这个包裹就被干掉了</li>
  <li>当一个节点在对象图中成为孤儿节点时，删除该节点（摘自百度）</li>
</ul>

<h2 id="-inverse参数">– inverse参数</h2>

<ul>
  <li>
    <p>这个参数决定谁来维护这个关联关系，它只在主表的那个配置文件里面配置</p>
  </li>
  <li>
    <p>什么是关联关系，即是主表更新了，主表要去更新一下子表吗？还是让子表自己更新？</p>
  </li>
  <li>
    <p>inverse=”false”，代表指定Father维护这个关联关系，即主表更新的同时，子表也更新了，然后主表还要更新一下子表</p>
  </li>
  <li>比如有Father表，有f_id，Son表，也有f_id，因为两个是关联的嘛，然后更新Father表，Son表也会一起更新，但是这个时候Son表的f_id是空的，因为Father表还没更新完</li>
  <li>
    <p>待Father表更新完了，然后Son表也更新完了，Father表会将新增的那个f_id扔给Son表去update一下刚才空的f_id</p>
  </li>
  <li>
    <p>inverse=”true”，代表指定Son维护这个关联关系，即主表更新后，子表再更新更新</p>
  </li>
  <li>
    <p>比如有Father表，有f_id，Son表，也有f_id，因为两个是关联的嘛，然后更新Father表，Son表是不会有动静的，待Father表更新完了，把f_id扔给Son表，然后Son表再默默的更新自己的信息</p>
  </li>
  <li>
    <h2 id="懂了不再看例子">懂了不，再看例子</h2>
  </li>
  <li>
    <p>Father表配置 <code class="highlighter-rouge">&lt;set name="son" inverse="true" cascade="all" &gt;</code></p>

    <p>Hibernate: insert into FATHER (F_NAME) values (?)</p>

    <p>//inverse=”true”，代表指定Son维护这个关联关系，即主表更新了，子表自己更新</p>

    <p>Hibernate: insert into SON (S_NAME, f_id) values (?, ?)</p>
  </li>
  <li>
    <p>Father表配置 <code class="highlighter-rouge">&lt;set name="son" inverse="false" cascade="all" &gt;</code></p>

    <p>Hibernate: insert into FATHER (F_NAME) values (?)
Hibernate: insert into SON (S_NAME, f_id) values (?, ?)</p>

    <p>//这里多了一次更新操作，为啥？
//因为inverse=”false”，代表指定Father维护这个关联关系，即主表更新了，子表更新了，主表还要去更新一下子表
//所以主表更新了自己之后，又去更新了一下子表的F_ID</p>

    <p>Hibernate: update SON set f_id=? where S_ID=?</p>
  </li>
  <li>cascade与inverse</li>
  <li>这个时候，大家可能又懵逼了，什么鬼啊，cascade=all的时候，不是已经级联了吗，不是主表更新子表也跟着更新了吗？！！</li>
  <li>其实是这样的，主表更新，子表也跟着更新，这个是cascade级联的作用</li>
  <li>粗暴的理解：让主表还是从表去控制子表的更新，这个是inverse的作用。配合上面的例子慢慢体会</li>
</ul>

<h2 id="3主键的类别">3、主键的类别：</h2>

<h4 id="assigned">Assigned</h4>

<ul>
  <li>由用户生成主键值，并且要在save()之前指定否则会抛出异常</li>
</ul>

<h4 id="hilo">Hilo</h4>

<ul>
  <li>使用高低位算法生成主键，高低位算法使用一个高位值和一个低位值，然后把算法得到的两个值拼接起来作为数据库中的唯一主键</li>
</ul>

<h4 id="increment">Increment</h4>

<ul>
  <li>对主键值采取自动增长的方式生成新的主键值，但要求底层数据库的主键类型为long,int等数值型。主键按数值顺序递增，增量为1。</li>
  <li>主键值由Hibernate本身维护，适用于所有的数据库，不适合多进程并发更新数据库</li>
</ul>

<h4 id="identity">Identity</h4>

<ul>
  <li>根据底层数据库，来支持自动增长</li>
  <li>例如MySQl中是auto_increment, SQL Server 中是Identity</li>
</ul>

<h4 id="sequence">Sequence</h4>

<h4 id="native">Native</h4>

<ul>
  <li>根据不同的底层数据库自动选择Identity、Sequence、Hilo主键生成方式</li>
  <li>便于程序移植，项目中如果用到多个数据库时，可以使用这种方式。</li>
</ul>

<h4 id="uuid">UUID</h4>

<ul>
  <li>使用128位UUID算法生成主键，能够保证网络环境下的主键唯一性，也就能够保证在不同数据库及不同服务器下主键的唯一性</li>
</ul>

<h4 id="foreign-guid">Foreign GUID</h4>

<ul>
  <li>用于一对一关系中。GUID主键生成方式使用了一种特殊算法，保证生成主键的唯一性，支持SQL Server和MySQL</li>
</ul>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/hibernate%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB%E4%B8%8E%E7%BA%A7%E8%81%94%E4%B8%80%E5%AF%B9%E4%B8%80%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%A4%9A%E5%AF%B9%E5%A4%9A.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/%E6%8E%92%E6%9F%A5spring%E4%BA%8B%E5%8A%A1%E4%B8%8D%E7%94%9F%E6%95%88.html">&laquo; 排查spring事务不生效</a>
  
  
  <a class="next" href="/2017/mybatis%E7%8E%AF%E5%A2%83%E7%9A%84%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA.html">MyBatis环境的简单搭建 &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
