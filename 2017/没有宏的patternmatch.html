<!-- build time:Sat Oct 27 2018 21:00:20 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="宏在lisp里面是一柄双刃剑，我一般是能避免使用尽量避免的，也在一直思考有没有什么能替代它。上次看到了fexpr，研究了一下，知道了fexpr和宏的区别。它们都不会对参数求值，都是把参数以原始的list形式传递。接着，它们都会调用自己的定义，对list进行展开，这一步也是相同的。最后一步才是区别：宏会对展开以后生成的表达式求值，而fexpr直接返回展开的结果。这个设定使得fexpr比宏更加动态，使"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="没有宏的pattern match"><meta property="og:url" content="http://www.jfox.info/2017/没有宏的patternmatch.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="宏在lisp里面是一柄双刃剑，我一般是能避免使用尽量避免的，也在一直思考有没有什么能替代它。上次看到了fexpr，研究了一下，知道了fexpr和宏的区别。它们都不会对参数求值，都是把参数以原始的list形式传递。接着，它们都会调用自己的定义，对list进行展开，这一步也是相同的。最后一步才是区别：宏会对展开以后生成的表达式求值，而fexpr直接返回展开的结果。这个设定使得fexpr比宏更加动态，使"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:39.382Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="没有宏的pattern match"><meta name="twitter:description" content="宏在lisp里面是一柄双刃剑，我一般是能避免使用尽量避免的，也在一直思考有没有什么能替代它。上次看到了fexpr，研究了一下，知道了fexpr和宏的区别。它们都不会对参数求值，都是把参数以原始的list形式传递。接着，它们都会调用自己的定义，对list进行展开，这一步也是相同的。最后一步才是区别：宏会对展开以后生成的表达式求值，而fexpr直接返回展开的结果。这个设定使得fexpr比宏更加动态，使"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/没有宏的patternmatch.html"><title>没有宏的pattern match | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/没有宏的patternmatch.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">没有宏的pattern match</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:54:21+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>宏在lisp里面是一柄双刃剑，我一般是能避免使用尽量避免的，也在一直思考有没有什么能替代它。上次看到了fexpr，研究了一下，知道了fexpr和宏的区别。它们都不会对参数求值，都是把参数以原始的list形式传递。接着，它们都会调用自己的定义，对list进行展开，这一步也是相同的。最后一步才是区别：宏会对展开以后生成的表达式求值，而fexpr直接返回展开的结果。</p><p>这个设定使得fexpr比宏更加动态，使语言无法静态分析，编译期更加模煳，或者说，编译器跟运行期搅和更严重，无法脱离eval。所以似乎也不是一个我想要的东西。</p><p>如果没有宏，函数的极限在哪里？</p><p>以实现pattern match为例，我想这样写：</p><pre><code>(pmatch x
        ((:cons a b) (+ a b))
        ((:nil) 42))
</code></pre><p>如果x是一个cons，pattern match会将a绑定到第一个，将b绑定到第二个，然后执行 <code>(+ a b)</code> 。没有宏的情况下，最接近能做到这个程度：</p><pre><code>(pmatch (cons 1 2)
        (:cons (lambda (a b) (+ a b)))
        (:nil (lambda () 42)))
</code></pre><p>如果判断是cons，则在一个函数里面计算 <code>(+ a b)</code> ，则 <code>:cons</code> 负责提供函数的参数，a绑定到第一个，b绑定到第二个。</p><p>先摆最终代码，别看代码不长，这可花了我一晚上才写出来。</p><pre><code>(define (selector is? . get)
  (lambda (f)
    (lambda (x)
      (lambda (cc)
        (if (is? x)
            (apply f (map (lambda (f) (f x)) get))
            (cc x))))))
(define pmatch
  (lambda (x . sel)
    (if (null? sel)
        (error &apos;panic)
        (((car sel) x)
        (lambda (x0)
          (apply pmatch (cons x0 (cdr sel))))))))
(define :cons (selector pair? car cdr))
(define :nil (selector null?))
</code></pre><p>TL;DR</p><p>lisp是高度抽象的，代码很短，背后的思维却异常的复杂。如果别人不告诉你怎么推出来的，代码跟本看不懂。</p><p>首先，pmatch函数的参数，应试是一个值，后面跟若干个函数，后面的函数依次对传值x进行计算，如果通过了就结束，没通过就继续尝试下一个。</p><pre><code>(pmatch (cons 1 2) sel1 sel2)
</code></pre><p>然后想sel1，sel2展开以后，应该是类似于这样子：</p><pre><code>(lambda (x)
  (if (pair? x)
      ((lambda (a b) (+ a b)) (car x) (cdr x))
      ?))
(lambda (x)
  (if (null? x)
      ((lambda () 42))
      ?))
</code></pre><p>由于要依次比较，我们要做一个CPS变换(这是个重点)，得到</p><pre><code>(lambda (cc)
  (lambda (x)
    (if (pair? x)
        ((lambda (a b) (+ a b)) (car x) (cdr x))
        (cc x))))
</code></pre><p>完整的写下来：</p><pre><code>(lambda (x)
  (let* ((:cons (lambda (cc)
                  (lambda (x)
                    (if (pair? x)
                        (      (lambda (a b) (+ a b))     (car x) (cdr x))
                        (cc x)))))
        (:nil (lambda (cc)
                (lambda (x)
                  (if (null? x)
                      (       (lambda () 42)    )
                      (cc x)))))
        (cc0 (lambda (_) (error &apos;panic)))
        (cc1 (:nil cc0))
        (cc2 (:cons cc1)))
    (cc2 x)))
</code></pre><p>验证一下，拿它个调用 <code>(cons 1 2)</code> 得到3，调用 <code>&#39;()</code> 得到42，好，继续往下。</p><pre><code>(lambda (x)
  (let* ((:cons (lambda (cc)
                  (lambda (x)
                    (if (pair? x)
                        (      ????     (car x) (cdr x))
                        (cc x)))))
        (:nil (lambda (cc)
                (lambda (x)
                  (if (null? x)
                      (       ????    )
                      (cc x)))))
        (cc0 (lambda (_) (error &apos;panic)))
        (cc1 (:nil cc0))
        (cc2 (:cons cc1)))
    (cc2 x)))
</code></pre><p><code>????</code> 是要作为参数传进去的，我们提取成参数 <code>f</code> 和 <code>g</code> ，再交换一下参数顺序，就变成了：</p><pre><code>(let* ((:cons (lambda (f)
                (lambda (x)
                  (lambda (cc)
                    (if (pair? x)
                        (f (car x) (cdr x))
                        (cc x)))
                  )))
      (f (lambda (a b) (+ a b)))
      (:nil (lambda (f)
              (lambda (x)
                (lambda (cc)
                  (if (null? x)
                      (f)
                      (cc x)))
                )))
      (g (lambda () 42))
      (cc0 (lambda (_) (error &apos;panic)))
      (cc1 (lambda (x) (((:nil g) x) cc0)))
      (cc2 (lambda (x) (((:cons f) x) cc1))))
  (cc2 x))
</code></pre><p>上面的 <code>:cons</code> 和 <code>:nil</code> 是可以单独拿出来的：</p><pre><code>(define :nil
  (lambda (f)
    (lambda (x)
      (lambda (cc)
        (if (null? x)
            (f)
            (cc x)))
      )))
(define :cons
  (lambda (f)
    (lambda (x)
      (lambda (cc)
        (if (pair? x)
            (f (car x) (cdr x))
            (cc x)))
      )))
</code></pre><p>接下来又是个重点， <code>:nil</code> 和 <code>:cons</code> 结构是比较类似的，我希望只保留必须的代码，尽量不要重复。</p><p>必要的信息包括判断是否是某个类型 <code>pair?</code> ， <code>null?</code> ，以及取结构里面某个域 <code>car</code> ， <code>cdr</code> 。</p><pre><code>(define :cons (selector pair? car cdr))
(define :cons
  (lambda (f)
    (lambda (x)
      (lambda (cc)
        (if (pair? x)
            (f (car x) (cdr x))
            (cc x)))
      )))
</code></pre><p>需要让两者是等价的。那么如何定义 <code>selector</code> 呢？</p><pre><code>(define (selector pair? car cdr)
  (lambda (f)
    (lambda (x)
      (lambda (cc)
        (if (pair? x)
            (f (car x) (cdr x))
            (cc x))))))
(define (selector nil?)
  (lambda (f)
    (lambda (x)
      (lambda (cc)
        (if (nil? x)
            (f)
            (cc x))))))
</code></pre><p>于是抽象出 <code>selector</code> 的定义：</p><pre><code>(define (selector is? . get)
  (lambda (f)
    (lambda (x)
      (lambda (cc)
        (if (is? x)
            (apply f (map (lambda (f) (f x)) get))
            (cc x))))))
</code></pre><p>接下来看 <code>pmatch</code> ，它应该是这样子的：</p><pre><code>(define pmatch
  (lambda (x sel1 sel2)
    (let* ((cc0 (lambda (_) (error &apos;panic)))
          (cc1 (lambda (x) ((sel2 x) cc0)))
          (cc2 (lambda (x) ((sel1 x) cc1))))
      (cc2 x))))
</code></pre><p>其中 <code>sel1</code> 和 <code>sel2</code> 分别是：</p><pre><code>(:cons (lambda (a b) (+ a b)))
(:nil (lambda () 42))
</code></pre><p>写成let不太方便，如果把pmatch的let展开，就是:</p><pre><code>(define pmatch
  (lambda (x sel1 sel2)
    ((sel1 x)
    (lambda (x)
      ((sel2 x)
        (lambda (_)
          (error &apos;panic)))))))
</code></pre><p>最后为了处理许多的selector，把参数做变成长的：</p><pre><code>(define pmatch
  (lambda (x . sel)
    (if (null? sel)
        (error &apos;panic)
        (((car sel) x)
        (lambda (x0)
          (apply pmatch (cons x0 (cdr sel))))))))
</code></pre><p>推导结束，以上！</p><p>再放几个好玩的，比如说定义option类型</p><pre><code>(define :some (selector vector? (lambda (x) (vector-ref x 0))))
(define :none (selector null?))
(pmatch #(5)
        (:some (lambda (x) x))
        (:none (lambda () 42)))
</code></pre><p>再比如实现else：</p><pre><code>(define :else (selector (lambda (x) #t) (lambda (x) x)))
(pmatch &apos;(a b c)
        (:cons (lambda (a b) (+ a b)))
        (:nil (lambda () 42))
        (:else (lambda (x) x)))
</code></pre><p><a href="void(0">点赞</a>)<a href="https://www.jfox.info/go.php?url=http://ju.outofmemory.cn/tag/Pattern/">Pattern</a><a href="https://www.jfox.info/go.php?url=http://ju.outofmemory.cn/tag/match/">match</a><a href="https://www.jfox.info/go.php?url=http://ju.outofmemory.cn/tag/%E5%AE%8F/">宏</a></p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/我是如何找一个影响数千职业网站的持续型xss的.html" rel="next" title="我是如何找一个影响数千职业网站的持续型XSS的"><i class="fa fa-chevron-left"></i> 我是如何找一个影响数千职业网站的持续型XSS的</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/apachewicket发布web开发框架.html" rel="prev" title="Apache Wicket 发布，Web 开发框架">Apache Wicket 发布，Web 开发框架 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->