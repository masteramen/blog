<!-- build time:Sat Oct 27 2018 21:00:22 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="H2M_LI_HEADER Java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。H2M_LI_HEADER 使用Quartz，这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。H2M_LI_HEADER Spring"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="Spring定时任务之使用"><meta property="og:url" content="http://www.jfox.info/2017/spring定时任务之使用.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="H2M_LI_HEADER Java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。H2M_LI_HEADER 使用Quartz，这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。H2M_LI_HEADER Spring"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.418Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring定时任务之使用"><meta name="twitter:description" content="H2M_LI_HEADER Java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。H2M_LI_HEADER 使用Quartz，这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。H2M_LI_HEADER Spring"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/spring定时任务之使用.html"><title>Spring定时任务之使用 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/spring定时任务之使用.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Spring定时任务之使用</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:51:34+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>H2M_LI_HEADER Java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。<br>H2M_LI_HEADER 使用Quartz，这是一个功能比较强大的的调度器，可以让你的程序在指定时间执行，也可以按照某一个频度执行，配置起来稍显复杂。<br>H2M_LI_HEADER Spring3.0以后自带的task，可以将它看成一个轻量级的Quartz，而且使用起来比Quartz简单许多。</p><ol><li>作业类需要继承自特定的作业类基类，如Quartz中需要继承自org.springframework.scheduling.quartz.QuartzJobBean；java.util.Timer中需要继承自java.util.TimerTask。</li><li>作业类即普通的java类，不需要继承自任何基类。</li></ol><p>注:个人推荐使用第二种方式，因为这样所以的类都是普通类，不需要事先区别对待。</p><ul><li>从任务调度的触发时机来分，这里主要是针对作业使用的触发器，主要有以下两种：</li></ul><ol><li>每隔指定时间则触发一次，在Quartz中对应的触发器为：org.springframework.scheduling.quartz.SimpleTriggerBean</li><li>每到指定时间则触发一次，在Quartz中对应的调度器为：org.springframework.scheduling.quartz.CronTriggerBean</li></ol><p>注：并非每种任务都可以使用这两种触发器，如java.util.TimerTask任务就只能使用第一种。Quartz和spring task都可以支持这两种触发条件。</p><p>详细介绍每种任务调度工具的使用方式，包括Quartz和spring task两种。</p><h2 id="Quartz"><a href="#Quartz" class="headerlink" title="Quartz"></a>Quartz</h2><h3 id="第一种，作业类继承自特定的基类：org-springframework-scheduling-quartz-QuartzJobBean。"><a href="#第一种，作业类继承自特定的基类：org-springframework-scheduling-quartz-QuartzJobBean。" class="headerlink" title="第一种，作业类继承自特定的基类：org.springframework.scheduling.quartz.QuartzJobBean。"></a>第一种，作业类继承自特定的基类：org.springframework.scheduling.quartz.QuartzJobBean。</h3><p><strong>第一步：定义作业类</strong></p><pre><code>Java代码  
</code></pre><ol><li>import org.quartz.JobExecutionContext;</li><li>import org.quartz.JobExecutionException;</li><li>import org.springframework.scheduling.quartz.QuartzJobBean;</li><li>public class Job1 extends QuartzJobBean {</li><li>private int timeout;</li><li>private static int i = 0;</li><li>//调度工厂实例化后，经过timeout时间开始执行调度</li><li>public void setTimeout(int timeout) {</li><li>this.timeout = timeout;</li><li>}</li><li>/**</li><li><ul><li>要调度的具体任务</li></ul></li><li>*/</li><li>@Override</li><li>protected void executeInternal(JobExecutionContext context)</li><li>throws JobExecutionException {</li><li>System.out.println(“定时任务执行中…”);</li><li>}</li><li>}</li></ol><p><strong>第二步：spring配置文件中配置作业类JobDetailBean</strong></p><pre><code>Xml代码  
</code></pre><ol><li><bean name="“job1”" class="“org.springframework.scheduling.quartz.JobDetailBean”"></bean></li><li><property name="“jobClass”" value="“com.gy.Job1”"></property></li><li><property name="“jobDataAsMap”"></property></li><li><map></map></li><li><entry key="“timeout”" value="“0”"></entry></li><li></li><li></li><li><p></p><p>说明：org.springframework.scheduling.quartz.JobDetailBean有两个属性，jobClass属性即我们在java代码中定义的任务类，jobDataAsMap属性即该任务类中需要注入的属性值。</p></li></ol><p><strong>第三步：配置作业调度的触发方式（触发器）</strong></p><p>Quartz的作业触发器有两种，分别是</p><p>org.springframework.scheduling.quartz.SimpleTriggerBean</p><p>org.springframework.scheduling.quartz.CronTriggerBean</p><p>第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。</p><p>配置方式如下：</p><pre><code>Xml代码  
</code></pre><ol><li><bean id="“simpleTrigger”" class="“org.springframework.scheduling.quartz.SimpleTriggerBean”"></bean></li><li><property name="“jobDetail”" ref="“job1”"></property></li><li><property name="“startDelay”" value="“0”">&lt;!– 调度工厂实例化后，经过0秒开始执行调度 –&gt;</property></li><li><property name="“repeatInterval”" value="“2000”">&lt;!– 每2秒调度一次 –&gt;</property></li><li></li></ol><p>第二种CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。</p><p>配置方式如下：</p><pre><code>Xml代码  
</code></pre><ol><li><bean id="“cronTrigger”" class="“org.springframework.scheduling.quartz.CronTriggerBean”"></bean></li><li><property name="“jobDetail”" ref="“job1”"></property></li><li>&lt;!—每天12:00运行一次 —&gt;</li><li><property 0="" 12="" name="“cronExpression”" value="“0" *="" ?”=""></property></li><li><p></p><p>关于cronExpression表达式的语法参见附录。</p></li></ol><p><strong>第四步：配置调度工厂</strong></p><pre><code>Xml代码  
</code></pre><ol><li><bean class="“org.springframework.scheduling.quartz.SchedulerFactoryBean”"></bean></li><li><property name="“triggers”"></property></li><li><list></list></li><li><ref bean="“cronTrigger”"></ref></li><li></li><li></li><li><p></p><p>说明：该参数指定的就是之前配置的触发器的名字。</p></li></ol><p><strong>第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。</strong></p><h3 id="第二种，作业类不继承特定基类。"><a href="#第二种，作业类不继承特定基类。" class="headerlink" title="第二种，作业类不继承特定基类。"></a>第二种，作业类不继承特定基类。</h3><p>Spring能够支持这种方式，归功于两个类：</p><p>org.springframework.scheduling.timer.MethodInvokingTimerTaskFactoryBean</p><p>org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean</p><p>这两个类分别对应spring支持的两种实现任务调度的方式，即前文提到到java自带的timer task方式和Quartz方式。这里我只写MethodInvokingJobDetailFactoryBean的用法，使用该类的好处是,我们的任务类不再需要继承自任何类，而是普通的pojo。</p><p><strong>第一步：编写任务类</strong></p><pre><code>Java代码  
</code></pre><ol><li>public class Job2 {</li><li>public void doJob2() {</li><li>System.out.println(“不继承QuartzJobBean方式-调度进行中…”);</li><li>}</li><li><p>}</p><p>可以看出，这就是一个普通的类，并且有一个方法。</p></li></ol><p><strong>第二步：配置作业类</strong></p><pre><code>Xml代码  
</code></pre><ol><li>&lt;bean id=“job2”</li><li>class=“org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean”&gt;</li><li><property name="“targetObject”"></property></li><li><bean class="“com.gy.Job2”"></bean></li><li></li><li><property name="“targetMethod”" value="“doJob2”"></property></li><li><property name="“concurrent”" value="“false”">&lt;!– 作业不并发调度 –&gt;</property></li><li><p></p><p>说明：这一步是关键步骤，声明一个MethodInvokingJobDetailFactoryBean，有两个关键属性：targetObject指定任务类，targetMethod指定运行的方法。往下的步骤就与方法一相同了，为了完整，同样贴出。</p></li></ol><p><strong>第三步：配置作业调度的触发方式（触发器）</strong></p><p>Quartz的作业触发器有两种，分别是</p><p>org.springframework.scheduling.quartz.SimpleTriggerBean</p><p>org.springframework.scheduling.quartz.CronTriggerBean</p><p>第一种SimpleTriggerBean，只支持按照一定频度调用任务，如每隔30分钟运行一次。</p><p>配置方式如下：</p><pre><code>Xml代码  
</code></pre><ol><li><bean id="“simpleTrigger”" class="“org.springframework.scheduling.quartz.SimpleTriggerBean”"></bean></li><li><property name="“jobDetail”" ref="“job2”"></property></li><li><property name="“startDelay”" value="“0”">&lt;!– 调度工厂实例化后，经过0秒开始执行调度 –&gt;</property></li><li><property name="“repeatInterval”" value="“2000”">&lt;!– 每2秒调度一次 –&gt;</property></li><li><p></p><p>第二种CronTriggerBean，支持到指定时间运行一次，如每天12:00运行一次等。</p></li></ol><p>配置方式如下：</p><pre><code>Xml代码  
</code></pre><ol><li><bean id="“cronTrigger”" class="“org.springframework.scheduling.quartz.CronTriggerBean”"></bean></li><li><property name="“jobDetail”" ref="“job2”"></property></li><li>&lt;!—每天12:00运行一次 —&gt;</li><li><property 0="" 12="" name="“cronExpression”" value="“0" *="" ?”=""></property></li><li></li></ol><p>以上两种调度方式根据实际情况，任选一种即可。</p><p><strong>第四步：配置调度工厂</strong></p><pre><code>Xml代码  
</code></pre><ol><li><bean class="“org.springframework.scheduling.quartz.SchedulerFactoryBean”"></bean></li><li><property name="“triggers”"></property></li><li><list></list></li><li><ref bean="“cronTrigger”"></ref></li><li></li><li></li><li></li></ol><p>说明：该参数指定的就是之前配置的触发器的名字。</p><p><strong>第五步：启动你的应用即可，即将工程部署至tomcat或其他容器。</strong></p><p>到此，spring中Quartz的基本配置就介绍完了，当然了，使用之前，要导入相应的spring的包与Quartz的包，这些就不消多说了。</p><p>其实可以看出Quartz的配置看上去还是挺复杂的，没有办法，因为Quartz其实是个重量级的工具，如果我们只是想简单的执行几个简单的定时任务，有没有更简单的工具，有！</p><p>请看我第下文Spring task的介绍。</p><h2 id="Spring-Task"><a href="#Spring-Task" class="headerlink" title="Spring-Task"></a>Spring-Task</h2><p>上节介绍了在Spring 中使用Quartz，本文介绍Spring3.0以后自主开发的定时任务工具，spring task，可以将它比作一个轻量级的Quartz，而且使用起来很简单，除spring相关的包外不需要额外的包，而且支持注解和配置文件两种</p><p>形式，下面将分别介绍这两种方式。</p><h3 id="第一种：配置文件方式"><a href="#第一种：配置文件方式" class="headerlink" title="第一种：配置文件方式"></a>第一种：配置文件方式</h3><p><strong>第一步：编写作业类</strong></p><p>即普通的pojo，如下：</p><pre><code>Java代码  
</code></pre><ol><li>import org.springframework.stereotype.Service;</li><li>@Service</li><li>public class TaskJob {</li><li>public void job1() {</li><li>System.out.println(“任务进行中。。。”);</li><li>}</li><li>}</li></ol><p><strong>第二步：在spring配置文件头中添加命名空间及描述</strong></p><pre><code>Xml代码  
</code></pre><ol><li>&lt;beans xmlns=“<a href="http://www.springframework.org/schema/beans”" target="_blank" rel="noopener">http://www.springframework.org/schema/beans”</a></li><li>xmlns:task=“<a href="http://www.springframework.org/schema/task”" target="_blank" rel="noopener">http://www.springframework.org/schema/task”</a></li><li>。。。。。。</li><li>xsi:schemaLocation=“<a href="http://www.springframework.org/schema/task" target="_blank" rel="noopener">http://www.springframework.org/schema/task</a> <a href="http://www.springframework.org/schema/task/spring-task-3.0.xsd”&gt;" target="_blank" rel="noopener">http://www.springframework.org/schema/task/spring-task-3.0.xsd”&gt;</a></li></ol><p><strong>第三步：spring配置文件中设置具体的任务</strong></p><pre><code>Xml代码  
</code></pre><ol><li><a href="task:scheduled-tasks" target="_blank" rel="noopener">task:scheduled-tasks</a></li><li>&lt;task:scheduled ref=“taskJob” method=“job1” cron=“0 <em></em> <em></em> ?”/&gt;</li><li>&lt;/task:scheduled-tasks&gt;</li><li>&lt;context:component-scan base-package=” com.gy.mytask ” /&gt;</li></ol><p>说明：ref参数指定的即任务类，method指定的即需要运行的方法，cron及cronExpression表达式，具体写法这里不介绍了，详情见上篇文章附录。</p><p>&lt;context:component-scan base-package=”com.gy.mytask” /&gt;这个配置不消多说了，spring扫描注解用的。</p><p>到这里配置就完成了，是不是很简单。</p><h3 id="第二种：使用注解形式"><a href="#第二种：使用注解形式" class="headerlink" title="第二种：使用注解形式"></a>第二种：使用注解形式</h3><p>也许我们不想每写一个任务类还要在xml文件中配置下，我们可以使用注解@Scheduled，我们看看源文件中该注解的定义：</p><pre><code>Java代码  
</code></pre><ol><li>@Target({java.lang.annotation.ElementType.METHOD, java.lang.annotation.ElementType.ANNOTATION_TYPE})</li><li>@Retention(RetentionPolicy.RUNTIME)</li><li>@Documented</li><li>public @interface Scheduled</li><li>{</li><li>public abstract String cron();</li><li>public abstract long fixedDelay();</li><li>public abstract long fixedRate();</li><li><p>}</p><p>可以看出该注解有三个方法或者叫参数，分别表示的意思是：</p></li></ol><p>cron：指定cron表达式</p><p>fixedDelay：官方文档解释：An interval-based trigger where the interval is measured from the completion time of the previous task. The time unit value is measured in milliseconds.即表示从上一个任务完成开始到下一个任务开始的间隔，单位是毫秒。</p><p>fixedRate：官方文档解释：An interval-based trigger where the interval is measured from the start time of the previous task. The time unit value is measured in milliseconds.即从上一个任务开始到下一个任务开始的间隔，单位是毫秒。</p><p>下面我来配置一下。</p><p><strong>第一步：编写pojo</strong></p><pre><code>Java代码  
</code></pre><ol><li>import org.springframework.scheduling.annotation.Scheduled;</li><li>import org.springframework.stereotype.Component;</li><li>@Component(“taskJob”)</li><li>public class TaskJob {</li><li>@Scheduled(cron = “0 0 3 <em></em> ?”)</li><li>public void job1() {</li><li>System.out.println(“任务进行中。。。”);</li><li>}</li><li>}</li></ol><p><strong>第二步：添加task相关的配置：</strong></p><pre><code>Xml代码  
</code></pre><ol><li>&lt;?xml version=“1.0” encoding=“UTF-8”?&gt;</li><li>&lt;beans xmlns=“<a href="http://www.springframework.org/schema/beans”" target="_blank" rel="noopener">http://www.springframework.org/schema/beans”</a></li><li>xmlns:xsi=“<a href="http://www.w3.org/2001/XMLSchema-instance”" target="_blank" rel="noopener">http://www.w3.org/2001/XMLSchema-instance”</a> xmlns:aop=“<a href="http://www.springframework.org/schema/aop”" target="_blank" rel="noopener">http://www.springframework.org/schema/aop”</a></li><li>xmlns:context=“<a href="http://www.springframework.org/schema/context”" target="_blank" rel="noopener">http://www.springframework.org/schema/context”</a></li><li>xmlns:tx=“<a href="http://www.springframework.org/schema/tx”" target="_blank" rel="noopener">http://www.springframework.org/schema/tx”</a></li><li>xmlns:task=“<a href="http://www.springframework.org/schema/task”" target="_blank" rel="noopener">http://www.springframework.org/schema/task”</a></li><li>xsi:schemaLocation=”</li><li><a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a> <a href="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</a></li><li><a href="http://www.springframework.org/schema/aop" target="_blank" rel="noopener">http://www.springframework.org/schema/aop</a> <a href="http://www.springframework.org/schema/aop/spring-aop-3.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/aop/spring-aop-3.0.xsd</a></li><li><a href="http://www.springframework.org/schema/context" target="_blank" rel="noopener">http://www.springframework.org/schema/context</a></li><li><a href="http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd</a></li><li><a href="http://www.springframework.org/schema/tx" target="_blank" rel="noopener">http://www.springframework.org/schema/tx</a> <a href="http://www.springframework.org/schema/tx/spring-tx-3.0.xsd" target="_blank" rel="noopener">http://www.springframework.org/schema/tx/spring-tx-3.0.xsd</a></li><li><a href="http://www.springframework.org/schema/task" target="_blank" rel="noopener">http://www.springframework.org/schema/task</a> <a href="http://www.springframework.org/schema/task/spring-task-3.0.xsd”" target="_blank" rel="noopener">http://www.springframework.org/schema/task/spring-task-3.0.xsd”</a></li><li>default-lazy-init=“false”&gt;</li><li>&lt;context:annotation-config /&gt;</li><li>&lt;!—spring扫描注解的配置 —&gt;</li><li>&lt;context:component-scan base-package=“com.gy.mytask” /&gt;</li><li>&lt;!—开启这个配置，spring才能识别@Scheduled注解 —&gt;</li><li>&lt;task:annotation-driven scheduler=“qbScheduler” mode=“proxy”/&gt;</li><li>&lt;task:scheduler id=“qbScheduler” pool-size=“10”/&gt;</li></ol><p>说明：理论上只需要加上&lt;task:annotation-driven /&gt;这句配置就可以了，这些参数都不是必须的。</p><p>Ok配置完毕，当然spring task还有很多参数，我就不一一解释了，具体参考xsd文档<a href="http://www.springframework.org/schema/task/spring-task-3.0.xsd。" target="_blank" rel="noopener">http://www.springframework.org/schema/task/spring-task-3.0.xsd。</a></p><p><em>附录：</em></p><p><em>cronExpression的配置说明，具体使用以及参数请百度google</em></p><p><em>字段 允许值 允许的特殊字符</em></p><p><em>秒 0-59 , – </em>/*</p><p><em>分 0-59 , – </em>/*</p><p><em>小时 0-23 , – </em>/*</p><p><em>日期 1-31 , – </em>? / L W C*</p><p><em>月份 1-12 或者 JAN-DEC , – </em>/*</p><p><em>星期 1-7 或者 SUN-SAT , – </em>? / L C #*</p><p><em>年（可选） 留空, 1970-2099 , – </em>/ *</p><p><em>– 区间</em></p><p>*<em> 通配符</em></p><p><em>? 你不想设置那个字段</em></p><p><em>下面只例出几个式子</em></p><p><em>CRON表达式 含义</em></p><p><em>“0 0 12 </em><em>?” 每天中午十二点触发</em></p><p><em>“0 15 10 ? </em><em>” 每天早上10：15触发</em></p><p><em>“0 15 10 </em><em>?” 每天早上10：15触发</em></p><p><em>“0 15 10 </em><em>? </em>” 每天早上10：15触发 *</p><p><em>“0 15 10 </em><em>? 2005” 2005年的每天早上10：15触发</em></p><p><em>“0 </em>14 <em></em> ?” 每天从下午2点开始到2点59分每分钟一次触发 *</p><p><em>“0 0/5 14 </em><em>?” 每天从下午2点开始到2：55分结束每5分钟一次触发</em></p><p><em>“0 0/5 14,18 </em><em>?” 每天的下午2点至2：55和6点至6点55分两个时间段内每5分钟一次触发</em></p><p><em>“0 0-5 14 </em><em>?” 每天14:00至14:05每分钟一次触发</em></p><p><em>“0 10,44 14 ? 3 WED” 三月的每周三的14：10和14：44触发</em></p><p><em>“0 15 10 ? </em>MON-FRI” 每个周一、周二、周三、周四、周五的10：15触发 *</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/svg-filter-相关的几个问题.html" rel="next" title="svg filter 相关的几个问题"><i class="fa fa-chevron-left"></i> svg filter 相关的几个问题</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/java基础-泛型.html" rel="prev" title="Java基础——泛型 » java面试题">Java基础——泛型 » java面试题 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Quartz"><span class="nav-number">1.</span> <span class="nav-text">Quartz</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一种，作业类继承自特定的基类：org-springframework-scheduling-quartz-QuartzJobBean。"><span class="nav-number">1.1.</span> <span class="nav-text">第一种，作业类继承自特定的基类：org.springframework.scheduling.quartz.QuartzJobBean。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二种，作业类不继承特定基类。"><span class="nav-number">1.2.</span> <span class="nav-text">第二种，作业类不继承特定基类。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Task"><span class="nav-number">2.</span> <span class="nav-text">Spring-Task</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#第一种：配置文件方式"><span class="nav-number">2.1.</span> <span class="nav-text">第一种：配置文件方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#第二种：使用注解形式"><span class="nav-number">2.2.</span> <span class="nav-text">第二种：使用注解形式</span></a></li></ol></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->