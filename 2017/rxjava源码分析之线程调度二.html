<!-- build time:Sat Oct 27 2018 21:00:16 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="作者TripleZ2017.08.04 16:13*字数 942在上一篇文章当中我们把RxJava的上游线程切换的源码都大致梳理了一遍，如果还没有看的请猛戳这里，但是光有上游的线程切换是不足以让我们完成在实际项目中的应用的，绝大多数时候我们都需要在下游进行线程的切换来处理上游在其他线程中得到的结果。所以现在我们就来分析一下RxJava源码中是如何实现对下游线程的切换控制管理的。这里我们一切换到An"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="RxJava源码分析之线程调度（二）"><meta property="og:url" content="http://www.jfox.info/2017/rxjava源码分析之线程调度二.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="作者TripleZ2017.08.04 16:13*字数 942在上一篇文章当中我们把RxJava的上游线程切换的源码都大致梳理了一遍，如果还没有看的请猛戳这里，但是光有上游的线程切换是不足以让我们完成在实际项目中的应用的，绝大多数时候我们都需要在下游进行线程的切换来处理上游在其他线程中得到的结果。所以现在我们就来分析一下RxJava源码中是如何实现对下游线程的切换控制管理的。这里我们一切换到An"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:40.334Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="RxJava源码分析之线程调度（二）"><meta name="twitter:description" content="作者TripleZ2017.08.04 16:13*字数 942在上一篇文章当中我们把RxJava的上游线程切换的源码都大致梳理了一遍，如果还没有看的请猛戳这里，但是光有上游的线程切换是不足以让我们完成在实际项目中的应用的，绝大多数时候我们都需要在下游进行线程的切换来处理上游在其他线程中得到的结果。所以现在我们就来分析一下RxJava源码中是如何实现对下游线程的切换控制管理的。这里我们一切换到An"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/rxjava源码分析之线程调度二.html"><title>RxJava源码分析之线程调度（二） | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/rxjava源码分析之线程调度二.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">RxJava源码分析之线程调度（二）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:59:42+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>作者<a href="/u/adb7c6deb713">TripleZ</a>2017.08.04 16:13*字数 942<br>在上一篇文章当中我们把RxJava的上游线程切换的源码都大致梳理了一遍，如果还没有看的<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/dfd1a8df6fe0">请猛戳这里</a>，但是光有上游的线程切换是不足以让我们完成在实际项目中的应用的，绝大多数时候我们都需要在下游进行线程的切换来处理上游在其他线程中得到的结果。所以现在我们就来分析一下RxJava源码中是如何实现对下游线程的切换控制管理的。</p><p>这里我们一切换到Android主线程为例：</p><pre><code>.subscribeOn(Schedulers.io())
.observeOn(AndroidSchedulers.mainThread())
</code></pre><p>现在就从observeOn(AndroidSchedulers.mainThread())入手,探探究竟。<br>首先我们来看一下RxJava是如何得到一个Android主线程的Scheduler的即HandlerScheduler。我们点进源码看一下：</p><pre><code>/** Android-specific Schedulers. */
public final class AndroidSchedulers {

    private static final class MainHolder {
        //创建一个Handle拿到主线程的Looper 创建默认的 HandlerScheduler
        static final Scheduler DEFAULT = new HandlerScheduler(new Handler(Looper.getMainLooper()));
    }

    private static final Scheduler MAIN_THREAD = RxAndroidPlugins.initMainThreadScheduler(
            new Callable&lt;Scheduler&gt;() {
                @Override public Scheduler call() throws Exception {
                    //该Callable默认返回的就是上面的HandleScheduler
                    return MainHolder.DEFAULT;
                }
            });

    /** A {@link Scheduler} which executes actions on the Android main thread. */
    public static Scheduler mainThread() {
        //这里就是入口 可以看到其实该方法是直接获取到了一个静态的Scheduler常量。
        return RxAndroidPlugins.onMainThreadScheduler(MAIN_THREAD);
    }

    /** A {@link Scheduler} which executes actions on {@code looper}. */
    public static Scheduler from(Looper looper) {
        if (looper == null) throw new NullPointerException(&quot;looper == null&quot;);
        return new HandlerScheduler(new Handler(looper));
    }

    private AndroidSchedulers() {
        throw new AssertionError(&quot;No instances.&quot;);
    }
}
</code></pre><p>好了现在Scheduler有了，我们继续分析observeOn方法。</p><pre><code>public final Observable&lt;T&gt; observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {
        ObjectHelper.requireNonNull(scheduler, &quot;scheduler is null&quot;);
        ObjectHelper.verifyPositive(bufferSize, &quot;bufferSize&quot;);
        return RxJavaPlugins.onAssembly(new ObservableObserveOn&lt;T&gt;(this, scheduler, delayError, bufferSize));
    }
</code></pre><p>看到了吧，RxJava所有的代码基本都是一致的，桥接模式，这里看到是创建了一个ObservableObserveOn对象，当然第二个参数默认是false，表明了如果执行了onError() 将会重新发送一遍上游的事件序列，第三个参数是缓存的大小默认是128。我们点进ObservableObserveOn的构造方法看看里面都做了什么，很关键。</p><pre><code>//可以看到套路基本都是一样的， ObservableObserveOn&lt;T&gt; 同样是继承于AbstractObservableWithUpstream&lt;T, T&gt; ,用来保存上游的原事件流。
public final class ObservableObserveOn&lt;T&gt; extends AbstractObservableWithUpstream&lt;T, T&gt; {
    final Scheduler scheduler;
    final boolean delayError;
    final int bufferSize;
    public ObservableObserveOn(ObservableSource&lt;T&gt; source, Scheduler scheduler, boolean delayError, int bufferSize) {
        super(source);
        this.scheduler = scheduler;
        this.delayError = delayError;
        this.bufferSize = bufferSize;
    }
//订阅的真正发生之处
    @Override
    protected void subscribeActual(Observer&lt;? super T&gt; observer) {
        if (scheduler instanceof TrampolineScheduler) {//肯定不是这个Scheduler啊，我们这里是HandleScheduler
            source.subscribe(observer);
        } else {
            //创建HandlerScheduler的Worker,HandlerWorker.
            Scheduler.Worker w = scheduler.createWorker();
            //上游事件和下游事件产生订阅，这里又是一个包装类ObserveOnObserver包装了下游真正的Observer。
           //我们到ObserverOnObserver里面去看看，其是一个静态内部类
          //这里是把worker，delayError，bufferSizew也都传了进去
            source.subscribe(new ObserveOnObserver&lt;T&gt;(observer, w, delayError, bufferSize));
        }
    }
  //实现了Runnable接口，继承于BasicIntQueueDisposable
    static final class ObserveOnObserver&lt;T&gt; extends BasicIntQueueDisposable&lt;T&gt;
    implements Observer&lt;T&gt;, Runnable {

        private static final long serialVersionUID = 6576896619930983584L;
        final Observer&lt;? super T&gt; actual;
        final Scheduler.Worker worker;
        final boolean delayError;
        final int bufferSize;

        SimpleQueue&lt;T&gt; queue;

        Disposable s;

        Throwable error;
        volatile boolean done;

        volatile boolean cancelled;

        int sourceMode;

        boolean outputFused;

        ObserveOnObserver(Observer&lt;? super T&gt; actual, Scheduler.Worker worker, boolean delayError, int bufferSize) {
            this.actual = actual;
            this.worker = worker;
            this.delayError = delayError;
            this.bufferSize = bufferSize;
        }

        @Override
        public void onSubscribe(Disposable s) {
            if (DisposableHelper.validate(this.s, s)) {
                this.s = s;
                if (s instanceof QueueDisposable) {
                    @SuppressWarnings(&quot;unchecked&quot;)
                    QueueDisposable&lt;T&gt; qd = (QueueDisposable&lt;T&gt;) s;

                    int m = qd.requestFusion(QueueDisposable.ANY | QueueDisposable.BOUNDARY);

                    if (m == QueueDisposable.SYNC) {
                        sourceMode = m;
                        queue = qd;
                        done = true;
                        actual.onSubscribe(this);
                        schedule();
                        return;
                    }
                    if (m == QueueDisposable.ASYNC) {
                        sourceMode = m;
                        queue = qd;
                        actual.onSubscribe(this);
                        return;
                    }
                }
              //事件的缓存队列 确定了缓存队列的大小
                queue = new SpscLinkedArrayQueue&lt;T&gt;(bufferSize);
              //执行真正的onSubscribe方法
                actual.onSubscribe(this);
            }
        }

        @Override
        public void onNext(T t) {
            if (done) {
                return;
            }

            if (sourceMode != QueueDisposable.ASYNC) {
                queue.offer(t);
            }
         //开始调度    
        schedule();
        }

        @Override
        public void onError(Throwable t) {
            if (done) {
                RxJavaPlugins.onError(t);
                return;
            }
            error = t;
            done = true;
             //开始调度 
            schedule();
        }

        @Override
        public void onComplete() {
            if (done) {
                return;
            }
            done = true;//已经完成
            //开始调度  
            schedule();
        }
      //取消订阅
        @Override
        public void dispose() {
            if (!cancelled) {
                cancelled = true;
                s.dispose();
                worker.dispose();
                if (getAndIncrement() == 0) {
                    queue.clear();
                }
            }
        }
      //判断是否被取消订阅
        @Override
        public boolean isDisposed() {
            return cancelled;
        }
      //执行调度的方法 
        void schedule() {
            if (getAndIncrement() == 0) {
              //传入当前ObserveOnObserver对象，其实现了Runnable接口
                worker.schedule(this);
            }
        }

        void drainNormal() {
            int missed = 1;
            //缓存数据的队列
            final SimpleQueue&lt;T&gt; q = queue;
            //实际下游的Observer
            final Observer&lt;? super T&gt; a = actual;

            for (;;) {
                //检测事件是否被终止，如果终止了直接跳出循环
                if (checkTerminated(done, q.isEmpty(), a)) {
                    return;
                }

                for (;;) {
                    //标记事件是否完成
                    boolean d = done;
                    T v;

                    try {
                        //拿到队列里的第一个事件
                        v = q.poll();
                    } catch (Throwable ex) {
                        //发生异常了 做一系列的后续动作
                        //取消订阅，队列的制空，发送异常事件，取消线程调度，最后跳出循环
                        Exceptions.throwIfFatal(ex);
                        s.dispose();
                        q.clear();
                        a.onError(ex);
                        worker.dispose();
                        return;
                    }
                    //判断事件是否为空
                    boolean empty = v == null;

                    if (checkTerminated(d, empty, a)) {
                        return;
                    }
                    //为空直接进入下一轮循环
                    //因为上游的事件处理也是需要时间的，上游的执行有可能是非常大量的数据所以可能会出现缓存队列里面暂时没有事件，所以这里需要一直进行循环去等待新的事件产生
                    if (empty) {
                        break;
                    }
                    //发送事件
                    a.onNext(v);
                }
              //下面这段代码我也不是很确定他的意思，这里我说一下我自己的理解不知道正不正确：
              //因为ObserveOnObserver是继承于BasicIntQueueDisposable ，而BasicIntQueueDisposable 又继承了AtomicInteger，一个原子操作类
            //用一个Integer整数来控制当前ObserveOnObserver对象的并发操作
            //如果当前ObserveOnObserver对象没有被其他线程独占，那么该对象就自己持有的话（代表已经执行完了当前的事件），就可以执行addAndGet(int i)方法了。
            //执行完改方法对自己的负数相加那么最终得出的是0，为0的话就可以开始下一个循环了，那么以后的每一个循环missed的值都为0都可以直接break！
            //最终要的是addAndGet()是一个阻塞式的方法，如果不成功的话，它会重新执行一遍
          //所以我分析得出这里其实是一个控制标记位“好了！现在轮到你了，开始吧”当第一次拿到权限后就可以一直执行下去了。

                missed = addAndGet(-missed);
                if (missed == 0) {
                    break;
                }
            }
        }

        void drainFused() {
   ...........
        }
        //具体的run方法内部
        @Override
        public void run() {
            if (outputFused) {
                drainFused();
            } else {
                //去处理队列里面缓存的数据
                drainNormal();
            }
        }
        //检查是否终止  代码都很简单 我就不做注释了
        boolean checkTerminated(boolean d, boolean empty, Observer&lt;? super T&gt; a) {
            if (cancelled) {
                queue.clear();
                return true;
            }
            if (d) {
                Throwable e = error;
                if (delayError) {
                    if (empty) {
                        if (e != null) {
                            a.onError(e);
                        } else {
                            a.onComplete();
                        }
                        worker.dispose();
                        return true;
                    }
                } else {
                    if (e != null) {
                        queue.clear();
                        a.onError(e);
                        worker.dispose();
                        return true;
                    } else
                    if (empty) {
                        a.onComplete();
                        worker.dispose();
                        return true;
                    }
                }
            }
            return false;
        }
    }
}
</code></pre><p>同样是装饰模式，关键就是每当执行onNext(),onError(),onCompleted()方法的时候，都会开启线程的调度，上游的每一次事件，都会在指定线程中处理，这就是核心。然后就执行了具体的Worker实现类里面的schedule方法，我们一起看一下。</p><pre><code>//HandlerWorker里面的schedule方法，其第二个参数为0L，第三个参数为TimeUnit.NANOSECONDS。
 @Override
        public Disposable schedule(Runnable run, long delay, TimeUnit unit) {
            if (run == null) throw new NullPointerException(&quot;run == null&quot;);
            if (unit == null) throw new NullPointerException(&quot;unit == null&quot;);

            if (disposed) {
                //判断是否取消订阅了
                return Disposables.disposed();
            }
            //满篇飞的Hook函数 +_+
            run = RxJavaPlugins.onSchedule(run);
            //封装当前持有主线程Looper的handler和ObserveOnObserver对象
            ScheduledRunnable scheduled = new ScheduledRunnable(handler, run);
            //创建Message
            Message message = Message.obtain(handler, scheduled);
            message.obj = this; // Used as token for batch disposal of this worker&apos;s runnables.
            //给主线程发送消息
            handler.sendMessageDelayed(message, Math.max(0L, unit.toMillis(delay)));

            // Re-check disposed state for removing in case we were racing a call to dispose().
            //判断是否取消订阅了
            if (disposed) {
            //如果取消订阅了 就remove掉消息处理的回调接口
                handler.removeCallbacks(scheduled);
                return Disposables.disposed();
            }

            return scheduled;
        }
</code></pre><p>当然了最后主线程的执行的程序是ScheduledRunnable里面的run()方法，代码如下：</p><pre><code>@Override
       public void run() {
           try {
             //ObserveOnObserver对象的run方法
               delegate.run();
           } catch (Throwable t) {
               //捕获异常了进行一系列处理
               IllegalStateException ie =
                   new IllegalStateException(&quot;Fatal Exception thrown on Scheduler.&quot;, t);
               RxJavaPlugins.onError(ie);
               Thread thread = Thread.currentThread();
               thread.getUncaughtExceptionHandler().uncaughtException(thread, ie);
           }
       }
</code></pre><p>这样RxJava就实现了把上游发送的每一个事件都巧妙地转换到了指定线程中处理，此处是Android主线程。<br>可以看到如果你在下游多次调用observeon()的话线程是会一直切换的，这也是网上一直说的结论。每一次切换线程，都会把对应的Observer对象的各项处理方法的处理执行在制定线程当中。<br>大概浏览完源码你会发现，RxJava的设计者真的是把面向对象的思想用到了极致，抽象接口与实体，设计模式地巧用都无处不在，感叹自己要学的真的还有太多，如果让我来写不知道还要多少年才能写出如此牛B的代码。<br>这也算是我第一次写源码分析的文章，还有很多地方有待提高，最开始听说别人源码分析很重要，不光要会用那些优秀的Library更要理解其中的精髓，与是我傻乎乎地闷着脑袋去看，结果真的看不懂，后来看了一本书叫做《Android源码设计模式》才恍然大悟，设计模式地巧用在各大优秀的开源Library中无处不在，只有真正地理解了设计模式，精通架构，才能写出如此优秀的代码。最后再安利一本书《设计模式之禅》这本书很有意思，作者语言幽默风趣，像看连环画一样很有意思。<br>哈哈 废话说了一大堆了，如果上面我的分析有误的话，欢迎指正批评，有什么不懂得地方也可以一起探讨。</p><p>最后</p><p>没有最后了，大家再见~~~</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/rdiframeworknetnet快速信息化系统开发框架v32winform版本新增新的角色.html" rel="next" title="RDIFramework.NET ━ .NET快速信息化系统开发框架 V3.2->WinForm版本新增新的角色授权管理界面效率更高、更规范"><i class="fa fa-chevron-left"></i> RDIFramework.NET ━ .NET快速信息化系统开发框架 V3.2->WinForm版本新增新的角色授权管理界面效率更高、更规范</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/我的网站之struts2笔记1.html" rel="prev" title="我的网站之struts2笔记1">我的网站之struts2笔记1 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->