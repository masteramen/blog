<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>[java手把手教程][第二季]java后端博客系统文章系统——No11 | Java面试</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="[java手把手教程][第二季]java后端博客系统文章系统——No11" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="H2M_LI_HEADER IDE为 idea2017.1.5 H2M_LI_HEADER JDK环境为 1.8 H2M_LI_HEADER gradle构建，版本：2.14.1 H2M_LI_HEADER Mysql版本为 5.5.27 H2M_LI_HEADER Tomcat版本为 7.0.52 H2M_LI_HEADER 流程图绘制（xmind） H2M_LI_HEADER 建模分析软件 PowerDesigner16.5 H2M_LI_HEADER 数据库工具MySQLWorkBench，版本：6.3.7build" />
<meta property="og:description" content="H2M_LI_HEADER IDE为 idea2017.1.5 H2M_LI_HEADER JDK环境为 1.8 H2M_LI_HEADER gradle构建，版本：2.14.1 H2M_LI_HEADER Mysql版本为 5.5.27 H2M_LI_HEADER Tomcat版本为 7.0.52 H2M_LI_HEADER 流程图绘制（xmind） H2M_LI_HEADER 建模分析软件 PowerDesigner16.5 H2M_LI_HEADER 数据库工具MySQLWorkBench，版本：6.3.7build" />
<link rel="canonical" href="http://www.jfox.info/2017/java%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E5%AD%A3java%E5%90%8E%E7%AB%AF%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%96%87%E7%AB%A0%E7%B3%BB%E7%BB%9Fno11.html" />
<meta property="og:url" content="http://www.jfox.info/2017/java%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E5%AD%A3java%E5%90%8E%E7%AB%AF%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%96%87%E7%AB%A0%E7%B3%BB%E7%BB%9Fno11.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T23:59:35+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"[java手把手教程][第二季]java后端博客系统文章系统——No11","dateModified":"2017-01-01T23:59:35+08:00","datePublished":"2017-01-01T23:59:35+08:00","url":"http://www.jfox.info/2017/java%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E5%AD%A3java%E5%90%8E%E7%AB%AF%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%96%87%E7%AB%A0%E7%B3%BB%E7%BB%9Fno11.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/java%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E5%AD%A3java%E5%90%8E%E7%AB%AF%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%96%87%E7%AB%A0%E7%B3%BB%E7%BB%9Fno11.html"},"description":"H2M_LI_HEADER IDE为 idea2017.1.5 H2M_LI_HEADER JDK环境为 1.8 H2M_LI_HEADER gradle构建，版本：2.14.1 H2M_LI_HEADER Mysql版本为 5.5.27 H2M_LI_HEADER Tomcat版本为 7.0.52 H2M_LI_HEADER 流程图绘制（xmind） H2M_LI_HEADER 建模分析软件 PowerDesigner16.5 H2M_LI_HEADER 数据库工具MySQLWorkBench，版本：6.3.7build","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">[java手把手教程][第二季]java后端博客系统文章系统——No11</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T23:59:35+08:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>H2M_LI_HEADER  IDE为 <strong>idea2017.1.5</strong>
H2M_LI_HEADER  JDK环境为 <strong>1.8</strong>
H2M_LI_HEADER gradle构建，版本：2.14.1
H2M_LI_HEADER  Mysql版本为 <strong>5.5.27</strong>
H2M_LI_HEADER  Tomcat版本为 <strong>7.0.52</strong>
H2M_LI_HEADER 流程图绘制（xmind）
H2M_LI_HEADER  建模分析软件 <strong>PowerDesigner16.5</strong>
H2M_LI_HEADER 数据库工具MySQLWorkBench，版本：6.3.7build</p>

<h4 id="本期目标">本期目标</h4>

<p>完成微信公众号相关接入</p>

<h4 id="资源引入">资源引入</h4>

<p>既然我们要开发微信相关的功能，那么我们需要微信相关的资源。首先是打开微信官方的开发者文档。接着我们应该构建微信相关的代码了。？</p>

<p>事实上并不是这样，我们在开源中国的java项目中可以找到一些跟微信相关的工具，本文中我采用了fastweixin 来快速进行开发。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>compile 'com.github.sd4324530:fastweixin:1.3.15'
</code></pre></div></div>

<h4 id="参照fastweixin说明进行开发">参照fastweixin说明进行开发</h4>

<p>实现微信互访的Controller</p>

<p>为什么说要实现这个？</p>

<ul>
  <li>配置微信相关设置</li>
  <li>根据生成的设置和微信服务器互联</li>
  <li>跟微信服务器交互，绑定微信账号</li>
  <li>获取和微信交互数据的令牌</li>
</ul>

<p>所以，我们有一大堆事情要做，但是此时此刻我们采用的fastweixin已经做好一大步，我们按照他的说明编写微信Controller。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@RestController
@RequestMapping("/weixin")
public class WeixinController extends WeixinControllerSupport {
    private static final Logger log = LoggerFactory.getLogger(WeixinController.class);
    private static final String TOKEN = "weixin";   //默认Token为weixin

    @Autowired
    private WeichatServiceImpl weichatService;
    @Autowired
    private PostService postService;

    @Override
    public void bindServer(HttpServletRequest request, HttpServletResponse response) {
        String signature = request.getParameter("signature");
        String timestamp = request.getParameter("timestamp");
        String nonce = request.getParameter("nonce");
        LogPrintUtil.getInstance(WeixinController.class).logOutLittle("bindWeiXin:\fsignature = "
                + signature + "\ntimestamp"
                + timestamp + "\nnonce" + nonce);
        super.bindServer(request, response);
    }

    //设置TOKEN，用于绑定微信服务器
    @Override
    protected String getToken() {
        return weichatService.getWeiConfig().getToken();
    }

    //使用安全模式时设置：APPID
    //不再强制重写，有加密需要时自行重写该方法
    @Override
    protected String getAppId() {
        return weichatService.getWeiConfig().getAppid();
    }

    //使用安全模式时设置：密钥
    //不再强制重写，有加密需要时自行重写该方法
    @Override
    protected String getAESKey() {
        return null;
    }

    //重写父类方法，处理对应的微信消息
    @Override
    protected BaseMsg handleTextMsg(TextReqMsg msg) {
        String content = msg.getContent();
        LogPrintUtil.getInstance(WeixinController.class).logOutLittle(String.format("用户发送到服务器的内容:{%s}", content));

        List&lt;Article&gt; articles = new ArrayList&lt;&gt;();
        List&lt;PostCustom&gt; byKeyword = null;
        try {
            byKeyword = postService.findByKeyword(content, null, null);
            if (null != byKeyword &amp;&amp; byKeyword.size() &gt; 0) {
                int count = 0;
                for (PostCustom postCustom : byKeyword) {
                    if (count &gt;= 5) break;
                    Article article = new Article();
                    article.setTitle(postCustom.getPostTitle());
                    article.setDescription(HtmlUtil.getTextFromHtml(postCustom.getPostContent()));
                    article.setUrl("http://acheng1314.cn/front/post/" + postCustom.getId());
                    articles.add(article);
                    count++;
                }
                return new NewsMsg(articles);
            }
        } catch (NotFoundException e) {
            e.printStackTrace();
        }
        return new TextMsg("暂未找到该信息!");
    }

    /*1.1版本新增，重写父类方法，加入自定义微信消息处理器
     *不是必须的，上面的方法是统一处理所有的文本消息，如果业务觉复杂，上面的会显得比较乱
     *这个机制就是为了应对这种情况，每个MessageHandle就是一个业务，只处理指定的那部分消息
     */
    @Override
    protected List&lt;MessageHandle&gt; initMessageHandles() {
        List&lt;MessageHandle&gt; handles = new ArrayList&lt;MessageHandle&gt;();
//                handles.add(new MyMessageHandle());
        return handles;
    }

    //1.1版本新增，重写父类方法，加入自定义微信事件处理器，同上
    @Override
    protected List&lt;EventHandle&gt; initEventHandles() {
        List&lt;EventHandle&gt; handles = new ArrayList&lt;EventHandle&gt;();
//                handles.add(new MyEventHandle());
        return handles;
    }

    /**
     * 处理图片消息，有需要时子类重写
     *
     * @param msg 请求消息对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleImageMsg(ImageReqMsg msg) {
        return super.handleImageMsg(msg);
    }

    /**
     * 处理语音消息，有需要时子类重写
     *
     * @param msg 请求消息对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleVoiceMsg(VoiceReqMsg msg) {
        return super.handleVoiceMsg(msg);
    }

    /**
     * 处理视频消息，有需要时子类重写
     *
     * @param msg 请求消息对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleVideoMsg(VideoReqMsg msg) {
        return super.handleVideoMsg(msg);
    }

    /**
     * 处理小视频消息，有需要时子类重写
     *
     * @param msg 请求消息对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg hadnleShortVideoMsg(VideoReqMsg msg) {
        return super.hadnleShortVideoMsg(msg);
    }

    /**
     * 处理地理位置消息，有需要时子类重写
     *
     * @param msg 请求消息对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleLocationMsg(LocationReqMsg msg) {
        return super.handleLocationMsg(msg);
    }

    /**
     * 处理链接消息，有需要时子类重写
     *
     * @param msg 请求消息对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleLinkMsg(LinkReqMsg msg) {
        return super.handleLinkMsg(msg);
    }

    /**
     * 处理扫描二维码事件，有需要时子类重写
     *
     * @param event 扫描二维码事件对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleQrCodeEvent(QrCodeEvent event) {
        return super.handleQrCodeEvent(event);
    }

    /**
     * 处理地理位置事件，有需要时子类重写
     *
     * @param event 地理位置事件对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleLocationEvent(LocationEvent event) {
        return super.handleLocationEvent(event);
    }

    /**
     * 处理菜单点击事件，有需要时子类重写
     *
     * @param event 菜单点击事件对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleMenuClickEvent(MenuEvent event) {
        LogPrintUtil.getInstance(this.getClass()).logOutLittle("点击" + event.toString());
        MyWeChatMenu myWeChatMenu = weichatService.findOneById(StringUtils.toInt(event.getEventKey()));
        try {
            List&lt;Article&gt; articles = new ArrayList&lt;&gt;();
            List&lt;PostCustom&gt; keyword = postService.findByKeyword(myWeChatMenu.getKeyword(), null, null);
            if (null != keyword &amp;&amp; keyword.size() &gt; 0) {
                int i = 0;
                for (PostCustom postCustom : keyword) {
                    if (i &gt;= 5) break;
                    Article article = new Article();
                    article.setTitle(postCustom.getPostTitle());
                    article.setDescription(HtmlUtil.getTextFromHtml(postCustom.getPostContent()));
                    article.setUrl("http://acheng1314.cn/front/post/" + postCustom.getId());
                    articles.add(article);
                    i++;
                }
                return new NewsMsg(articles);
            }
        } catch (NotFoundException e) {
            e.printStackTrace();
        }
        return new TextMsg("暂未找到该信息!");
    }

    /**
     * 处理菜单跳转事件，有需要时子类重写
     *
     * @param event 菜单跳转事件对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleMenuViewEvent(MenuEvent event) {
        LogPrintUtil.getInstance(this.getClass()).logOutLittle("点击跳转" + event.toString());
        return super.handleMenuViewEvent(event);
    }

    /**
     * 处理菜单扫描推事件，有需要时子类重写
     *
     * @param event 菜单扫描推事件对象
     * @return 响应的消息对象
     */
    @Override
    protected BaseMsg handleScanCodeEvent(ScanCodeEvent event) {
        return super.handleScanCodeEvent(event);
    }

    /**
     * 处理菜单弹出相册事件，有需要时子类重写
     *
     * @param event 菜单弹出相册事件
     * @return 响应的消息对象
     */
    @Override
    protected BaseMsg handlePSendPicsInfoEvent(SendPicsInfoEvent event) {
        return super.handlePSendPicsInfoEvent(event);
    }

    /**
     * 处理模版消息发送事件，有需要时子类重写
     *
     * @param event 菜单弹出相册事件
     * @return 响应的消息对象
     */
    @Override
    protected BaseMsg handleTemplateMsgEvent(TemplateMsgEvent event) {
        return super.handleTemplateMsgEvent(event);
    }

    /**
     * 处理添加关注事件，有需要时子类重写
     *
     * @param event 添加关注事件对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleSubscribe(BaseEvent event) {
        return super.handleSubscribe(event);
    }

    /**
     * 接收群发消息的回调方法
     *
     * @param event 群发回调方法
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg callBackAllMessage(SendMessageEvent event) {
        return super.callBackAllMessage(event);
    }

    /**
     * 处理取消关注事件，有需要时子类重写
     *
     * @param event 取消关注事件对象
     * @return 响应消息对象
     */
    @Override
    protected BaseMsg handleUnsubscribe(BaseEvent event) {
        return super.handleUnsubscribe(event);
    }

}
</code></pre></div></div>

<p>我们看上面的众多方法都已经打上了javadoc，现在我们需要关注的主要是下面的这三个方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//设置TOKEN，用于绑定微信服务器
    @Override
    protected String getToken() {
        return weichatService.getWeiConfig().getToken();
    }

    //使用安全模式时设置：APPID
    //不再强制重写，有加密需要时自行重写该方法
    @Override
    protected String getAppId() {
        return weichatService.getWeiConfig().getAppid();
    }

    //使用安全模式时设置：密钥
    //不再强制重写，有加密需要时自行重写该方法
    @Override
    protected String getAESKey() {
        return null;
    }
</code></pre></div></div>

<p>同时在微信的开发者设置页面也有对应的设置来控制，测试账号如下：
<img src="be6b9de.png" alt="" /></p>

<p>微信测试号设置页面</p>

<p>按照上面的Controller来讲，URL已经可以设置了，就是我们服务器域名+/weixin。</p>

<p>当然，这不是重点！但是按照前面我们的开发习惯来讲，微信相关的一些设置能够持久化到服务器那就是最好的了。所以我们还是写到数据库中。（刚开始其实我是写到properties中，但是由于properties的特性，所以数据不刷新。干脆我也就存储到数据库中。）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/*创建数据库表cc_site_option，用来存储站点基础信息*/
SET NAMES utf8;
-- ----------------------------
--  Table structure for `cc_site_option`
-- ----------------------------
DROP TABLE IF EXISTS `cc_site_option`;
CREATE TABLE `cc_site_option` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `option_key` varchar(128) DEFAULT NULL COMMENT '配置KEY',
  `option_value` text COMMENT '配置内容',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=8 DEFAULT CHARSET=utf8 COMMENT='配置信息表，用来保存网站的所有配置信息。';
</code></pre></div></div>

<p>其实在上面的表中大家细心点可以看到我是采用了类似Map的存储结构，也就是说我们的数据通俗来讲也就是键值对的形式，所以读取数据的时候存储用的List</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;。简要的Dao如下： 
   
  

@Repository("siteConfigDao")
public interface SiteConfigDao extends Dao {

    @Deprecated
    @Override
    public int add(Serializable serializable);

    @Deprecated
    @Override
    public int del(Serializable serializable);

    @Deprecated
    @Override
    public int update(Serializable serializable);

    @Deprecated
    @Override
    public Serializable findOneById(Serializable Id);

    @Override
    List&lt;HashMap&lt;String, String&gt;&gt; findAll();

    Serializable findOneByKey(@Param("mKey") Serializable key);

    void updateOneByKey(@Param("mKey") Serializable key, @Param("mValue") Serializable value);

    //    @Insert("INSERT INTO `cc_site_option` (`option_key`,`option_value`) VALUES (#{mKey},#{mValue});")
    void insertOne(@Param("mKey") Serializable key, @Param("mValue") Serializable value);
}
</code></pre></div></div>

<p>唯一细节一点的就是对应的Service中获取想要的某一些数据。同时，我们的微信菜单也是需要存储的，如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CREATE TABLE `cc_wechat_menu` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` text NOT NULL COMMENT '微信菜单的名字',
  `parent_id` int(11) DEFAULT '0' COMMENT '父级菜单的id，最外层菜单的parent_id为0',
  `type` varchar(255) DEFAULT NULL COMMENT '微信菜单类型，deleted表示删除，其他的都是微信上面的相同类型,click=点击推事件,view=跳转URL,scancode_push=扫码推事件,scancode_waitmsg=扫码推事件且弹出“消息接收中”提示框,pic_sysphoto=弹出系统拍照发图,pic_photo_or_album=弹出拍照或者相册发图,pic_weixin=弹出微信相册发图器,location_select=弹出地理位置选择器,',
  `keyword` text COMMENT '填写的关键字将会触发“自动回复”匹配的内容，访问网页请填写URL地址。',
  `position` int(11) DEFAULT '0' COMMENT '排序的数字决定了菜单在什么位置。',
  PRIMARY KEY (`id`),
  UNIQUE KEY `cc_wechat_menu_id_uindex` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='微信菜单表';
</code></pre></div></div>

<p>当然到这里后，我们需要的是微信的Dao（这次在Dao中采用了注解插入sql的方式，这种方式可以懒得创建mapper文件。）。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@Repository("weChatDao")
public interface WeChatDao extends Dao&lt;MyWeChatMenu&gt; {

    @Override
    int add(MyWeChatMenu weChatMenu);

    @Update("UPDATE `cc_wechat_menu` SET type='deleted' WHERE id=#{id}")
    @Override
    int del(MyWeChatMenu weChatMenu);

    @Update("UPDATE `cc_wechat_menu` SET name=#{name},parent_id=#{parentId},type=#{type},keyword=#{keyword},position=#{position} WHERE id=#{id}")
    @Override
    int update(MyWeChatMenu weChatMenu);

    @Select("SELECT * FROM `cc_wechat_menu` WHERE id=#{id}")
    @Override
    MyWeChatMenu findOneById(Serializable Id);

    @Select("SELECT * FROM `cc_wechat_menu` WHERE type!='deleted'")
    @Override
    List&lt;MyWeChatMenu&gt; findAll();

    @Select("SELECT * FROM `cc_wechat_menu` WHERE type!='deleted' AND parent_id=0")
    List&lt;MyWeChatMenu&gt; getParentWeiMenu();
}
</code></pre></div></div>

<p>简单来说上面的注解插入sql语句这样执行，注意一点就是这几个sql的使用。剩下的就是微信的Service，如下：</p>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/java%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E5%AD%A3java%E5%90%8E%E7%AB%AF%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E6%96%87%E7%AB%A0%E7%B3%BB%E7%BB%9Fno11.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/%E8%B5%A2%E5%9C%A8%E9%9D%A2%E8%AF%95%E4%B9%8Bjava%E6%A1%86%E6%9E%B6%E7%AF%878.html">&laquo; 赢在面试之Java框架篇（8）</a>
  
  
  <a class="next" href="/2017/java%E6%9E%B6%E6%9E%84%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%E5%9B%BE.html">Java架构学习路线图 &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
