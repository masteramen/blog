<!-- build time:Sat Oct 27 2018 21:00:21 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="拿一个简单的快捷支付系统为例，服务化后的系统调用图如下所示：通过上图我们可以看到，单块系统根据业务进行服务化后，每个系统功能单一、职责明确并且独立布署，这只是从系统的角度描述了服务化后的调用关系，那么从微服务的角度讲，还有一点是去中心化，也就是将数据库也按服务进行拆分，下图所示的正是每个服务与其对应的数据库间的关系。上面我们可以看到，每个服务对应一个数据库，这样从上到下就已经全部拆分开了，再结合康"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="小程聊微服务-数据抽取那点事（一）"><meta property="og:url" content="http://www.jfox.info/2017/小程聊微服务数据抽取那点事一.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="拿一个简单的快捷支付系统为例，服务化后的系统调用图如下所示：通过上图我们可以看到，单块系统根据业务进行服务化后，每个系统功能单一、职责明确并且独立布署，这只是从系统的角度描述了服务化后的调用关系，那么从微服务的角度讲，还有一点是去中心化，也就是将数据库也按服务进行拆分，下图所示的正是每个服务与其对应的数据库间的关系。上面我们可以看到，每个服务对应一个数据库，这样从上到下就已经全部拆分开了，再结合康"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2017/1091/b8a525b.png"><meta property="og:image" content="http://www.jfox.info/2017/1091/699cdf9.png"><meta property="og:image" content="http://www.jfox.info/2017/1091/11cc566.png"><meta property="og:image" content="http://www.jfox.info/2017/1091/0aa39c7.png"><meta property="og:image" content="http://www.jfox.info/2017/1091/36c9358.png"><meta property="og:image" content="http://www.jfox.info/2017/1091/979a4ff.png"><meta property="og:updated_time" content="2018-10-27T12:29:39.313Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="小程聊微服务-数据抽取那点事（一）"><meta name="twitter:description" content="拿一个简单的快捷支付系统为例，服务化后的系统调用图如下所示：通过上图我们可以看到，单块系统根据业务进行服务化后，每个系统功能单一、职责明确并且独立布署，这只是从系统的角度描述了服务化后的调用关系，那么从微服务的角度讲，还有一点是去中心化，也就是将数据库也按服务进行拆分，下图所示的正是每个服务与其对应的数据库间的关系。上面我们可以看到，每个服务对应一个数据库，这样从上到下就已经全部拆分开了，再结合康"><meta name="twitter:image" content="http://www.jfox.info/2017/1091/b8a525b.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/小程聊微服务数据抽取那点事一.html"><title>小程聊微服务-数据抽取那点事（一） | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/小程聊微服务数据抽取那点事一.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">小程聊微服务-数据抽取那点事（一）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:53:11+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>拿一个简单的快捷支付系统为例，服务化后的系统调用图如下所示：<br><img src="/2017/1091/b8a525b.png" alt=""></p><p>通过上图我们可以看到，单块系统根据业务进行服务化后，每个系统功能单一、职责明确并且独立布署，这只是从系统的角度描述了服务化后的调用关系，那么从微服务的角度讲，还有一点是去中心化，也就是将数据库也按服务进行拆分，下图所示的正是每个服务与其对应的数据库间的关系。</p><p><img src="/2017/1091/699cdf9.png" alt=""></p><p>上面我们可以看到，每个服务对应一个数据库，这样从上到下就已经全部拆分开了，再结合康威定律的理论，每个服务由一个团队负责管理，团队之间彼此协作和沟通。</p><h4 id="三、数据抽取的技术选型"><a href="#三、数据抽取的技术选型" class="headerlink" title="三、数据抽取的技术选型"></a><strong>三、数据抽取的技术选型</strong></h4><p>关于后台的数据统计需求，因为服务化后数据库已经拆分开，于是对后台数据统计造成了一定的困扰，针对这个问题我首先想到的是利用数据库同步来解决，将不同库或者表的数据统一汇总到一起。那么接下来，我将和大家一起逐步探讨和分析。</p><p>1、使用Oracle Golden Gate（简称OGG）工具</p><p>OGG的实现原理是抽取源端的redo log和archive log，然后通过TCP/IP协议投递到目标端，最后解析还原同步到目标端，使目标端实现源端的数据同步，如下图所示：</p><p><img src="/2017/1091/11cc566.png" alt=""><br><strong>1.1 使用OGG的优点：</strong><br>1、对生产系统影响小：实时读取交易日志，以低资源占用实现大交易量数据实时复制。<br>2、以交易为单位复制，保证交易一致性：只同步已提交的数据。<br>3、灵活的拓扑结构：支持一对一、一对多、多对一、多对多和双向复制等。<br>4、可以自定义基于表和行的过滤规则，可以对实时数据执行灵活影射和变换。<br><strong>1.2 使用OGG需要注意的问题点：</strong><br>1、在二个库之间做数据同步的时候，如果我们要在表中新加字段，必须要将OGG停下来加字段，然后再启动，新字段同步才会生效。<br>2、使用OGG做数据同步的时候，工具不是很稳定，经常会出现假死或者退出的情况。<br>3、OGG偶尔出现在同步过程中丢数据的时候。</p><p>2、使用Oracle Logminer</p><p>Logminer是oracle从8i开始提供的用于分析重做日志信息的工具，它包括DBMS_LOGMNR和DBMS_LOGMNR_D两个package，后边的D是字典的意思。它既能分析redo log file，也能分析归档后的archive log file。通过LogMiner可以跟踪Oracle数据库的所有DML、DDL和DCL操作。</p><p>2.1 使用LogMiner进行数据同步的框架图如下所示：</p><p><img src="/2017/1091/0aa39c7.png" alt=""></p><p>2.2 数据同步流程图如下所示：</p><p><img src="/2017/1091/36c9358.png" alt=""></p><p><strong>同步流程说明：</strong>：</p><p>通过指定源端、目标端数据库信息、LogMiner 同步时间等配置信息，获取源端同步数据。</p><p>1、通过定时轮询的方式检测是否到达数据同步时间，如果是则进行数据同步，否则继续进行轮询。<br>2、定时加载数据库归档日志文件到动态表 v$logmnr_contents 中。<br>3、根据条件读取指定 sql 语句。<br>4、执行 sql 语句。</p><p>基于JAVA写的LogMiner的数据同步部分核心代码如下所示：</p><pre><code>try {
    ResultSetresultSet=null;
    // 获取源数据库连接
    sourceConn = DataBase.getSourceDataBase(); Statement statement = sourceConn.createStatement();
    // 添加所有日志文件，本代码仅分析联机日志 StringBuffer sbSQL = new StringBuffer(); sbSQL.append(&quot; BEGIN&quot;);
    sbSQL.append(&quot; dbms_logmnr.add_logfile(logfilename=&gt;&apos;&quot;+Constants.LOG_PATH+&quot;REDO01.LOG&apos;, options=&gt;dbms_logmnr.NEW);&quot;);
    sbSQL.append(&quot; dbms_logmnr.add_logfile(logfilename=&gt;&apos;&quot;+Constants.LOG_PATH+&quot;REDO02.LOG&apos;, options=&gt;dbms_logmnr.ADDFILE);&quot;);
    sbSQL.append(&quot; dbms_logmnr.add_logfile(logfilename=&gt;&apos;&quot;+Constants.LOG_PATH+&quot;REDO03.LOG&apos;, options=&gt;dbms_logmnr.ADDFILE);&quot;);
    sbSQL.append(&quot; END;&quot;);
    CallableStatement callableStatement = sourceConn.prepareCall(sbSQL+&quot;&quot;); callableStatement.execute();
    // 打印获分析日志文件信息resultSet= statement.executeQuery(&quot;SELECT db_name, thread_sqn, filename FROM v$logmnr_logs&quot;);

    while(resultSet.next()) {
        System.out.println(&quot;已添加日志文件==&gt;&quot;+resultSet.getObject(3)); 
    }

    System.out.println(&quot;开始分析日志文件,起始scn号:&quot;+Constants.LAST_SCN);
    callableStatement = sourceConn.prepareCall(&quot;BEGINdbms_logmnr.start_logmnrstartScn=&gt;&apos;&quot;+Constants.LAST_SCN+&quot;&apos;,dictfilename=&gt;&apos;&quot;+Constants.DATA_DICTIONARY+&quot;dictionary.ora&apos;,OPTIONS =&gt;DBMS_LOGMNR.COMMITTED_DATA_ONLY+dbms_logmnr.NO_ROWID_IN_STMT);END;&quot;);
    callableStatement.execute(); 
    System.out.println(&quot;完成分析日志文件&quot;);
    // 查询获取分析结果 System.out.println(&quot;查询分析结果&quot;); resultSet= statement.executeQuery(&quot;SELECT scn,operation,timestamp,status,sql_redo FROM v$logmnr_contents WHERE seg_owner=&apos;&quot;+Constants.SOURCE_CLIENT_USERNAME+&quot;&apos; AND seg_type_name=&apos;TABLE&apos; AND operation !=&apos;SELECT_FOR_UPDATE&apos;&quot;);

    // 连接到目标数据库，在目标数据库执行redo语句
    targetConn = DataBase.getTargetDataBase();
    Statement targetStatement = targetConn.createStatement();
    String lastScn = Constants.LAST_SCN; String operation =null;
    String sql =null;
    boolean isCreateDictionary =false; while(resultSet.next()){
    lastScn =resultSet.getObject(1)+&quot;&quot;;
    if( lastScn.equals(Constants.LAST_SCN) ) {
        continue; 
    }
    operation =resultSet.getObject(2)+&quot;&quot;; 
    if( &quot;DDL&quot;.equalsIgnoreCase(operation) ) {
        isCreateDictionary =true;
    }
    sql =resultSet.getObject(5)+&quot;&quot;;
    // 替换用户
    sql = sql.replace(&quot;&quot;&quot;+Constants.SOURCE_CLIENT_USERNAME+&quot;&quot;.&quot;, &quot;&quot;); System.out.println(&quot;scn=&quot;+lastScn+&quot;,自动执行sql==&quot;+sql+&quot;&quot;);
    try {
        targetStatement.executeUpdate(sql.substring(0, sql.length()-1));
    } catch (Exception e) {
        System.out.println(&quot;测试一下,已经执行过了&quot;); }
    }
    // 更新scn
    Constants.LAST_SCN = (Integer.parseInt(lastScn))+&quot;&quot;;
    // DDL发生变化，更新数据字典 if( isCreateDictionary ){
        System.out.println(&quot;DDL发生变化，更新数据字典&quot;);
        createDictionary(sourceConn); 
        System.out.println(&quot;完成更新数据字典&quot;); 
        isCreateDictionary =false;
    } 

    System.out.println(&quot;完成一个工作单元&quot;);
} finally {
    if( null!= sourceConn ) { 
        sourceConn.close();
    } 
    if( null!= targetConn ) {
        targetConn.close();
    }
    sourceConn =null;
    targetConn =null; 
    }
}
</code></pre><p>2.3 使用LogMiner做数据同步需要注意的点：</p><p>1、LogMiner是针对数据库级别的同步。<br>2、LogMiner工具的时效性较差，同步延时时间很长。<br>3、目标库必须与源库版本相同，或者比源库版本更高；目标库与源库字符集一致，或者是源库字符集的超集。<br>4、源数据库与目标库，必须运行在相同的硬件平台。<br>5、通过LogMiner方式获取日志的，通过oracle提供工具读取redo日志的信息，然后解析成SQL队列。有些特殊的数据类型，数据的变化是不记录到redo的，比如LOB字段的变化</p><p>3、总结</p><p>上面二种方案各有优缺点，但是实际工作中更需要同步延时小，同时稳定性极佳并且数据丢失率极低的方案，可以看到这二个方案并不适合做真正的数据抽取工具，来实现一个如下的方案：</p><p><img src="/2017/1091/979a4ff.png" alt=""></p><p>在下一文中，我将结合工作实战为大家介绍一款高效的数据库同步工具，最终解决微服务实施中所带来的数据统计的痛点。</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/personallyidentifiablebrains.html" rel="next" title="Personally Identifiable Brains"><i class="fa fa-chevron-left"></i> Personally Identifiable Brains</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/collectioniteratorforeach.html" rel="prev" title="Collection-Iterator-foreach">Collection-Iterator-foreach <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#三、数据抽取的技术选型"><span class="nav-number">1.</span> <span class="nav-text">三、数据抽取的技术选型</span></a></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->