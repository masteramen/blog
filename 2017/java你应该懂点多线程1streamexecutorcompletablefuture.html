<!-- build time:Sat Oct 27 2018 21:00:17 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="作者Mr_AG2017.07.29 07:05字数 2580StreamStream常用操作集合扩展类，通过Collection.stream()和Collection.parallelStream()来创建一个Stream。Stream常用操作下边操作例子数据源List&amp;lt;String&amp;gt; stringCollection = new ArrayList&amp;lt;&amp;gt;(); strin"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="Java你应该懂点多线程1-Stream、Executor、CompletableFuture"><meta property="og:url" content="http://www.jfox.info/2017/java你应该懂点多线程1streamexecutorcompletablefuture.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="作者Mr_AG2017.07.29 07:05字数 2580StreamStream常用操作集合扩展类，通过Collection.stream()和Collection.parallelStream()来创建一个Stream。Stream常用操作下边操作例子数据源List&amp;lt;String&amp;gt; stringCollection = new ArrayList&amp;lt;&amp;gt;(); strin"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.422Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java你应该懂点多线程1-Stream、Executor、CompletableFuture"><meta name="twitter:description" content="作者Mr_AG2017.07.29 07:05字数 2580StreamStream常用操作集合扩展类，通过Collection.stream()和Collection.parallelStream()来创建一个Stream。Stream常用操作下边操作例子数据源List&amp;lt;String&amp;gt; stringCollection = new ArrayList&amp;lt;&amp;gt;(); strin"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/java你应该懂点多线程1streamexecutorcompletablefuture.html"><title>Java你应该懂点多线程1-Stream、Executor、CompletableFuture | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/java你应该懂点多线程1streamexecutorcompletablefuture.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java你应该懂点多线程1-Stream、Executor、CompletableFuture</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:58:29+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>作者<a href="/u/86feb75a6296">Mr_AG</a>2017.07.29 07:05字数 2580</p><h1 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h1><h2 id="Stream常用操作"><a href="#Stream常用操作" class="headerlink" title="Stream常用操作"></a>Stream常用操作</h2><p>集合扩展类，通过<code>Collection.stream()</code>和<code>Collection.parallelStream()</code>来创建一个Stream。</p><h2 id="Stream常用操作-1"><a href="#Stream常用操作-1" class="headerlink" title="Stream常用操作"></a>Stream常用操作</h2><p>下边操作例子数据源</p><pre><code>List&lt;String&gt; stringCollection = new ArrayList&lt;&gt;();
stringCollection.add(&quot;ddd2&quot;);
stringCollection.add(&quot;aaa2&quot;);
stringCollection.add(&quot;bbb1&quot;);
stringCollection.add(&quot;aaa1&quot;);
stringCollection.add(&quot;bbb3&quot;);
stringCollection.add(&quot;ccc&quot;);
stringCollection.add(&quot;bbb2&quot;);
stringCollection.add(&quot;ddd1&quot;);
</code></pre><p>过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。</p><pre><code>stringCollection
    .stream()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);
</code></pre><p>排序是一个中间操作，返回的是排序好后的Stream。如果你不指定一个自定义的Comparator则会使用默认排序。需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据是不会被修改的。</p><pre><code>stringCollection
    .stream()
    .sorted()
    .filter((s) -&gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);
</code></pre><p>中间操作map会将元素根据指定的Function接口来依次将元素转成另外的对象，下面的示例展示了将字符串转换为大写字符串。你也可以通过map来讲对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。</p><pre><code>stringCollection
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -&gt; b.compareTo(a))
    .forEach(System.out::println);
</code></pre><p>Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是最终操作，并返回一个boolean类型的值。</p><pre><code>boolean anyStartsWithA = 
    stringCollection
        .stream()
        .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;));
System.out.println(anyStartsWithA);      // true

boolean allStartsWithA = 
    stringCollection
        .stream()
        .allMatch((s) -&gt; s.startsWith(&quot;a&quot;));
System.out.println(allStartsWithA);      // false

boolean noneStartsWithZ = 
    stringCollection
        .stream()
        .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;));
System.out.println(noneStartsWithZ);      // true
</code></pre><p>计数是一个最终操作，返回Stream中元素的个数，返回值类型是long。</p><pre><code>long startsWithB = 
    stringCollection
        .stream()
        .filter((s) -&gt; s.startsWith(&quot;b&quot;))
        .count();
System.out.println(startsWithB);    // 3
</code></pre><p>这是一个最终操作，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规越后的结果是通过Optional接口表示的。</p><pre><code>Optional&lt;String&gt; reduced =
    stringCollection
        .stream()
        .sorted()
        .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2);
reduced.ifPresent(System.out::println);
</code></pre><p>前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。</p><p>首先我们创建一个没有重复元素的大表,然后我们计算一下排序这个Stream要耗时多久</p><pre><code>int max = 1000000;
List&lt;String&gt; values = new ArrayList&lt;&gt;(max);
for (int i = 0; i &lt; max; i++) {
    UUID uuid = UUID.randomUUID();
    values.add(uuid.toString());
}
</code></pre><p>串行排序：</p><pre><code>long t0 = System.nanoTime();
long count = values.stream().sorted().count();
System.out.println(count);
long t1 = System.nanoTime();
long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis));
// 串行耗时: 899 ms
</code></pre><p>并行排序：</p><pre><code>long t0 = System.nanoTime();
long count = values.parallelStream().sorted().count();
System.out.println(count);
long t1 = System.nanoTime();
long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis));
// 并行排序耗时: 472 ms
</code></pre><p>上面两个代码几乎是一样的，但是并行版的快了50%之多，唯一需要做的改动就是将stream()改为parallelStream()。</p><h1 id="Lumbda-、Executors处理线程并发"><a href="#Lumbda-、Executors处理线程并发" class="headerlink" title="Lumbda 、Executors处理线程并发"></a>Lumbda 、Executors处理线程并发</h1><pre><code>new Thread(() -&gt; System.out.println(&quot;Single Thread Run.............&quot;)).start(); 
</code></pre><ul><li>ExecutorService管理无返回值的线程（ExecutorService+runnable）</li></ul><p>Executos支持运行异步任务，通常管理一个线程池，这样一来我们就不需要手动去创建新的线程。</p><pre><code>ExecutorService executorService = Executors.newSingleThreadExecutor();  
executorService.submit(() -&gt; {  
    try {  
        TimeUnit.SECONDS.sleep(4);  
    } catch (InterruptedException e1) {  
        e1.printStackTrace();  
    }  
    System.out.println(&quot;thread managed by executorservice……&quot;);  
});  
try {  
    System.out.println(&quot;尝试关闭ExecutorService&quot;);  
    executorService.shutdown();  
    //指定一段时间温和关闭  
    executorService.awaitTermination(5, TimeUnit.SECONDS);  
}  
catch (InterruptedException e) {  
    System.out.println(&quot;任务中断……&quot;);  
}  
finally {  
    if (!executorService.isTerminated()) {  
        System.out.println(&quot;结束未完成的任务……&quot;);  
    }  
    executorService.shutdownNow();  
    System.out.println(&quot;ExecutorService被停止……&quot;);  
}  
</code></pre><p><strong>注</strong>：Java进程从没有停止！Executors必须显式的停止-否则它们将持续监听新的任务。如果执行executorService.shutdown();时任务未终止，会报java.lang.InterruptedException: sleep interrupted异常。</p><ul><li><p>ExecutorService管理有返回值的线程（ExecutorService+callable+future）</p><p>Callable<string>callable = ()-&gt; {</string></p><pre><code>TimeUnit.SECONDS.sleep(4);  
return &quot;managed by executor and have result to return&quot;;  
</code></pre><p>};<br>ExecutorService executorService = Executors.newSingleThreadExecutor();<br>Future<string>future = executorService.submit(callable);<br>try {</string></p><pre><code>String result = future.get();  
System.out.print(result);   
</code></pre><p>} catch (Exception e) {</p><pre><code>e.printStackTrace();  
</code></pre><p>}</p></li></ul><p><strong>注</strong>：future.get()是一个阻塞的方法，上述代码中大约4s之后值才输出出来</p><ul><li><p>Executors批量处理多个callable并返回所有callable的运行结果（Executor+callable+future+invokeAll）</p><p>private static void testInvokeAll(){<br>ExecutorService executorService = Executors.newWorkStealingPool();<br>List&lt;Callable<string>&gt; callables = Arrays.asList(getCallable(“download apk………..”, 4),getCallable(“download files………..”, 10),getCallable(“download pictures………..”, 6));<br>try {</string></p><pre><code>executorService.invokeAll(callables)  
 .stream()  
 .map(future -&gt;{  
     try{  
         return future.get();  
     }catch (Exception e) {  
        e.printStackTrace();  
        return &quot;&quot;;  
    }  
 })  
 .forEach(System.out::println);  
</code></pre><p>} catch (InterruptedException e) {</p><pre><code>e.printStackTrace();  
</code></pre><p>}<br>}</p><p>private static Callable<string>getCallable(String s,long time){<br>Callable<string>callable = ()-&gt; {</string></string></p><pre><code>TimeUnit.SECONDS.sleep(time);  
return s;  
</code></pre><p>};<br>return callable;<br>}</p></li></ul><p><strong>注</strong>：三个任务执行的时间分别为4s、10s、6s，invokeAll会在所有的任务都执行完也就是10s之后才输出结果</p><ul><li>Executors批量处理多个callable并返回运行最快的callable的运行结果（Executor+invokeAny）</li></ul><pre><code>long startTime = System.currentTimeMillis(); 
ExecutorService executorService = Executors.newWorkStealingPool();  
List&lt;Callable&lt;String&gt;&gt; callables = Arrays.asList(getCallable(&quot;download apk...........&quot;, 4),getCallable(&quot;download files...........&quot;, 10),getCallable(&quot;download pictures...........&quot;, 6));  
try {  
    String result = executorService.invokeAny(callables);  
    System.out.println(&quot;执行...&quot;+result+&quot;...花了.........&quot;+(System.currentTimeMillis() - startTime)/1000 +&quot;s..............&quot;);  
} catch (Exception e) {  
    e.printStackTrace();  
}  
</code></pre><p><strong>注</strong>：invokeAll返回集合中所有callable的结果，invokeAny只返回一个值，即运行最快的那个callable的值</p><ul><li><p>Executors延迟一段时间执行任务（executorService.schedule(task,time,timeUnit)）</p><p>ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);</p><pre><code>executorService.schedule(() -&gt; System.out.println(&quot;test delay runnable..............&quot;), 3, TimeUnit.SECONDS);  
</code></pre></li></ul><ul><li><p>Executors以固定时间执行任务（executorService.scheduleAtFixedRate()）</p><p>ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);<br>executorService.scheduleAtFixedRate(() -&gt; System.out.println(“test fixed delay runnable…………..”), 3,5, TimeUnit.SECONDS);</p></li></ul><p>3s后第一次输出结果，然后每5s执行一次任务<br>注：scheduleAtFixedRate()并不考虑任务的实际用时。所以，如果你指定了一个period为1分钟而任务需要执行2分钟，那么线程池为了性能会更快的执行。</p><ul><li><p>Executors两次任务之间以固定的间隔执行（executorService.scheduleWithFixedDelay()）</p><p>ScheduledExecutorService executorService = Executors.newScheduledThreadPool(1);<br>executorService.scheduleWithFixedDelay(() -&gt;<br>{</p><pre><code>System.out.println(&quot;test fixed delay runnable..............&quot;);  
try {  
    TimeUnit.SECONDS.sleep(2);  
} catch (InterruptedException e) {  
    e.printStackTrace();  
}
</code></pre><p>}, 3,5, TimeUnit.SECONDS);</p></li></ul><p><strong>注</strong>：该方法是在3s后第一次执行任务输出结果，然后在任务执行完后的时间间隔是5，即以后每隔7s输出一次结果（执行任务的时间+任务间隔）</p><h1 id="CompletableFuture"><a href="#CompletableFuture" class="headerlink" title="CompletableFuture"></a>CompletableFuture</h1><p>CompletableFuture有两个主要的方面优于ol中的Future – 异步回调/转换，这能使得从任何时刻的任何线程都可以设置CompletableFuture的值。</p><p>手动地创建CompletableFuture是我们唯一的选择吗？不一定。就像一般的Futures，我们可以关联存在的任务，同时CompletableFuture使用工厂方法：</p><pre><code>static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier);
static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor);
static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable);
static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor);
</code></pre><p>runAsync()易于理解，注意它需要Runnable，因此它返回<code>CompletableFuture&lt;Void&gt;</code>作为Runnable不返回任何值。如果你需要处理异步操作并返回结果，使用<code>Supplier&lt;U&gt;</code>:</p><pre><code>final CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; {
    //...long running...
    return &quot;42&quot;;
}, executor);
//或
final CompletableFuture&lt;String&gt; future =
    CompletableFuture.supplyAsync(() -&gt; longRunningTask(params), executor);


CompletableFuture&lt;String&gt; safe =
    future.exceptionally(ex -&gt; &quot;We have a problem: &quot; + ex.getMessage());
</code></pre><p>exceptionally()接受一个函数时，将调用原始future来抛出一个异常。我们会有机会将此异常转换为和Future类型的兼容的一些值来进行恢复。safe进一步的转换将不再产生一个异常而是从提供功能的函数返回一个String值。</p><p>一个更加灵活的方法是handle()接受一个函数，它接收正确的结果或异常：</p><pre><code>CompletableFuture&lt;Integer&gt; safe = future.handle((ok, ex) -&gt; {
    if (ok != null) {
        return Integer.parseInt(ok);
    } else {
        log.warn(&quot;Problem&quot;, ex);
        return -1;
    }
});
</code></pre><ul><li><p>转换和作用于CompletableFuture(thenApply)</p><p><u>CompletableFuture<u> thenApply(Function&lt;? super T,? extends U&gt; fn);<br><u>CompletableFuture<u> thenApplyAsync(Function&lt;? super T,? extends U&gt; fn);<br><u>CompletableFuture<u> thenApplyAsync(Function&lt;? super T,? extends U&gt; fn, Executor executor);</u></u></u></u></u></u></p></li></ul><p>例子：</p><pre><code>CompletableFuture&lt;String&gt; f1 = //...
CompletableFuture&lt;Integer&gt; f2 = f1.thenApply(Integer::parseInt);
CompletableFuture&lt;Double&gt; f3 = f2.thenApply(r -&gt; r * r * Math.PI);
</code></pre><ul><li><p>运行完成的代码（thenAccept/thenRun）</p><p>CompletableFuture<void>thenAccept(Consumer&lt;? super T&gt; block);<br>CompletableFuture<void>thenRun(Runnable action);</void></void></p></li></ul><p>在future的管道里有两种典型的“最终”阶段方法。他们在你使用future的值的时候做好准备，当 thenAccept()提供最终的值时，thenRun执行 Runnable，这甚至没有方法去计算值。例如：</p><pre><code>future.thenAcceptAsync(dbl -&gt; log.debug(&quot;Result: {}&quot;, dbl), executor);
log.debug(&quot;Continuing&quot;);
</code></pre><p>…Async变量也可用两种方法，隐式和显式执行器，我不会过多强调这个方法。<br>thenAccept()/thenRun()方法并没有发生阻塞（即使没有明确的executor)。它们像一个事件侦听器/处理程序，你连接到一个future时，这将执行一段时间。”Continuing”消息将立即出现，尽管future甚至没有完成。</p><ul><li>结合（链接）这两个futures（thenCompose()）</li></ul><p>时你想运行一些future的值（当它准备好了），但这个函数也返回了future。CompletableFuture足够灵活地明白我们的函数结果现在应该作为顶级的future，对比<code>CompletableFuture&lt;CompletableFuture&gt;</code>。方法 thenCompose()相当于Scala的flatMap：</p><pre><code>&lt;U&gt; CompletableFuture&lt;U&gt; thenCompose(Function&lt;? super T,CompletableFuture&lt;U&gt;&gt; fn);
</code></pre><p>…Async变化也是可用的，在下面的事例中，仔细观察thenApply()(map)和thenCompose()（flatMap）的类型和差异，当应用calculateRelevance()方法返回CompletableFuture：</p><pre><code>CompletableFuture&lt;Document&gt; docFuture = //...

CompletableFuture&lt;CompletableFuture&lt;Double&gt;&gt; f =
    docFuture.thenApply(this::calculateRelevance);

CompletableFuture&lt;Double&gt; relevanceFuture =
    docFuture.thenCompose(this::calculateRelevance);

//...

private CompletableFuture&lt;Double&gt; calculateRelevance(Document doc)  //...
</code></pre><ul><li><p>两个futures的转换值(thenCombine())<br>当thenCompose()用于链接一个future时依赖另一个thenCombine，当他们都完成之后就结合两个独立的futures：</p><p>&lt;U,V&gt; CompletableFuture<v>thenCombine(CompletableFuture&lt;? extends U&gt; other, BiFunction&lt;? super T,? super U,? extends V&gt; fn)</v></p></li></ul><p>…Async变量也是可用的，假设你有两个CompletableFuture，一个加载Customer另一个加载最近的Shop。他们彼此完全独立，但是当他们完成时，您想要使用它们的值来计算Route。这是一个可剥夺的例子：</p><pre><code>CompletableFuture&lt;Customer&gt; customerFuture = loadCustomerDetails(123);
CompletableFuture&lt;Shop&gt; shopFuture = closestShop();
CompletableFuture&lt;Route&gt; routeFuture =
    customerFuture.thenCombine(shopFuture, (cust, shop) -&gt; findRoute(cust, shop));

//...

private Route findRoute(Customer customer, Shop shop) //...
</code></pre><p>你也知道，我们有customerFuture 和 shopFuture。那么routeFuture包装它们然后“等待”它们完成。当他们准备好了，它会运行我们提供的函数来结合所有的结果(findRoute())。当两个基本的futures完成并且 findRoute()也完成时，这样routeFuture将会完成。</p><ul><li><p>等待所有的 CompletableFutures 完成<br>如果不是产生新的CompletableFuture连接这两个结果，我们只是希望当完成时得到通知，我们可以使用thenAcceptBoth()/runAfterBoth()系列的方法，（…Async 变量也是可用的）。它们的工作方式与thenAccept() 和 thenRun()类似，但是是等待两个futures而不是一个：</p><p><u>CompletableFuture<void>thenAcceptBoth(CompletableFuture&lt;? extends U&gt; other, BiConsumer&lt;? super T,? super U&gt; block)<br>CompletableFuture<void>runAfterBoth(CompletableFuture&lt;?&gt; other, Runnable action)</void></void></u></p></li></ul><ul><li>等待第一个 CompletableFuture 来完成任务</li></ul><p>另一个有趣的事是CompletableFutureAPI可以等待第一个（与所有相反）完成的future。当你有两个相同类型任务的结果时就显得非常方便，你只要关心响应时间就行了，没有哪个任务是优先的。API方法(…Async变量也是可用的）：</p><pre><code>CompletableFuture&lt;Void&gt; acceptEither(CompletableFuture&lt;? extends T&gt; other, Consumer&lt;? super T&gt; block)
CompletableFuture&lt;Void&gt; runAfterEither(CompletableFuture&lt;?&gt; other, Runnable action)
</code></pre><p>作为一个例子，你有两个系统可以集成。一个具有较小的平均响应时间但是拥有高的标准差，另一个一般情况下较慢，但是更加容易预测。为了两全其美（性能和可预测性）你可以在同一时间调用两个系统并等着谁先完成。通常这会是第一个系统，但是在进度变得缓慢时，第二个系统就可以在可接受的时间内完成：</p><pre><code>CompletableFuture&lt;String&gt; fast = fetchFast();
CompletableFuture&lt;String&gt; predictable = fetchPredictably();
fast.acceptEither(predictable, s -&gt; {
    System.out.println(&quot;Result: &quot; + s);
});
</code></pre><p>s代表了从fetchFast()或是fetchPredictably()得到的String。我们不必知道也无需关心。</p><p>applyToEither()算是 acceptEither()的前辈了。当两个futures快要完成时，后者只是简单地调用一些代码片段，applyToEither()将会返回一个新的future。当这两个最初的futures完成时，新的future也会完成。API有点类似于(…Async 变量也是可用的)：</p><pre><code>&lt;U&gt; CompletableFuture&lt;U&gt; applyToEither(CompletableFuture&lt;? extends T&gt; other, Function&lt;? super T,U&gt; fn)
</code></pre><p>这个额外的fn功能在第一个future被调用时能完成。我不确定这个专业化方法的目的是什么，毕竟一个人可以简单地使用：fast.applyToEither(predictable).thenApply(fn)。因为我们坚持用这个API，但我们的确不需要额外功能的应用程序，我会简单地使用Function.identity()占位符：</p><pre><code>CompletableFuture&lt;String&gt; fast = fetchFast();
CompletableFuture&lt;String&gt; predictable = fetchPredictably();
CompletableFuture&lt;String&gt; firstDone =
    fast.applyToEither(predictable, Function.&lt;String&gt;identity());
</code></pre><p>第一个完成的future可以通过运行。请注意，从客户的角度来看，两个futures实际上是在firstDone的后面而隐藏的。客户端只是等待着future来完成并且通过applyToEither()使得当最先的两个任务完成时通知客户端。</p><p>我们现在知道如何等待两个future来完成（使用thenCombine()）并第一个完成(applyToEither())。但它可以扩展到任意数量的futures吗？的确，使用static辅助方法：</p><pre><code>static CompletableFuture&lt;Void&lt; allOf(CompletableFuture&lt;?&lt;... cfs)
static CompletableFuture&lt;Object&lt; anyOf(CompletableFuture&lt;?&lt;... cfs)
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/nettyinboundoutbound信道处理器定义.html" rel="next" title="Netty Inbound/Outbound信道处理器定义"><i class="fa fa-chevron-left"></i> Netty Inbound/Outbound信道处理器定义</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/java线程池艺术探索.html" rel="prev" title="Java 线程池艺术探索">Java 线程池艺术探索 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Stream"><span class="nav-number">1.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream常用操作"><span class="nav-number">1.1.</span> <span class="nav-text">Stream常用操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream常用操作-1"><span class="nav-number">1.2.</span> <span class="nav-text">Stream常用操作</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Lumbda-、Executors处理线程并发"><span class="nav-number">2.</span> <span class="nav-text">Lumbda 、Executors处理线程并发</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CompletableFuture"><span class="nav-number">3.</span> <span class="nav-text">CompletableFuture</span></a></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->