<!-- build time:Sat Oct 27 2018 21:00:16 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="作者落叶飞逝的恋2017.08.03 23:01字数 1946Spring MVC会根据请求方法签名不同，将请求消息中信息以一定方式转换并绑定到请求方法的参数中。1.数据绑定流程Spring MVC通过反射机制对目标处理方法的签名进行分析，并将请求消息绑定到处理方法的参数上。数据绑定的核心部件是DatabinderSpring MVC数据绑定机制  1.Spring MVC框架将ServletRe"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="Spring MVC的数据转换及数据格式化"><meta property="og:url" content="http://www.jfox.info/2017/springmvc的数据转换及数据格式化.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="作者落叶飞逝的恋2017.08.03 23:01字数 1946Spring MVC会根据请求方法签名不同，将请求消息中信息以一定方式转换并绑定到请求方法的参数中。1.数据绑定流程Spring MVC通过反射机制对目标处理方法的签名进行分析，并将请求消息绑定到处理方法的参数上。数据绑定的核心部件是DatabinderSpring MVC数据绑定机制  1.Spring MVC框架将ServletRe"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2017/1472/dbee536.png"><meta property="og:updated_time" content="2018-10-27T12:29:37.415Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring MVC的数据转换及数据格式化"><meta name="twitter:description" content="作者落叶飞逝的恋2017.08.03 23:01字数 1946Spring MVC会根据请求方法签名不同，将请求消息中信息以一定方式转换并绑定到请求方法的参数中。1.数据绑定流程Spring MVC通过反射机制对目标处理方法的签名进行分析，并将请求消息绑定到处理方法的参数上。数据绑定的核心部件是DatabinderSpring MVC数据绑定机制  1.Spring MVC框架将ServletRe"><meta name="twitter:image" content="http://www.jfox.info/2017/1472/dbee536.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/springmvc的数据转换及数据格式化.html"><title>Spring MVC的数据转换及数据格式化 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/springmvc的数据转换及数据格式化.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Spring MVC的数据转换及数据格式化</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:59:32+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>作者<a href="/u/24fffffbd71a">落叶飞逝的恋</a>2017.08.03 23:01字数 1946<br>Spring MVC会根据请求方法签名不同，将请求消息中信息以一定方式转换并绑定到请求方法的参数中。</p><h3 id="1-数据绑定流程"><a href="#1-数据绑定流程" class="headerlink" title="1.数据绑定流程"></a>1.数据绑定流程</h3><p>Spring MVC通过反射机制对目标处理方法的签名进行分析，并将请求消息绑定到处理方法的参数上。数据绑定的核心部件是<strong>Databinder</strong><br><img src="/2017/1472/dbee536.png" alt=""></p><pre><code>Spring MVC数据绑定机制 
</code></pre><ul><li><p>1.Spring MVC框架将ServletRequest对象及处理方法的参数实例传递给DataBinder。</p></li><li><p>2.DataBinder调用装配在Spring Web上下文中的ConversionService组件进行数据类型转换、<br>数据格式化工作，并将ServletRequest中的消息填充到参数对象中。</p></li><li><p>3.然后再调用Validator组件对已经绑定的请求消息数据的参数对象进行数据合法性校验。</p></li><li><p>4.最终生成数据绑定结果BindingResult对象，BindingResult包含已完成数据绑定的参数对象，还包含相应的校验错误的对象。</p></li><li><p>5.Spring MVC抽取BindingResult中的参数对象及校验对象，将它们赋给处理方法的相应参数。</p></li></ul><h3 id="2-数据转换-ConversionService"><a href="#2-数据转换-ConversionService" class="headerlink" title="2.数据转换(ConversionService)"></a>2.数据转换(ConversionService)</h3><p>在Java语言中，在java.beans包中提供了一个PropertyEditor接口来进行数据转换(只能用于字符串和Java对象的转换)。其功能就是将一个字符串转换为一个Java对象。</p><p>Spring 3.0，添加了一个通用的类型转换模块，位于org.springframework.core.convert包中。</p><h4 id="2-1-ConversionServiceboolean-canConvert-TypeDescriptor-sourceType-TypeDescriptor-targetType"><a href="#2-1-ConversionServiceboolean-canConvert-TypeDescriptor-sourceType-TypeDescriptor-targetType" class="headerlink" title="2.1 ConversionServiceboolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType)"></a>2.1 ConversionServiceboolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType)</h4><p>org.springframework.core.convert.ConversionService是Spring类型转换的核心接口。</p><ul><li>boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</li></ul><p>判断是否可以将一个Java类转换为另一个Java类</p><ul><li>boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType)</li></ul><p>TypeDescriptor不但描述了需要转换类的信息，还描述了类的上下文信息。这样可以利用这些信息做出更多的各种灵活的控制。</p><ul><li><t>T convert(Object source, Class<t>targetType)</t></t></li></ul><p>将源类型对象转换为目标类型对象</p><ul><li>Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</li></ul><p>将源类型从源类型对象转换为目标类型对象，通常利用到类中的上下文信息</p><p>可以利用org.springframework.context.support.ConversionServiceFactoryBean在Spring的上下文中定义一个ConversionService。Spring将自动识别出上下文种的ConversionService，并在Spring MVC处理方法的参数绑定中使用它进行数据转换。</p><pre><code>&lt;bean class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;/&gt;
</code></pre><h4 id="2-2-Spring支持的转换器"><a href="#2-2-Spring支持的转换器" class="headerlink" title="2.2 Spring支持的转换器"></a>2.2 Spring支持的转换器</h4><p>Spring 在org.springframework.core.convert.converter包中定义了3种类型的转换器接口，我们可以实现其中任意一种转换接口，并将它作为自定义转换器注册到ConversionServiceFactoryBean当中。</p><p>Spring中最简单的一个转换器接口。该方法负责将S类型转换为T类型的对象。</p><p>如果希望将一种类型的对象转换为另一种类型及其子类对象，比如将String类型转换为Number以及Number的子类Integer、Double等对象。就需要一系列的Converter。该接口的作用就是将这一系列的相同的Converter封装在一起。</p><p>Converter&lt;S，T&gt;只是负责将一个类型的对象转换为另一个类型的对象，它并没有考虑类型对象的上下文信息。因此不能完成复杂类型的转换工作。而该接口会根据源类型的对象及其上下文进行类型转换。</p><p>Code</p><pre><code>public class User implements Serializable {
    private String loginname;

    private Date birthday;

    public String getLoginname() {
        return loginname;
    }

    public void setLoginname(String loginname) {
        this.loginname = loginname;
    }

    public Date getBirthday() {
        return birthday;
    }

    public void setBirthday(Date birthday) {
        this.birthday = birthday;
    }
}


&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Sign Up&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action=&quot;/user/register&quot; method=&quot;post&quot;&gt;
    &lt;table&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label&gt;登录名：&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;loginname&quot; name=&quot;loginname&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;&lt;label&gt;生日：&lt;/label&gt;&lt;/td&gt;
            &lt;td&gt;&lt;input type=&quot;text&quot; id=&quot;birthday&quot; name=&quot;birthday&quot;&gt;&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
            &lt;td&gt;
                &lt;input type=&quot;submit&quot; id=&quot;submit&quot; value=&quot;登录&quot;&gt;
            &lt;/td&gt;
        &lt;/tr&gt;
    &lt;/table&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;


@RequestMapping(value = &quot;register&quot;, method = RequestMethod.POST)
public String register(@ModelAttribute User user, Model model) {
    model.addAttribute(&quot;user&quot;, user);
    return &quot;success&quot;;
}
</code></pre><p>这时候，前台输入的生日为String格式的。而User实体定义的是Date时间类型的。那么后台再接收的时候，就会报错。</p><p>这时候，我们就自定义类型转换器。实现ConversionService里面的最简单的Converter&lt;S,T&gt;</p><pre><code>public class StringToDateConverter implements Converter&lt;String, Date&gt; {

    /**
     * 日期类型模板，如yyyy-MM-dd
     */
    private String datePattern;

    public void setDatePattern(String datePattern) {
        this.datePattern = datePattern;
    }

    @Override
    public Date convert(String date) {
        Date result = null;
        try {
            SimpleDateFormat dateFormat = new SimpleDateFormat(this.datePattern);
            result = dateFormat.parse(date);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return result;
    }
}


&lt;!--装配自定义的类型转换器--&gt;
&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;

&lt;!--自定义Date类型转换器--&gt;
&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;converters&quot;&gt;
        &lt;bean class=&quot;utils.StringToDateConverter&quot; p:datePattern=&quot;yyyy-MM-dd&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="注册方法"><a href="#注册方法" class="headerlink" title="注册方法"></a>注册方法</h4><ul><li>1.InitBinder（不推荐使用java.beans.PropertyEditor）</li></ul><p>刚才上面的注册方式是通过xml配置进行的操作，那么我们可以不借助xml配置，使用@InitBinder添加自定义编辑转换数据。这里就用到了Java自身的PropertyEditor类。</p><ul><li><p>自定义方法实现PropertyEditor的相关类</p><p>public class DateEditor extends PropertyEditorSupport {</p><pre><code>@Override
public void setAsText(String text) throws IllegalArgumentException {
    SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
    try {
        Date date = dateFormat.parse(text);
        setValue(date);
    } catch (Exception ex) {
        ex.printStackTrace();
    }
}
</code></pre><p>}</p></li></ul><pre><code>@InitBinder
public void initBinder(WebDataBinder binder){
    binder.registerCustomEditor(Date.class,new DateEditor());
}
</code></pre><ul><li>2.WebBindingInitializer（不推荐使用java.beans.PropertyEditor）</li></ul><p>如果这个数据转换需要在系统多处使用，那么这个自定义转换器方法需要进行全局注册。使用WebBindingInitializer进行全局范围的注册。</p><h3 id="3-数据格式化（Fommatter）"><a href="#3-数据格式化（Fommatter）" class="headerlink" title="3.数据格式化（Fommatter）"></a>3.数据格式化（Fommatter<t>）</t></h3><p>Spring使用Converter转换器进行源类型对象到目标类型对象的转换。但是Converter并不能够进行输入或输出的信息的格式化。</p><p>Spring 3.0引入格式化转换框架，org.springframework.format，Formatte<t>为最重要的接口。</t></p><p>Converter接口是完成任意Object与Object之间的转换，而Formatter是完成任意Object与String的转换。所以Formatter接口更适合在Web层，处理用户表单提交的数据格式化。</p><p>Formatter<t>接口，完成T类型对象的格式化和解析功能。</t></p><pre><code>public interface Formatter&lt;T&gt; extends Printer&lt;T&gt;, Parser&lt;T&gt; {

}
</code></pre><h4 id="3-1重要接口"><a href="#3-1重要接口" class="headerlink" title="3.1重要接口"></a>3.1重要接口</h4><p>格式化显示接口</p><pre><code>T parse(String text, Locale locale) throws ParseException;
</code></pre><p>解析接口，参考本地信息，将一个格式化后的字符串转换为T类型的对象。</p><p>Formatter<t>继承上面两个接口类，具备所继承接口的所有功能。</t></p><p>注册格式化转换器。一般很少单独用到，我们一般用到的FormattingConversionServiceFactoryBean这个里面已经封装了这个接口对象。</p><ul><li>AnnotationFormatterFactory<a extends="" annotation=""></a></li></ul><p>注解驱动的字段格式化工厂，用于创建带注解的对象字段的Printer和Parser。即是用于格式化和解析带注释的对象字段。</p><pre><code>//注解A的应用范围，哪些属性类可以标注A注解
Set&lt;Class&lt;?&gt;&gt; getFieldTypes();


//根据A注解，获取特定属性类型Printer
Printer&lt;?&gt; getPrinter(A annotation, Class&lt;?&gt; fieldType);


//根据A注解，获取特定属性类型Parser
Parser&lt;?&gt; getParser(A annotation, Class&lt;?&gt; fieldType);
</code></pre><h4 id="3-2-自定义实现Formatter接口（了解下实现方式）"><a href="#3-2-自定义实现Formatter接口（了解下实现方式）" class="headerlink" title="3.2 自定义实现Formatter接口（了解下实现方式）"></a>3.2 自定义实现Formatter接口（了解下实现方式）</h4><pre><code>public class DateFormatter implements Formatter&lt;Date&gt; {

    private String datePattern;

    private SimpleDateFormat dateFormat;

    public DateFormatter(String datePattern) {
        this.datePattern = datePattern;
        dateFormat = new SimpleDateFormat(datePattern);

    }

    @Override
    public Date parse(String text, Locale locale) throws ParseException {
        Date result = null;
        try {
            result = dateFormat.parse(text);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return result;
    }

    @Override
    public String print(Date object, Locale locale) {
        return dateFormat.format(object);
    }
}


&lt;!--装配自定义格式转化器--&gt;
&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;


&lt;!--配置自定义格式化转换器bean--&gt;
&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;formatters&quot;&gt;
        &lt;bean class=&quot;utils.DateFormatter&quot; c:datePattern=&quot;yyyy-MM-dd&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="3-3-使用系统内置的转换器（推荐这种方式）"><a href="#3-3-使用系统内置的转换器（推荐这种方式）" class="headerlink" title="3.3 使用系统内置的转换器（推荐这种方式）"></a>3.3 使用系统内置的转换器（推荐这种方式）</h4><p>当然Spring本身就提供了很多内置的转换器，不需要我们再写多余的代码。比如上面我们自定义的时间格式转化器。Spring内置的org.springframework.format.datetime包中就有对应的DateFormatter实现类。</p><p>我们只需要定义xml就可以了，如下。</p><pre><code>&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;formatters&quot;&gt;
        &lt;bean class=&quot;org.springframework.format.datetime.DateFormatter&quot; c:pattern=&quot;yyyy-MM-dd&quot;/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="3-4-自定义使用FormatterRegister注册Formatter-只需要了解，无须掌握，太麻烦"><a href="#3-4-自定义使用FormatterRegister注册Formatter-只需要了解，无须掌握，太麻烦" class="headerlink" title="3.4 自定义使用FormatterRegister注册Formatter(只需要了解，无须掌握，太麻烦)"></a>3.4 自定义使用FormatterRegister注册Formatter(只需要了解，无须掌握，太麻烦)</h4><p>前面我们直接在xml里面注册Formatter实现类，那么我们还可以直接在xml里面注册Registrar，来替代直接注册Formatter。</p><p>自定义出FormatterRegistrar类</p><pre><code>public class CustomerFormatterRegistrar implements FormatterRegistrar {

    private DateFormatter dateFormatter;

    public CustomerFormatterRegistrar(DateFormatter dateFormatter) {
        this.dateFormatter = dateFormatter;
    }

    @Override
    public void registerFormatters(FormatterRegistry registry) {
        registry.addFormatter(dateFormatter);
    }
}
</code></pre><p>自定义出DateFormmater类</p><pre><code>public class DateFormatter implements Formatter&lt;Date&gt; {

    private String datePattern;

    private SimpleDateFormat dateFormat;

    public DateFormatter(String datePattern) {
        this.datePattern = datePattern;
        dateFormat = new SimpleDateFormat(datePattern);

    }

    @Override
    public Date parse(String text, Locale locale) throws ParseException {
        Date result = null;
        try {
            result = dateFormat.parse(text);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        return result;
    }

    @Override
    public String print(Date object, Locale locale) {
        return dateFormat.format(object);
    }
}


&lt;!--装配自定义格式转化器--&gt;
&lt;mvc:annotation-driven conversion-service=&quot;conversionService&quot;/&gt;


&lt;!--在Spring上下文定义出自定义的时间转化器组件--&gt;
&lt;bean id=&quot;dateFormatter&quot; class=&quot;utils.DateFormatter&quot; c:datePattern=&quot;yyyy-MM-dd&quot;&gt;&lt;/bean&gt;

&lt;bean id=&quot;conversionService&quot; class=&quot;org.springframework.format.support.FormattingConversionServiceFactoryBean&quot;&gt;
    &lt;property name=&quot;formatterRegistrars&quot;&gt;
        &lt;bean class=&quot;utils.CustomerFormatterRegistrar&quot; c:dateFormatter-ref=&quot;dateFormatter&quot;&gt;&lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre><h4 id="3-5-使用注解的方式来进行格式化工作（AnnotationFormatterFactory）"><a href="#3-5-使用注解的方式来进行格式化工作（AnnotationFormatterFactory）" class="headerlink" title="3.5 使用注解的方式来进行格式化工作（AnnotationFormatterFactory）"></a>3.5 使用注解的方式来进行格式化工作（AnnotationFormatterFactory<a extends="" annotation="">）</a></h4><p>前面的例子无论是自定义实现数据格式工作还是使用系统内置的类，都需要通过进行繁琐的xml配置。现在我们直接使用<strong>注解_Annotation</strong>的方式进行实现格式化工作。</p><p>org.springframework.format.annotation 定义了两个格式化的注解类型</p><p>@DateTimeFormat 注解可以对java.util.Date、java.util.Calendar等时间类型的属性进行标注。该类支持下面三种互斥属性</p><p>==互斥属性指的是只能拥有其一，不然同时具备。==</p><pre><code>//自定义时间格式
private String pattern;

private String stylePattern;

private ISO iso;
</code></pre><p>stylePattern</p><pre><code>/**
 * Set the two character to use to format date values. The first character used for
 * the date style, the second is for the time style. Supported characters are
 * &lt;ul&gt;
 * &lt;li&gt;&apos;S&apos; = Small&lt;/li&gt;短日期/时间的样式
 * &lt;li&gt;&apos;M&apos; = Medium&lt;/li&gt;中日期/时间的样式
 * &lt;li&gt;&apos;L&apos; = Long&lt;/li&gt;长日期/时间的样式
 * &lt;li&gt;&apos;F&apos; = Full&lt;/li&gt;完整日期/时间的样式
 * &lt;li&gt;&apos;-&apos; = Omitted&lt;/li&gt;忽略日期/时间的样式
 * &lt;ul&gt;
 * This method mimics the styles supported by Joda-Time.
 * @param stylePattern two characters from the set {&quot;S&quot;, &quot;M&quot;, &quot;L&quot;, &quot;F&quot;, &quot;-&quot;}
 * @since 3.2
 */
public void setStylePattern(String stylePattern) {
    this.stylePattern = stylePattern;
}
</code></pre><p>IOS几种可选值</p><pre><code>formats.put(ISO.DATE, &quot;yyyy-MM-dd&quot;);
formats.put(ISO.TIME, &quot;HH:mm:ss.SSSZ&quot;);
formats.put(ISO.DATE_TIME, &quot;yyyy-MM-dd&apos;T&apos;HH:mm:ss.SSSZ&quot;);
</code></pre><p>NumberFormat可对类似数字类型的属性进行标注，它拥有两个互斥的属性。</p><pre><code>String pattern()

Style style()
</code></pre><p>style可选枚举值</p><pre><code>enum Style {

    /**
     * The default format for the annotated type: typically &apos;number&apos; but possibly
     * &apos;currency&apos; for a money type (e.g. {@code javax.money.MonetaryAmount)}.
     * @since 4.2
     */
    DEFAULT,

    /**
     * The general-purpose number format for the current locale.
     */
    NUMBER,

    /**
     * The percent format for the current locale.
     */
    PERCENT,

    /**
     * The currency format for the current locale.
     */
    CURRENCY
}
</code></pre><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><ul><li><p>后台代码新建需要进行数据转换及格式化的类。省略了get、set方法</p><p>public class User implements Serializable {</p><pre><code>private String loginname;

@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)
private Date birthday;

/**
 * 薪水，以财务格式接收
 */
@NumberFormat(style = NumberFormat.Style.NUMBER, pattern = &quot;#,###&quot;)
private double salary;

/**
 * 业绩完成比例
 */
@NumberFormat(style = NumberFormat.Style.PERCENT)
private double performance;

/**
 * 薪水的货币类型展示
 */
@NumberFormat(style = NumberFormat.Style.CURRENCY)
private double salaryDisplay;
</code></pre><p>}</p></li></ul><pre><code>&lt;mvc:annotation-driven/&gt;
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/六struts2配置文件.html" rel="next" title="(六)Struts2 配置文件"><i class="fa fa-chevron-left"></i> (六)Struts2 配置文件</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/java对excel表格的上传和下载处理-2.html" rel="prev" title="java对excel表格的上传和下载处理">java对excel表格的上传和下载处理 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数据绑定流程"><span class="nav-number">1.</span> <span class="nav-text">1.数据绑定流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-数据转换-ConversionService"><span class="nav-number">2.</span> <span class="nav-text">2.数据转换(ConversionService)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-ConversionServiceboolean-canConvert-TypeDescriptor-sourceType-TypeDescriptor-targetType"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 ConversionServiceboolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-Spring支持的转换器"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 Spring支持的转换器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#注册方法"><span class="nav-number">2.3.</span> <span class="nav-text">注册方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-数据格式化（Fommatter）"><span class="nav-number">3.</span> <span class="nav-text">3.数据格式化（Fommatter）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1重要接口"><span class="nav-number">3.1.</span> <span class="nav-text">3.1重要接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-自定义实现Formatter接口（了解下实现方式）"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 自定义实现Formatter接口（了解下实现方式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-使用系统内置的转换器（推荐这种方式）"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 使用系统内置的转换器（推荐这种方式）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-自定义使用FormatterRegister注册Formatter-只需要了解，无须掌握，太麻烦"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 自定义使用FormatterRegister注册Formatter(只需要了解，无须掌握，太麻烦)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-使用注解的方式来进行格式化工作（AnnotationFormatterFactory）"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 使用注解的方式来进行格式化工作（AnnotationFormatterFactory）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#代码演示"><span class="nav-number">3.6.</span> <span class="nav-text">代码演示</span></a></li></ol></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->