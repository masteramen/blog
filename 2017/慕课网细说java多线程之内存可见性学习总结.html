<!-- build time:Sat Oct 27 2018 21:00:19 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="慕课网_《细说Java多线程之内存可见性》学习总结课程目标和学习内容共享变量在线程间的可见性 synchronized实现可见性 volatile实现可见性     指令重排序     as-if-serial语义     volatile使用注意事项 synchronized和volatile比较 第二章：可见性介绍2-1 可见性介绍可见性一个线程对共享变量值的修改，能够及时地被其他线程看到 共"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="慕课网_《细说Java多线程之内存可见性》学习总结"><meta property="og:url" content="http://www.jfox.info/2017/慕课网细说java多线程之内存可见性学习总结.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="慕课网_《细说Java多线程之内存可见性》学习总结课程目标和学习内容共享变量在线程间的可见性 synchronized实现可见性 volatile实现可见性     指令重排序     as-if-serial语义     volatile使用注意事项 synchronized和volatile比较 第二章：可见性介绍2-1 可见性介绍可见性一个线程对共享变量值的修改，能够及时地被其他线程看到 共"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.410Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="慕课网_《细说Java多线程之内存可见性》学习总结"><meta name="twitter:description" content="慕课网_《细说Java多线程之内存可见性》学习总结课程目标和学习内容共享变量在线程间的可见性 synchronized实现可见性 volatile实现可见性     指令重排序     as-if-serial语义     volatile使用注意事项 synchronized和volatile比较 第二章：可见性介绍2-1 可见性介绍可见性一个线程对共享变量值的修改，能够及时地被其他线程看到 共"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/慕课网细说java多线程之内存可见性学习总结.html"><title>慕课网_《细说Java多线程之内存可见性》学习总结 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/慕课网细说java多线程之内存可见性学习总结.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">慕课网_《细说Java多线程之内存可见性》学习总结</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:55:13+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="慕课网-《细说Java多线程之内存可见性》学习总结"><a href="#慕课网-《细说Java多线程之内存可见性》学习总结" class="headerlink" title="慕课网_《细说Java多线程之内存可见性》学习总结"></a>慕课网_《细说Java多线程之内存可见性》学习总结</h1><p>课程目标和学习内容</p><pre><code>共享变量在线程间的可见性
synchronized实现可见性
volatile实现可见性
    指令重排序
    as-if-serial语义
    volatile使用注意事项
synchronized和volatile比较
</code></pre><h1 id="第二章：可见性介绍"><a href="#第二章：可见性介绍" class="headerlink" title="第二章：可见性介绍"></a>第二章：可见性介绍</h1><h2 id="2-1-可见性介绍"><a href="#2-1-可见性介绍" class="headerlink" title="2-1 可见性介绍"></a>2-1 可见性介绍</h2><p>可见性</p><pre><code>一个线程对共享变量值的修改，能够及时地被其他线程看到
</code></pre><p>共享变量</p><pre><code>如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量
</code></pre><p>Java内存模型（JMM）</p><pre><code>Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取出变量这样的底层细节
</code></pre><p>Java内存模型</p><pre><code>所有的变量都存储在主内存中
每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本
（主内存中该变量的一份拷贝）
</code></pre><p>Java内存模型示意图</p><p>Java内存模型中的两条规定</p><pre><code>线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写
不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成
</code></pre><p>共享变量可见性实现的原理。如线程1对共享变量的修改要想被线程2及时看到，必须要经过如下2个步骤</p><pre><code>把工作内存1中更新过的共享变量刷新到主内存中
将主内存中最新的共享变量的值更新到工作内存2中
</code></pre><p>共享变量可见性实现的原理示意图</p><h1 id="第三章：synchronized实现可见性"><a href="#第三章：synchronized实现可见性" class="headerlink" title="第三章：synchronized实现可见性"></a>第三章：synchronized实现可见性</h1><h2 id="3-1-synchronized实现可见性原理"><a href="#3-1-synchronized实现可见性原理" class="headerlink" title="3-1 synchronized实现可见性原理"></a>3-1 synchronized实现可见性原理</h2><p>要实现共享变量的可见性，必须保证两点</p><pre><code>线程修改后的共享变量能够及时从工作内存刷新到主内存中
其他线程能够及时把共享变量的最新值从主内存更新到自己的工作内存中
</code></pre><p>Java语言层面支持的可见性实现方式</p><pre><code>synchronized
volatile
</code></pre><p>synchronized能够实现</p><pre><code>原子性（同步）
可见性
</code></pre><p>JMM关于synchronized的两条规定</p><pre><code>线程解锁前，必须把共享变量的最新值刷新到主内存中
线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值
（注意：加锁与解锁需要时同一把锁）
</code></pre><p>线程解锁前对共享变量的修改在下次加锁时对其他线程可见</p><p>线程执行互斥代码的过程</p><pre><code>1.获得互斥锁
2.清空工作内存
3.从主内存拷贝变量的最新副本到工作内存
4.执行代码
5.将更改后的共享变量的值刷新到主内存
6.释放互斥锁
</code></pre><p>重排序</p><pre><code>代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化
</code></pre><p>当前的三种重排序</p><pre><code>编译器优化的重排序（编译器优化）
指令级并行重排序（处理器优化）
内存系统的重排序（处理器优化）
</code></pre><p>重排序示意图：有可能出现下面情况</p><p>as-if-serial</p><pre><code>无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致（Java编译器、运行时和处理器都会保证Java在单线程下遵循as-if-serial语义）
</code></pre><h2 id="3-2-synchronized实现可见性（上）"><a href="#3-2-synchronized实现可见性（上）" class="headerlink" title="3-2 synchronized实现可见性（上）"></a>3-2 synchronized实现可见性（上）</h2><p>代码演示：</p><pre><code>package com.myimooc.synchronizeddemo.my;

/**
 * 程序主类
 * @author ZhangCheng on 2017-07-09
 *
 */
public class SynchronizedDemo {

    //共享变量
    private boolean ready = false;
    private int result = 0;
    private int number = 1;   
    //写操作
    public synchronized void write(){
        ready = true;                           //1.1                
        number = 2;                            //1.2                
    }
    //读操作
    public synchronized void read(){                    
        if(ready){                             //2.1
            result = number*3;         //2.2
        }       
        System.out.println(&quot;result的值为：&quot; + result);
    }

    //内部线程类
    private class ReadWriteThread extends Thread {
        //根据构造方法中传入的flag参数，确定线程执行读操作还是写操作
        private boolean flag;
        public ReadWriteThread(boolean flag){
            this.flag = flag;
        }
        @Override                                                                    
        public void run() {
            if(flag){
                //构造方法中传入true，执行写操作
                write();
            }else{
                //构造方法中传入false，执行读操作
                read();
            }
        }
    }

    public static void main(String[] args)  {
        SynchronizedDemo synDemo = new SynchronizedDemo();
        //启动线程执行写操作
        synDemo.new ReadWriteThread(true).start();
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        //启动线程执行读操作
        synDemo.new ReadWriteThread(false).start();
    }

}
</code></pre><h2 id="3-3-synchronized实现可见性（中）"><a href="#3-3-synchronized实现可见性（中）" class="headerlink" title="3-3 synchronized实现可见性（中）"></a>3-3 synchronized实现可见性（中）</h2><p>导致共享变量在线程间不可见的原因</p><pre><code>线程的交叉执行
重排序结合线程交叉执行
共享变量更新后的值没有在工作内存与主内存间及时更新
</code></pre><p>安全的代码</p><h2 id="3-4-synchronized实现可见性（下）"><a href="#3-4-synchronized实现可见性（下）" class="headerlink" title="3-4 synchronized实现可见性（下）"></a>3-4 synchronized实现可见性（下）</h2><h1 id="第四章：volatile实现可见性"><a href="#第四章：volatile实现可见性" class="headerlink" title="第四章：volatile实现可见性"></a>第四章：volatile实现可见性</h1><h2 id="4-1-volatile能够保证可见性"><a href="#4-1-volatile能够保证可见性" class="headerlink" title="4-1 volatile能够保证可见性"></a>4-1 volatile能够保证可见性</h2><p>volatile关键字</p><pre><code>能够保证volatile变量的可见性
不能保证volatile变量复合操作的原子性
</code></pre><p>volatile如何实现内存可见性</p><pre><code>深入来说：通过加入内存屏障和禁止重排序优化来实现的
    对volatile变量执行写操作时，会在写操作后加入一个store屏障指令
    对volatile变量执行读操作时，会在读操作前加入一条load屏障指令
通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中重读该变量的值，
    而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。
    这样任何时刻，不同的线程总能看到该变量的最新值
</code></pre><p>线程写volatile变量的过程</p><pre><code>改变线程工作内存中volatile变量副本的值
将改变后的副本的值从工作内存刷新到主内存
</code></pre><p>线程读volatile变量的过程</p><pre><code>从主内存中读取volatile变量的最新值到线程的工作内存中
从工作内存中读取volatile变量的副本
</code></pre><h2 id="4-2-volatile不能保证原子性（上）"><a href="#4-2-volatile不能保证原子性（上）" class="headerlink" title="4-2 volatile不能保证原子性（上）"></a>4-2 volatile不能保证原子性（上）</h2><p>代码演示：</p><pre><code>package com.myimooc.volatiledemo.my;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 程序主类
 * @author ZhangCheng on 2017-07-09
 *
 */
public class VolatileDemo {

    private int number = 0;

    public int getNumber(){
        return this.number;
    }

    public void increase(){
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        this.number++;
    }

    public static void main(String[] args) {
        final VolatileDemo volDemo = new VolatileDemo();
        for(int i = 0 ; i &lt; 500 ; i++){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    volDemo.increase();
                }
            }).start();
        }

        //如果还有子线程在运行，主线程就让出CPU资源，
        //直到所有的子线程都运行完了，主线程再继续往下执行
        while(Thread.activeCount() &gt; 1){
            Thread.yield();
        }

        System.out.println(&quot;number : &quot; + volDemo.getNumber());
    }

}
</code></pre><h2 id="4-3-volatile不能保证原子性（中）"><a href="#4-3-volatile不能保证原子性（中）" class="headerlink" title="4-3 volatile不能保证原子性（中）"></a>4-3 volatile不能保证原子性（中）</h2><p>程序分析</p><p>解决方案：保证number自增操作的原子性</p><pre><code>使用synchronized关键字
使用ReentrantLock（java.util.concurrent.locks包下）
使用AtomicInterger（java.util.concurrent.atomic包下）
</code></pre><h2 id="4-4-volatile不能保证原子性（下）"><a href="#4-4-volatile不能保证原子性（下）" class="headerlink" title="4-4 volatile不能保证原子性（下）"></a>4-4 volatile不能保证原子性（下）</h2><p>代码演示：</p><pre><code>package com.myimooc.volatiledemo.my;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * 程序主类
 * @author ZhangCheng on 2017-07-09
 *
 */
public class VolatileDemo {

    private int number = 0;
    private Lock lock = new ReentrantLock();

    public int getNumber(){
        return this.number;
    }

    public void increase(){
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // 方案一
        /*
        synchronized(this){
            this.number++;
        }
        */
        // 方案二
        lock.lock();// 获取锁
        try {
            this.number++;
        } finally {
            lock.unlock();// 释放锁
        }

    }

    public static void main(String[] args) {
        final VolatileDemo volDemo = new VolatileDemo();
        for(int i = 0 ; i &lt; 500 ; i++){
            new Thread(new Runnable() {
                @Override
                public void run() {
                    volDemo.increase();
                }
            }).start();
        }

        //如果还有子线程在运行，主线程就让出CPU资源，
        //直到所有的子线程都运行完了，主线程再继续往下执行
        while(Thread.activeCount() &gt; 1){
            Thread.yield();
        }

        System.out.println(&quot;number : &quot; + volDemo.getNumber());
    }

}
</code></pre><h2 id="4-5-volatile使用注意事项"><a href="#4-5-volatile使用注意事项" class="headerlink" title="4-5 volatile使用注意事项"></a>4-5 volatile使用注意事项</h2><p>volatile适用场合：要在多线程中安全的使用volatile变量，必须同时满足</p><pre><code>对变量的写入操作不依赖其当前值
    不满足：number++、count = count * 5等
    满足：boolean变量、记录温度变化的变量等
该变量没有包含在具有其他变量的不变式中
    不满足：不变式low &lt; up
</code></pre><h2 id="4-6-synchronized和volatile比较"><a href="#4-6-synchronized和volatile比较" class="headerlink" title="4-6 synchronized和volatile比较"></a>4-6 synchronized和volatile比较</h2><p>synchronized和volatile比较</p><pre><code>volatile不需要加锁，比synchronized更轻量级，不会阻塞线程
从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁
synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性
</code></pre><h1 id="第五章：课程总结"><a href="#第五章：课程总结" class="headerlink" title="第五章：课程总结"></a>第五章：课程总结</h1><h2 id="5-1-课程总结"><a href="#5-1-课程总结" class="headerlink" title="5-1 课程总结"></a>5-1 课程总结</h2><p>课程总结</p><pre><code>什么是内存可见性
Java内存模型（JMM）
实现可见性的方式：synchronized和volatile
    final也可以保证内存可见性
synchronized和volatile实现内存可见性的原理
synchronized实现可见性
    指令重排序
    as-if-serial语义
volatile实现可见性
    volatile能够保证可见性
    volatile不能保证原子性
    volatile使用注意事项
synchronized和volatile比较
    volatile比synchronized更轻量级
    volatile没有synchronized使用的广泛
</code></pre><p>问：即使没有保证可见性的措施，很多时候共享变量依然能够在主内存和工作内存见得到及时地更新？</p><p>答：一般只有在短时间内高并发的情况下才会出现变量得不到及时更新的情况，因为CPU在执行时会很快的刷新缓存，所以一般情况下很难看到这种情况。</p><p>对64位（long、double）变量的读写可能不是原子操作</p><pre><code>Java内存模型允许JVM将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的读写操作来进行
导致问题：有可能会出现读取到“半个变量”的情况
解决办法：加volatile关键字
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/netty固定长度解码器讲解.html" rel="next" title="netty 固定长度解码器讲解"><i class="fa fa-chevron-left"></i> netty 固定长度解码器讲解</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/java环境为何如此配置.html" rel="prev" title="Java环境为何如此配置？">Java环境为何如此配置？ <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#慕课网-《细说Java多线程之内存可见性》学习总结"><span class="nav-number">1.</span> <span class="nav-text">慕课网_《细说Java多线程之内存可见性》学习总结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章：可见性介绍"><span class="nav-number">2.</span> <span class="nav-text">第二章：可见性介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-可见性介绍"><span class="nav-number">2.1.</span> <span class="nav-text">2-1 可见性介绍</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章：synchronized实现可见性"><span class="nav-number">3.</span> <span class="nav-text">第三章：synchronized实现可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-synchronized实现可见性原理"><span class="nav-number">3.1.</span> <span class="nav-text">3-1 synchronized实现可见性原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-synchronized实现可见性（上）"><span class="nav-number">3.2.</span> <span class="nav-text">3-2 synchronized实现可见性（上）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-synchronized实现可见性（中）"><span class="nav-number">3.3.</span> <span class="nav-text">3-3 synchronized实现可见性（中）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-synchronized实现可见性（下）"><span class="nav-number">3.4.</span> <span class="nav-text">3-4 synchronized实现可见性（下）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第四章：volatile实现可见性"><span class="nav-number">4.</span> <span class="nav-text">第四章：volatile实现可见性</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-volatile能够保证可见性"><span class="nav-number">4.1.</span> <span class="nav-text">4-1 volatile能够保证可见性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-volatile不能保证原子性（上）"><span class="nav-number">4.2.</span> <span class="nav-text">4-2 volatile不能保证原子性（上）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-volatile不能保证原子性（中）"><span class="nav-number">4.3.</span> <span class="nav-text">4-3 volatile不能保证原子性（中）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-volatile不能保证原子性（下）"><span class="nav-number">4.4.</span> <span class="nav-text">4-4 volatile不能保证原子性（下）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-volatile使用注意事项"><span class="nav-number">4.5.</span> <span class="nav-text">4-5 volatile使用注意事项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-synchronized和volatile比较"><span class="nav-number">4.6.</span> <span class="nav-text">4-6 synchronized和volatile比较</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第五章：课程总结"><span class="nav-number">5.</span> <span class="nav-text">第五章：课程总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-课程总结"><span class="nav-number">5.1.</span> <span class="nav-text">5-1 课程总结</span></a></li></ol></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->