<!-- build time:Sat Oct 27 2018 21:00:18 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="生活就像海洋，只有意志坚强的人才能到达彼岸。已经很久没有发文章了呀，想必大家都挂念我了，哈哈。温故而知新，今天一起来复习一下spring mvc的内容吧。spring mvc简介与运行原理Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="Spring思维导图，让Spring不再难懂（mvc篇）"><meta property="og:url" content="http://www.jfox.info/2017/spring思维导图让spring不再难懂mvc篇.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="生活就像海洋，只有意志坚强的人才能到达彼岸。已经很久没有发文章了呀，想必大家都挂念我了，哈哈。温故而知新，今天一起来复习一下spring mvc的内容吧。spring mvc简介与运行原理Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2017/1355/2687192.png"><meta property="og:image" content="http://www.jfox.info/2017/1355/05725f5.png"><meta property="og:image" content="http://www.jfox.info/2017/1355/860bd85.png"><meta property="og:image" content="http://www.jfox.info/2017/1355/7eb9969.png"><meta property="og:image" content="http://www.jfox.info/2017/1355/0b38896.png"><meta property="og:image" content="http://www.jfox.info/2017/1355/46c8109.png"><meta property="og:image" content="http://www.jfox.info/2017/1355/4283c90.png"><meta property="og:image" content="http://www.jfox.info/2017/1355/b67a1ae.png"><meta property="og:image" content="http://www.jfox.info/2017/1355/29284b8.png"><meta property="og:updated_time" content="2018-10-27T12:29:39.340Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring思维导图，让Spring不再难懂（mvc篇）"><meta name="twitter:description" content="生活就像海洋，只有意志坚强的人才能到达彼岸。已经很久没有发文章了呀，想必大家都挂念我了，哈哈。温故而知新，今天一起来复习一下spring mvc的内容吧。spring mvc简介与运行原理Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还"><meta name="twitter:image" content="http://www.jfox.info/2017/1355/2687192.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/spring思维导图让spring不再难懂mvc篇.html"><title>Spring思维导图，让Spring不再难懂（mvc篇） | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/spring思维导图让spring不再难懂mvc篇.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Spring思维导图，让Spring不再难懂（mvc篇）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:57:35+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>生活就像海洋，只有意志坚强的人才能到达彼岸。</p><p>已经很久没有发文章了呀，想必大家都挂念我了，哈哈。</p><p>温故而知新，今天一起来复习一下spring mvc的内容吧。</p><p>spring mvc简介与运行原理</p><p>Spring的模型-视图-控制器（MVC）框架是围绕一个DispatcherServlet来设计的，这个Servlet会把请求分发给各个处理器，并支持可配置的处理器映射、视图渲染、本地化、时区与主题渲染等，甚至还能支持文件上传。<br><img src="/2017/1355/2687192.png" alt=""></p><p>原理.png</p><ul><li>(1) Http请求：客户端请求提交到DispatcherServlet。</li><li>(2) 寻找处理器：由DispatcherServlet控制器查询一个或多个HandlerMapping，找到处理请求的Controller。</li><li>(3) 调用处理器：DispatcherServlet将请求提交到Controller。</li><li>(4)(5)调用业务处理和返回结果：Controller调用业务逻辑处理后，返回ModelAndView。</li><li>(6)(7)处理视图映射并返回模型： DispatcherServlet查询一个或多个ViewResoler视图解析器，找到ModelAndView指定的视图。</li><li>(8) Http响应：视图负责将结果显示到客户端。</li></ul><p>主要注解<br><img src="/2017/1355/05725f5.png" alt=""></p><p>spring mvc注解.png</p><p>ContextLoaderListener</p><p><em>在讲ContextLoaderListener之前，首先来了解一下web.xml的作用。</em></p><ul><li><p>一个web中可以没有web.xml文件，也就是说，web.xml文件并不是web工程必须的。web.xml文件是用来初始化配置信息：比如Welcome页面、servlet、servlet-mapping、filter、listener、启动加载级别等。当你的web工程没用到这些时，你可以不用web.xml文件来配置你的Application。</p></li><li><p>当要启动某个web项目时，服务器软件或容器如（tomcat）会第一步加载项目中的web.xml文件，通过其中的各种配置来启动项目，只有其中配置的各项均无误时，项目才能正确启动。web.xml有多项标签，在其加载的过程中顺序依次为：context-param &gt;&gt; listener &gt;&gt; fileter &gt;&gt; servlet​。（同类多个节点以出现顺序依次加载）</p></li></ul><p><img src="/2017/1355/860bd85.png" alt=""></p><p>web.xml加载过程.png</p><p><em>而spring mvc启动过程大致分为两个过程：</em></p><ul><li>ContextLoaderListener初始化，实例化IoC容器，并将此容器实例注册到ServletContext中。</li><li>DispatcherServlet初始化。</li></ul><p><img src="/2017/1355/7eb9969.png" alt=""></p><p>web.xml配置.png</p><p>其中ContextLoaderListener监听器它实现了ServletContextListener这个接口，在web.xml配置这个监听器，启动容器时，就会默认执行它实现的方法。在ContextLoaderListener中关联了ContextLoader这个类，所以整个加载配置过程由ContextLoader来完成。</p><ul><li><p><em>ContextLoaderListener在web.xml中的配置</em></p><p><context-param></context-param></p><pre><code>&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
&lt;param-value&gt;/WEB-INF/applicationContext.xml&lt;/param-value&gt;
</code></pre><p></p><listener><br><listener-class>org.springframework.web.context.ContextLoaderListener</listener-class><br></listener></li></ul><p>ServletContextListener 接口有两个方法:contextInitialized,contextDestroyed</p><p>DispatcherServlet</p><p>Spring MVC框架，与其他很多web的MVC框架一样：请求驱动；所有设计都围绕着一个中央Servlet来展开，它负责把所有请求分发到控制器；同时提供其他web应用开发所需要的功能。不过Spring的中央处理器，DispatcherServlet，能做的比这更多。</p><p>下图展示了Spring Web MVC的DispatcherServlet处理请求的工作流。熟悉设计模式的朋友会发现，DispatcherServlet应用的其实就是一个“前端控制器”的设计模式（其他很多优秀的web框架也都使用了这个设计模式）。<br><img src="/2017/1355/0b38896.png" alt=""></p><p>spring mvc处理请求的流程.jpg</p><pre><code>&lt;!-- servlet定义 --&gt;
&lt;servlet&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
    &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;
    &lt;url-pattern&gt;/&lt;/url-pattern&gt;
&lt;/servlet-mapping&gt;
</code></pre><p>其中</p><ul><li>load-on-startup：表示启动容器时初始化该Servlet；</li><li>url-pattern：表示哪些请求交给Spring Web MVC处理， “/” 是用来定义默认servlet映射的。也可以如“*.html”表示拦截所有以html为扩展名的请求。</li></ul><p>在Spring MVC中，每个DispatcherServlet都持有一个自己的上下文对象WebApplicationContext，它又继承了根（root）WebApplicationContext对象中已经定义的所有bean。这些继承的bean可以在具体的Servlet实例中被重载，在每个Servlet实例中你也可以定义其scope下的新bean。</p><p>WebApplicationContext继承自ApplicationContext，它提供了一些web应用经常需要用到的特性。它与普通的ApplicationContext不同的地方在于，它支持主题的解析，并且知道它关联到的是哪个servlet（它持有一个该ServletContext的引用）<br><img src="/2017/1355/46c8109.png" alt=""></p><p>DispatcherServlet继承结构</p><p>spring mvc同时提供了很多特殊的注解，用于处理请求和渲染视图等。DispatcherServlet初始化的过程中会默认使用这些特殊bean进行配置。如果你想指定使用哪个特定的bean，你可以在web应用上下文WebApplicationContext中简单地配置它们。<br><img src="/2017/1355/4283c90.png" alt=""></p><p>特殊bean.png</p><p>其中，常用的ViewResolver的配置。以jsp作为视图为例</p><pre><code>&lt;!-- 对模型视图名称的解析,即在模型视图名称添加前后缀 --&gt;
&lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;
    &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot; /&gt;
    &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot; /&gt;
&lt;/bean&gt;
</code></pre><p>配置上传文件限制MultipartResolver</p><pre><code>&lt;!-- 上传限制 --&gt;
&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;
     &lt;!-- 上传文件大小限制为31M，31*1024*1024 --&gt;
     &lt;property name=&quot;maxUploadSize&quot; value=&quot;32505856&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>applicationContext.xml中的标签<br><img src="/2017/1355/b67a1ae.png" alt=""></p><p>applicationContext.xml配置文件标签.png</p><p>文件上传</p><p>前面说到DispatcherServlet中有个特殊的Bean叫MultipartResolver，可用于限制文件的上传大小等。当解析器MultipartResolver完成处理时，请求便会像其他请求一样被正常流程处理。</p><pre><code>&lt;form method=&quot;post&quot; action=&quot;/form&quot; enctype=&quot;multipart/form-data&quot;&gt;
     &lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt;
     &lt;input type=&quot;file&quot; name=&quot;file&quot;/&gt;
     &lt;input type=&quot;submit&quot;/&gt;
&lt;/form&gt;

@RequestMapping(path = &quot;/form&quot;, method = RequestMethod.POST)
 public String handleFormUpload(@RequestParam(&quot;name&quot;) String name, 
            @RequestParam(&quot;file&quot;) MultipartFile file) {

   if (!file.isEmpty()) {
          byte[] bytes = file.getBytes();
          // store the bytes somewhere
          return &quot;redirect:uploadSuccess&quot;;
    }
    return &quot;redirect:uploadFailure&quot;;
}
</code></pre><p>异常处理</p><p>先来说下常见的异常处理有几种方式，如下图：<br><img src="/2017/1355/29284b8.png" alt=""></p><p>异常处理方式.png</p><p>Spring的处理器异常解析器HandlerExceptionResolver接口的实现负责处理各类控制器执行过程中出现的异常。也是上面提到的，是DispatcherServlet中的特殊bean，可以自定义配置处理。</p><p>某种程度上讲，HandlerExceptionResolver与你在web应用描述符web.xml文件中能定义的异常映射（exception mapping）很相像，不过它比后者提供了更灵活的方式。比如它能提供异常被抛出时正在执行的是哪个处理器这样的信息。</p><ul><li><p><em>HandlerExceptionResolver 提供resolveException接口</em></p><p>public interface HandlerExceptionResolver {</p><pre><code>ModelAndView resolveException(  
        HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex);  
</code></pre><p>}</p></li><li><p><em>在BaseController中使用 @ExceptionHandler注解处理异常</em></p><pre><code>@ExceptionHandler(Exception.class)
public Object exceptionHandler(Exception ex, HttpServletResponse response, 
          HttpServletRequest request) throws IOException {
    String url = &quot;&quot;;
    String msg = ex.getMessage();
    Object resultModel = null;
    try {
        if (ex.getClass() == HttpRequestMethodNotSupportedException.class) {
            url = &quot;admin/common/500&quot;;
            System.out.println(&quot;--------毛有找到对应方法---------&quot;);
        } else if (ex.getClass() == ParameterException.class) {//自定义的异常

        } else if (ex.getClass() == UnauthorizedException.class) {
            url = &quot;admin/common/unauth&quot;;
            System.out.println(&quot;--------毛有权限---------&quot;);
        }

        String header = req.getHeader(&quot;X-Requested-With&quot;);
        boolean isAjax = &quot;XMLHttpRequest&quot;.equalsIgnoreCase(header);
        String method = req.getMethod();
        boolean isPost = &quot;POST&quot;.equalsIgnoreCase(method);

        if (isAjax || isPost) {
            return Message.error(msg);
        } else {
            ModelAndView view = new ModelAndView(url);
            view.addObject(&quot;error&quot;, msg);
            view.addObject(&quot;class&quot;, ex.getClass());
            view.addObject(&quot;method&quot;, request.getRequestURI());
            return view;
        }
    } catch (Exception exception) {
        logger.error(exception.getMessage(), exception);
        return resultModel;
    } finally {
        logger.error(msg, ex);
        ex.printStackTrace();
    }
}
</code></pre><p><error-page></error-page></p><pre><code>&lt;error-code&gt;403&lt;/error-code&gt;
&lt;location&gt;/403.html&lt;/location&gt;
</code></pre><p><br><error-page></error-page></p><pre><code>&lt;error-code&gt;404&lt;/error-code&gt;
&lt;location&gt;/404.html&lt;/location&gt;
</code></pre><p></p><p><error-page></error-page></p><pre><code>&lt;error-code&gt;500&lt;/error-code&gt; 
&lt;location&gt;/500.html&lt;/location&gt; 
</code></pre><p></p><p><error-page></error-page></p><pre><code>&lt;exception-type&gt;java.lang.Exception&lt;/exception-type&gt; 
&lt;location&gt;/500.jsp&lt;/location&gt; 
</code></pre><p></p><p><error-page></error-page></p><pre><code>&lt;exception-type&gt;java.lang.Throwable&lt;/exception-type&gt; 
&lt;location&gt;/500.jsp&lt;/location&gt; 
</code></pre><p></p></li><li><p>来一个问题：HandlerExceptionResolver和web.xml中配置的error-page会有冲突吗？</p></li></ul><p><em>解答</em>：如果resolveException返回了ModelAndView，会优先根据返回值中的页面来显示。不过，resolveException可以返回null，此时则展示web.xml中的error-page的500状态码配置的页面。<br>当web.xml中有相应的error-page配置，则可以在实现resolveException方法时返回null。<br>API文档中对返回值的解释：<br><strong>return a corresponding ModelAndView to forward to, or null for default processing.</strong></p><p>写在最后</p><p>下篇文章将会写Spring aop的内容，同样以思维导图的方式编写。可视化学习，让java不再难懂。</p><p>关注我的简书吧，与我共同学习。</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/testingspringbootwithtestng附录imockobjects.html" rel="next" title="Testing Spring Boot with TestNG – 附录I Mock Objects"><i class="fa fa-chevron-left"></i> Testing Spring Boot with TestNG – 附录I Mock Objects</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/十遗补缺javaarraylist的不当使用导致的concurrentmodificationexception问题.html" rel="prev" title="【十遗补缺】java ArrayList的不当使用导致的ConcurrentModificationException问题">【十遗补缺】java ArrayList的不当使用导致的ConcurrentModificationException问题 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->