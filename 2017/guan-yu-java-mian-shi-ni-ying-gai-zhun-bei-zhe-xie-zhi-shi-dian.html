<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>关于Java面试，你应该准备这些知识点 | Java面试</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="关于Java面试，你应该准备这些知识点" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="原文出处： 占小狼 马老师说过，员工的离职原因很多，只有两点最真实： 钱，没给到位 心，受委屈了 当然，我是想换个平台，换个方向，想清楚为什么要跳槽，如果真的要跳槽，想要拿到一个理想的offer，除了运气，基本功也要足够的扎实，希望下面的面试经验能给你们能够提供一些帮助。 项目经验 面试官在一开始会让你进行自我介绍，主要是想让你介绍一下自己做过的一些项目，看看你对这些项目的了解程度，因为很多人简历上写的项目并非都是从头到尾都参与的，有些只是参与并实现了其中的一些模块而已，或是接手维护别人的项目，所以在你简历上所写的和面试过程中所说的项目经验，你自己必须能够了解来龙去脉，因为面试官肯定会根据你的项目描述，对项目中的实现原理，或为什么要这样实现进行提问，这时不至于木讷住而不知如何作答，如此局面只会大大降低面试分。 场景对话： 面试官：（拿着简历）讲讲你最近做的这个项目 我：&amp;……%￥#*&amp;￥@%￥！，说了一大通（不知道面试官听进去多少，面试官会挑他会的进行提问） 面试官：你说这个项目中用到了netty，能大概讲讲netty的线程模型么？ 我：（幸好我看过netty的源码）netty通过Reactor模型基于多路复用器接收并处理用户请求（能讲就多讲一点），内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件（通过口述加画图的方式，把请求的执行过程大概描述了一遍，时间有限，也不可能把所有的细节都说完，挑重点讲，挑记忆深刻的讲） 面试官：嗯，理解的还挺深入的…那你在做这个项目时有没有遇到什么困难，或者是觉得有挑战的地方？ 我：（这时面试官想让你自己出题自己回答了，所以一定要回答，不回答就突显不出你这个项目了，要是这个问题没有准备过，只能临时发挥了，当然我就是属于临时发挥的）稍微想一下，因为之前确实碰到了这个问题，当时做这个项目时，对netty的不过熟悉，把请求的业务逻辑放在work线程池的线程中进行处理，进行压测的时候，发现qps总是上不去，后来看了源码之后才发现，由于业务逻辑的处理比较耗时，完全占用了work线程池的资源，导致新的请求一直处于等待状态。 面试官：那最后是如何解决的？ 我：最后把处理业务的逻辑封装成一个task提交给一个新建的业务线程池中执行，执行完之后由work线程池执行请求的write事件。 面试官：好的，你知道nio中selector可能触发bug么？ 我：嗯，对的，selector的select方法，因为底层的epoll函数可能会发生空转，从而导致cpu100%。 面试官：那如何解决该问题？ 我：这个问题在netty已经解决了，通过&amp;^%&amp;$^（把netty的解决方案说一遍） 面试官：嗯，对了，你们这个项目有给自己定指标么？ 我：有的，&amp;&amp;…………￥￥##@，把自己项目的指标说了一通，如何进行AB实验，如何迭代优化指标 面试官：嗯，好的 ，项目的问题先到这里，我们来考察一下java的基本点吧。 如上只是本人所做的一个项目，当然了，具体项目具体分析，也不是每个面试官问的点都一样，如果面试官不懂netty，自然会挑别的问题进行提问，不过你也可以尝试着把问题往自己熟悉的方向去靠。 面试知识点 1、线程池 线程池的实现原理，这个知识点真的很重要，几乎每次面试都会被问到，一般的提问方式有如下几种： 1、“讲讲线程池的实现原理” 2、“线程池中的coreNum和maxNum有什么不同” 3、“在不同的业务场景中，线程池参数如何设置” 场景对话： 面试官：平时线程池用的多么？ 我：嗯，我的*项目中就用到了 面试官：那好，你讲讲线程池的实现原理 我：（还好我之前看过源码，但是时间久远有点模糊了），能给我笔和纸么，我画图分析给你看看，&amp;&amp;￥&amp;假设初始化一个线程池，核心线程数是5，最大线程数是10@@@ 面试官：嗯，好的，你继续… 我：在纸上画了正方形，这个代表一个线程池，初始化的时候，里面是没有线程的 面试官：嗯，好的，你继续… 我：又画了一个细长的长方形，这个代表阻塞队列，一开始里面也是没有任务的 面试官：嗯，好的，你继续… 我：当来了一个任务时，在正方形中画了一个小圆圈，代表初始化了一个线程，如果再来一个任务，就再画一个圆圈，表示再初始化了一个线程，连续画了5个圆圈之后，如果第6个任务过来了… 面试官：嗯，好的，你继续… 我：这时会把第6个任务放到阻塞队列中.. 面试官：嗯，然后呢？ 我：现在线程池中不是有5个线程了么，如果其中一个线程空闲了，就会从阻塞队列中获取第6个任务，进行执行.. 面试官：嗯，对的，那如果任务产生的速度比消费的速度快呢？ 我：如果线程池的5个线程都在running状态，那么任务就先保存在阻塞队列中 面试官：如果队列满了，怎么办？ 我：如果队列满了，我们不是设置了最大线程数是10么，而线程池中只有5个线程，这时会新建一个线程去执行不能保存到阻塞队列的任务，然后我又在正方形中画了5个圆圈。 面试官：那如果线程池中的线程数达到10个了，阻塞队列也满了，怎么办？ 我：这种情况通过自定义reject函数去处理这里任务了，舒了一口去，以为问完了… 面试官：好的，那如果运行一段时间之后，阻塞队列中的任务也执行完了，线程池中的线程会怎么样？ 我：…这个好像超过核心线程数的线程会在空闲一段时间内自动回收…因为有点不记得这个逻辑了，回答的有点虚… 面试官：好的，那这种情况在什么场景下会发生? 我：（有时候真是笨啊，很多东西都知道，但是在面试的时候一紧张，全忘记）这个…那个…我好像没有遇到过这样的情况 面试官：嗯，好的，你回去之后再好好想想 我：…….. 我居然忘记了秒杀这个场景 线程池分析的文章： 深入分析java线程池的实现原理 2、锁的实现 在关于锁的面试过程中，一般主要问Synchronized和ReentrantLock的实现原理，更有甚者会问读写锁。 场景对话： 面试官：都了解Java中的什么锁？ 我：比如Synchronized和ReentrantLock…读写锁用的不多，就没研究了（我就怕被问读写锁，因为一直没去看） 面试官：那好，你先说说Synchronized的实现原理吧 我：嗯，Synchronized是JVM实现的一种锁，其中锁的获取和释放分别是monitorenter和monitorexit指令，该锁在实现上分为了偏向锁、轻量级锁和重量级锁，其中偏向锁在1.6是默认开启的，轻量级锁在多线程竞争的情况下会膨胀成重量级锁，有关锁的数据都保存在对象头中…&amp;&amp;@@#，（嗯，说了一大堆，面试官也没打断我） 面试官：哦，嗯，理解的还挺透彻，那你说说ReentrantLock的实现吧… 我：ReentrantLock是基于AQS实现的 面试官：什么是AQS？ 我：在AQS内部会保存一个状态变量state，通过CAS修改该变量的值，修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒&amp;&amp;&amp;$$（又说了一堆） 面试官：能说说CAS的实现原理么？ 我：CAS是通过unsafe类的compareAndSwap方法实现的（心里得意的一笑） 面试官：哦，好的，那你知道这个方法的参数的含义的么？ 我：（这是在逼我啊…努力的回想，因为我真的看过啊）我想想啊，这个方法看的时间有点久远了，第一个参数是要修改的对象，第二个参数是对象中要修改变量的偏移量，第三个参数是修改之前的值，第四个参数是预想修改后的值….（说出来之后都有点佩服自己，这个都记得，不过面试官好像还是不肯放过我…） 面试官：嗯，对的，那你知道操作系统级别是如何实现的么？ 我：（我去你大爷…）我只记得X86中有一个cmp开头的指令，具体的我忘记了… 面试官：嗯，好，你知道CAS指令有什么缺点么 我：哦，CAS的缺点是存在ABA问题 面试官：怎么讲？ 我：就是一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。 面试官：那怎么解决？ 我：（有完没完了啊…我的心里是崩溃的）针对这种情况，java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。 面试官：嗯，好的，这个问题到此为止，我们再看看别的 我：….我能喝口水么 关于锁分析的文章，希望对大家有用： 深入浅出java同步器AQS java中的CAS 深入浅出synchronized 深入浅出ReentrantLock java中的Unsafe java volatile关键字解惑 深入分析Object.wait/notify实现机制 深入分析synchronized的JVM实现 3、ConcurrentHashMap 当考察数据结构时，面试官一开始会问HashMap的实现原理，当你说出HashMap并非线程安全之后，会让你自己引出ConcurrentHashMap，接着就可能开始如下的对话。 场景对话： 面试官：谈谈ConcurrentHashMap实现原理 我：@＃¥@@基于分段锁的％％¥＃@＃¥，但是1.8之后改变实现方式了 面试官：1.8啥方式 我：把1.8的实现原理说了一通，其中提到了红黑树… 面试官：能讲下红黑树的概念吗 我：红黑树是一种二叉树，并且是平衡……％……¥……， 面试官：能讲下红黑树的。。。。。 我：打住，别问了，红黑树我只知道他是二叉树，比其他树多一个属性，其他的我都不知道 面试官：好的，那换个，你知道它的size方法是如何实现的么？ 我：size方法？是想要得到Map中的元素个数么？ 面试官：对的…. 我：我记得好像size方法返回是不准确的，平时也不会用到这个方法… 面试官：如果你觉得size方法返回值不准确，那如果让你自己实现，你觉得应该怎么实现呢？ 我：…@＃¥@@…两眼一黑 我：等等，让我想想…..应该可以用AtomicInteger变量进行记录…嗯，对的，每次插入或删除的时候，操作这个变量，我得意的一笑… 面试官：哦，是么，那如果我觉得这个AtomicInteger这个变量性能不好，还能再优化么？ 我：懵逼脸…（当时居然把volitile变量给忘记了）…好像没有了，我想不出来了… 面试官：哦，那回头你再看看源码吧，jdk中已经实现了… 我：哦，是么…. 面试官：那今天的面试到此结束，我们后面会通知你。 我：……………… 关于ConcurrentHashMap，本人也写过不少的分析文章，希望对大家有用： 深入浅出ConcurrentHashMap（1.8） 谈谈ConcurrentHashMap1.7和1.8的不同实现 ConcurrentHashMap的红黑树实现分析 深入分析ConcurrentHashMap1.8的扩容实现" />
<meta property="og:description" content="原文出处： 占小狼 马老师说过，员工的离职原因很多，只有两点最真实： 钱，没给到位 心，受委屈了 当然，我是想换个平台，换个方向，想清楚为什么要跳槽，如果真的要跳槽，想要拿到一个理想的offer，除了运气，基本功也要足够的扎实，希望下面的面试经验能给你们能够提供一些帮助。 项目经验 面试官在一开始会让你进行自我介绍，主要是想让你介绍一下自己做过的一些项目，看看你对这些项目的了解程度，因为很多人简历上写的项目并非都是从头到尾都参与的，有些只是参与并实现了其中的一些模块而已，或是接手维护别人的项目，所以在你简历上所写的和面试过程中所说的项目经验，你自己必须能够了解来龙去脉，因为面试官肯定会根据你的项目描述，对项目中的实现原理，或为什么要这样实现进行提问，这时不至于木讷住而不知如何作答，如此局面只会大大降低面试分。 场景对话： 面试官：（拿着简历）讲讲你最近做的这个项目 我：&amp;……%￥#*&amp;￥@%￥！，说了一大通（不知道面试官听进去多少，面试官会挑他会的进行提问） 面试官：你说这个项目中用到了netty，能大概讲讲netty的线程模型么？ 我：（幸好我看过netty的源码）netty通过Reactor模型基于多路复用器接收并处理用户请求（能讲就多讲一点），内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件（通过口述加画图的方式，把请求的执行过程大概描述了一遍，时间有限，也不可能把所有的细节都说完，挑重点讲，挑记忆深刻的讲） 面试官：嗯，理解的还挺深入的…那你在做这个项目时有没有遇到什么困难，或者是觉得有挑战的地方？ 我：（这时面试官想让你自己出题自己回答了，所以一定要回答，不回答就突显不出你这个项目了，要是这个问题没有准备过，只能临时发挥了，当然我就是属于临时发挥的）稍微想一下，因为之前确实碰到了这个问题，当时做这个项目时，对netty的不过熟悉，把请求的业务逻辑放在work线程池的线程中进行处理，进行压测的时候，发现qps总是上不去，后来看了源码之后才发现，由于业务逻辑的处理比较耗时，完全占用了work线程池的资源，导致新的请求一直处于等待状态。 面试官：那最后是如何解决的？ 我：最后把处理业务的逻辑封装成一个task提交给一个新建的业务线程池中执行，执行完之后由work线程池执行请求的write事件。 面试官：好的，你知道nio中selector可能触发bug么？ 我：嗯，对的，selector的select方法，因为底层的epoll函数可能会发生空转，从而导致cpu100%。 面试官：那如何解决该问题？ 我：这个问题在netty已经解决了，通过&amp;^%&amp;$^（把netty的解决方案说一遍） 面试官：嗯，对了，你们这个项目有给自己定指标么？ 我：有的，&amp;&amp;…………￥￥##@，把自己项目的指标说了一通，如何进行AB实验，如何迭代优化指标 面试官：嗯，好的 ，项目的问题先到这里，我们来考察一下java的基本点吧。 如上只是本人所做的一个项目，当然了，具体项目具体分析，也不是每个面试官问的点都一样，如果面试官不懂netty，自然会挑别的问题进行提问，不过你也可以尝试着把问题往自己熟悉的方向去靠。 面试知识点 1、线程池 线程池的实现原理，这个知识点真的很重要，几乎每次面试都会被问到，一般的提问方式有如下几种： 1、“讲讲线程池的实现原理” 2、“线程池中的coreNum和maxNum有什么不同” 3、“在不同的业务场景中，线程池参数如何设置” 场景对话： 面试官：平时线程池用的多么？ 我：嗯，我的*项目中就用到了 面试官：那好，你讲讲线程池的实现原理 我：（还好我之前看过源码，但是时间久远有点模糊了），能给我笔和纸么，我画图分析给你看看，&amp;&amp;￥&amp;假设初始化一个线程池，核心线程数是5，最大线程数是10@@@ 面试官：嗯，好的，你继续… 我：在纸上画了正方形，这个代表一个线程池，初始化的时候，里面是没有线程的 面试官：嗯，好的，你继续… 我：又画了一个细长的长方形，这个代表阻塞队列，一开始里面也是没有任务的 面试官：嗯，好的，你继续… 我：当来了一个任务时，在正方形中画了一个小圆圈，代表初始化了一个线程，如果再来一个任务，就再画一个圆圈，表示再初始化了一个线程，连续画了5个圆圈之后，如果第6个任务过来了… 面试官：嗯，好的，你继续… 我：这时会把第6个任务放到阻塞队列中.. 面试官：嗯，然后呢？ 我：现在线程池中不是有5个线程了么，如果其中一个线程空闲了，就会从阻塞队列中获取第6个任务，进行执行.. 面试官：嗯，对的，那如果任务产生的速度比消费的速度快呢？ 我：如果线程池的5个线程都在running状态，那么任务就先保存在阻塞队列中 面试官：如果队列满了，怎么办？ 我：如果队列满了，我们不是设置了最大线程数是10么，而线程池中只有5个线程，这时会新建一个线程去执行不能保存到阻塞队列的任务，然后我又在正方形中画了5个圆圈。 面试官：那如果线程池中的线程数达到10个了，阻塞队列也满了，怎么办？ 我：这种情况通过自定义reject函数去处理这里任务了，舒了一口去，以为问完了… 面试官：好的，那如果运行一段时间之后，阻塞队列中的任务也执行完了，线程池中的线程会怎么样？ 我：…这个好像超过核心线程数的线程会在空闲一段时间内自动回收…因为有点不记得这个逻辑了，回答的有点虚… 面试官：好的，那这种情况在什么场景下会发生? 我：（有时候真是笨啊，很多东西都知道，但是在面试的时候一紧张，全忘记）这个…那个…我好像没有遇到过这样的情况 面试官：嗯，好的，你回去之后再好好想想 我：…….. 我居然忘记了秒杀这个场景 线程池分析的文章： 深入分析java线程池的实现原理 2、锁的实现 在关于锁的面试过程中，一般主要问Synchronized和ReentrantLock的实现原理，更有甚者会问读写锁。 场景对话： 面试官：都了解Java中的什么锁？ 我：比如Synchronized和ReentrantLock…读写锁用的不多，就没研究了（我就怕被问读写锁，因为一直没去看） 面试官：那好，你先说说Synchronized的实现原理吧 我：嗯，Synchronized是JVM实现的一种锁，其中锁的获取和释放分别是monitorenter和monitorexit指令，该锁在实现上分为了偏向锁、轻量级锁和重量级锁，其中偏向锁在1.6是默认开启的，轻量级锁在多线程竞争的情况下会膨胀成重量级锁，有关锁的数据都保存在对象头中…&amp;&amp;@@#，（嗯，说了一大堆，面试官也没打断我） 面试官：哦，嗯，理解的还挺透彻，那你说说ReentrantLock的实现吧… 我：ReentrantLock是基于AQS实现的 面试官：什么是AQS？ 我：在AQS内部会保存一个状态变量state，通过CAS修改该变量的值，修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒&amp;&amp;&amp;$$（又说了一堆） 面试官：能说说CAS的实现原理么？ 我：CAS是通过unsafe类的compareAndSwap方法实现的（心里得意的一笑） 面试官：哦，好的，那你知道这个方法的参数的含义的么？ 我：（这是在逼我啊…努力的回想，因为我真的看过啊）我想想啊，这个方法看的时间有点久远了，第一个参数是要修改的对象，第二个参数是对象中要修改变量的偏移量，第三个参数是修改之前的值，第四个参数是预想修改后的值….（说出来之后都有点佩服自己，这个都记得，不过面试官好像还是不肯放过我…） 面试官：嗯，对的，那你知道操作系统级别是如何实现的么？ 我：（我去你大爷…）我只记得X86中有一个cmp开头的指令，具体的我忘记了… 面试官：嗯，好，你知道CAS指令有什么缺点么 我：哦，CAS的缺点是存在ABA问题 面试官：怎么讲？ 我：就是一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。 面试官：那怎么解决？ 我：（有完没完了啊…我的心里是崩溃的）针对这种情况，java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。 面试官：嗯，好的，这个问题到此为止，我们再看看别的 我：….我能喝口水么 关于锁分析的文章，希望对大家有用： 深入浅出java同步器AQS java中的CAS 深入浅出synchronized 深入浅出ReentrantLock java中的Unsafe java volatile关键字解惑 深入分析Object.wait/notify实现机制 深入分析synchronized的JVM实现 3、ConcurrentHashMap 当考察数据结构时，面试官一开始会问HashMap的实现原理，当你说出HashMap并非线程安全之后，会让你自己引出ConcurrentHashMap，接着就可能开始如下的对话。 场景对话： 面试官：谈谈ConcurrentHashMap实现原理 我：@＃¥@@基于分段锁的％％¥＃@＃¥，但是1.8之后改变实现方式了 面试官：1.8啥方式 我：把1.8的实现原理说了一通，其中提到了红黑树… 面试官：能讲下红黑树的概念吗 我：红黑树是一种二叉树，并且是平衡……％……¥……， 面试官：能讲下红黑树的。。。。。 我：打住，别问了，红黑树我只知道他是二叉树，比其他树多一个属性，其他的我都不知道 面试官：好的，那换个，你知道它的size方法是如何实现的么？ 我：size方法？是想要得到Map中的元素个数么？ 面试官：对的…. 我：我记得好像size方法返回是不准确的，平时也不会用到这个方法… 面试官：如果你觉得size方法返回值不准确，那如果让你自己实现，你觉得应该怎么实现呢？ 我：…@＃¥@@…两眼一黑 我：等等，让我想想…..应该可以用AtomicInteger变量进行记录…嗯，对的，每次插入或删除的时候，操作这个变量，我得意的一笑… 面试官：哦，是么，那如果我觉得这个AtomicInteger这个变量性能不好，还能再优化么？ 我：懵逼脸…（当时居然把volitile变量给忘记了）…好像没有了，我想不出来了… 面试官：哦，那回头你再看看源码吧，jdk中已经实现了… 我：哦，是么…. 面试官：那今天的面试到此结束，我们后面会通知你。 我：……………… 关于ConcurrentHashMap，本人也写过不少的分析文章，希望对大家有用： 深入浅出ConcurrentHashMap（1.8） 谈谈ConcurrentHashMap1.7和1.8的不同实现 ConcurrentHashMap的红黑树实现分析 深入分析ConcurrentHashMap1.8的扩容实现" />
<link rel="canonical" href="http://www.jfox.info/2017/guan-yu-java-mian-shi-ni-ying-gai-zhun-bei-zhe-xie-zhi-shi-dian.html" />
<meta property="og:url" content="http://www.jfox.info/2017/guan-yu-java-mian-shi-ni-ying-gai-zhun-bei-zhe-xie-zhi-shi-dian.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T15:48:41+00:00" />
<script type="application/ld+json">
{"description":"原文出处： 占小狼 马老师说过，员工的离职原因很多，只有两点最真实： 钱，没给到位 心，受委屈了 当然，我是想换个平台，换个方向，想清楚为什么要跳槽，如果真的要跳槽，想要拿到一个理想的offer，除了运气，基本功也要足够的扎实，希望下面的面试经验能给你们能够提供一些帮助。 项目经验 面试官在一开始会让你进行自我介绍，主要是想让你介绍一下自己做过的一些项目，看看你对这些项目的了解程度，因为很多人简历上写的项目并非都是从头到尾都参与的，有些只是参与并实现了其中的一些模块而已，或是接手维护别人的项目，所以在你简历上所写的和面试过程中所说的项目经验，你自己必须能够了解来龙去脉，因为面试官肯定会根据你的项目描述，对项目中的实现原理，或为什么要这样实现进行提问，这时不至于木讷住而不知如何作答，如此局面只会大大降低面试分。 场景对话： 面试官：（拿着简历）讲讲你最近做的这个项目 我：&amp;……%￥#*&amp;￥@%￥！，说了一大通（不知道面试官听进去多少，面试官会挑他会的进行提问） 面试官：你说这个项目中用到了netty，能大概讲讲netty的线程模型么？ 我：（幸好我看过netty的源码）netty通过Reactor模型基于多路复用器接收并处理用户请求（能讲就多讲一点），内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件（通过口述加画图的方式，把请求的执行过程大概描述了一遍，时间有限，也不可能把所有的细节都说完，挑重点讲，挑记忆深刻的讲） 面试官：嗯，理解的还挺深入的…那你在做这个项目时有没有遇到什么困难，或者是觉得有挑战的地方？ 我：（这时面试官想让你自己出题自己回答了，所以一定要回答，不回答就突显不出你这个项目了，要是这个问题没有准备过，只能临时发挥了，当然我就是属于临时发挥的）稍微想一下，因为之前确实碰到了这个问题，当时做这个项目时，对netty的不过熟悉，把请求的业务逻辑放在work线程池的线程中进行处理，进行压测的时候，发现qps总是上不去，后来看了源码之后才发现，由于业务逻辑的处理比较耗时，完全占用了work线程池的资源，导致新的请求一直处于等待状态。 面试官：那最后是如何解决的？ 我：最后把处理业务的逻辑封装成一个task提交给一个新建的业务线程池中执行，执行完之后由work线程池执行请求的write事件。 面试官：好的，你知道nio中selector可能触发bug么？ 我：嗯，对的，selector的select方法，因为底层的epoll函数可能会发生空转，从而导致cpu100%。 面试官：那如何解决该问题？ 我：这个问题在netty已经解决了，通过&amp;^%&amp;$^（把netty的解决方案说一遍） 面试官：嗯，对了，你们这个项目有给自己定指标么？ 我：有的，&amp;&amp;…………￥￥##@，把自己项目的指标说了一通，如何进行AB实验，如何迭代优化指标 面试官：嗯，好的 ，项目的问题先到这里，我们来考察一下java的基本点吧。 如上只是本人所做的一个项目，当然了，具体项目具体分析，也不是每个面试官问的点都一样，如果面试官不懂netty，自然会挑别的问题进行提问，不过你也可以尝试着把问题往自己熟悉的方向去靠。 面试知识点 1、线程池 线程池的实现原理，这个知识点真的很重要，几乎每次面试都会被问到，一般的提问方式有如下几种： 1、“讲讲线程池的实现原理” 2、“线程池中的coreNum和maxNum有什么不同” 3、“在不同的业务场景中，线程池参数如何设置” 场景对话： 面试官：平时线程池用的多么？ 我：嗯，我的*项目中就用到了 面试官：那好，你讲讲线程池的实现原理 我：（还好我之前看过源码，但是时间久远有点模糊了），能给我笔和纸么，我画图分析给你看看，&amp;&amp;￥&amp;假设初始化一个线程池，核心线程数是5，最大线程数是10@@@ 面试官：嗯，好的，你继续… 我：在纸上画了正方形，这个代表一个线程池，初始化的时候，里面是没有线程的 面试官：嗯，好的，你继续… 我：又画了一个细长的长方形，这个代表阻塞队列，一开始里面也是没有任务的 面试官：嗯，好的，你继续… 我：当来了一个任务时，在正方形中画了一个小圆圈，代表初始化了一个线程，如果再来一个任务，就再画一个圆圈，表示再初始化了一个线程，连续画了5个圆圈之后，如果第6个任务过来了… 面试官：嗯，好的，你继续… 我：这时会把第6个任务放到阻塞队列中.. 面试官：嗯，然后呢？ 我：现在线程池中不是有5个线程了么，如果其中一个线程空闲了，就会从阻塞队列中获取第6个任务，进行执行.. 面试官：嗯，对的，那如果任务产生的速度比消费的速度快呢？ 我：如果线程池的5个线程都在running状态，那么任务就先保存在阻塞队列中 面试官：如果队列满了，怎么办？ 我：如果队列满了，我们不是设置了最大线程数是10么，而线程池中只有5个线程，这时会新建一个线程去执行不能保存到阻塞队列的任务，然后我又在正方形中画了5个圆圈。 面试官：那如果线程池中的线程数达到10个了，阻塞队列也满了，怎么办？ 我：这种情况通过自定义reject函数去处理这里任务了，舒了一口去，以为问完了… 面试官：好的，那如果运行一段时间之后，阻塞队列中的任务也执行完了，线程池中的线程会怎么样？ 我：…这个好像超过核心线程数的线程会在空闲一段时间内自动回收…因为有点不记得这个逻辑了，回答的有点虚… 面试官：好的，那这种情况在什么场景下会发生? 我：（有时候真是笨啊，很多东西都知道，但是在面试的时候一紧张，全忘记）这个…那个…我好像没有遇到过这样的情况 面试官：嗯，好的，你回去之后再好好想想 我：…….. 我居然忘记了秒杀这个场景 线程池分析的文章： 深入分析java线程池的实现原理 2、锁的实现 在关于锁的面试过程中，一般主要问Synchronized和ReentrantLock的实现原理，更有甚者会问读写锁。 场景对话： 面试官：都了解Java中的什么锁？ 我：比如Synchronized和ReentrantLock…读写锁用的不多，就没研究了（我就怕被问读写锁，因为一直没去看） 面试官：那好，你先说说Synchronized的实现原理吧 我：嗯，Synchronized是JVM实现的一种锁，其中锁的获取和释放分别是monitorenter和monitorexit指令，该锁在实现上分为了偏向锁、轻量级锁和重量级锁，其中偏向锁在1.6是默认开启的，轻量级锁在多线程竞争的情况下会膨胀成重量级锁，有关锁的数据都保存在对象头中…&amp;&amp;@@#，（嗯，说了一大堆，面试官也没打断我） 面试官：哦，嗯，理解的还挺透彻，那你说说ReentrantLock的实现吧… 我：ReentrantLock是基于AQS实现的 面试官：什么是AQS？ 我：在AQS内部会保存一个状态变量state，通过CAS修改该变量的值，修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒&amp;&amp;&amp;$$（又说了一堆） 面试官：能说说CAS的实现原理么？ 我：CAS是通过unsafe类的compareAndSwap方法实现的（心里得意的一笑） 面试官：哦，好的，那你知道这个方法的参数的含义的么？ 我：（这是在逼我啊…努力的回想，因为我真的看过啊）我想想啊，这个方法看的时间有点久远了，第一个参数是要修改的对象，第二个参数是对象中要修改变量的偏移量，第三个参数是修改之前的值，第四个参数是预想修改后的值….（说出来之后都有点佩服自己，这个都记得，不过面试官好像还是不肯放过我…） 面试官：嗯，对的，那你知道操作系统级别是如何实现的么？ 我：（我去你大爷…）我只记得X86中有一个cmp开头的指令，具体的我忘记了… 面试官：嗯，好，你知道CAS指令有什么缺点么 我：哦，CAS的缺点是存在ABA问题 面试官：怎么讲？ 我：就是一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。 面试官：那怎么解决？ 我：（有完没完了啊…我的心里是崩溃的）针对这种情况，java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。 面试官：嗯，好的，这个问题到此为止，我们再看看别的 我：….我能喝口水么 关于锁分析的文章，希望对大家有用： 深入浅出java同步器AQS java中的CAS 深入浅出synchronized 深入浅出ReentrantLock java中的Unsafe java volatile关键字解惑 深入分析Object.wait/notify实现机制 深入分析synchronized的JVM实现 3、ConcurrentHashMap 当考察数据结构时，面试官一开始会问HashMap的实现原理，当你说出HashMap并非线程安全之后，会让你自己引出ConcurrentHashMap，接着就可能开始如下的对话。 场景对话： 面试官：谈谈ConcurrentHashMap实现原理 我：@＃¥@@基于分段锁的％％¥＃@＃¥，但是1.8之后改变实现方式了 面试官：1.8啥方式 我：把1.8的实现原理说了一通，其中提到了红黑树… 面试官：能讲下红黑树的概念吗 我：红黑树是一种二叉树，并且是平衡……％……¥……， 面试官：能讲下红黑树的。。。。。 我：打住，别问了，红黑树我只知道他是二叉树，比其他树多一个属性，其他的我都不知道 面试官：好的，那换个，你知道它的size方法是如何实现的么？ 我：size方法？是想要得到Map中的元素个数么？ 面试官：对的…. 我：我记得好像size方法返回是不准确的，平时也不会用到这个方法… 面试官：如果你觉得size方法返回值不准确，那如果让你自己实现，你觉得应该怎么实现呢？ 我：…@＃¥@@…两眼一黑 我：等等，让我想想…..应该可以用AtomicInteger变量进行记录…嗯，对的，每次插入或删除的时候，操作这个变量，我得意的一笑… 面试官：哦，是么，那如果我觉得这个AtomicInteger这个变量性能不好，还能再优化么？ 我：懵逼脸…（当时居然把volitile变量给忘记了）…好像没有了，我想不出来了… 面试官：哦，那回头你再看看源码吧，jdk中已经实现了… 我：哦，是么…. 面试官：那今天的面试到此结束，我们后面会通知你。 我：……………… 关于ConcurrentHashMap，本人也写过不少的分析文章，希望对大家有用： 深入浅出ConcurrentHashMap（1.8） 谈谈ConcurrentHashMap1.7和1.8的不同实现 ConcurrentHashMap的红黑树实现分析 深入分析ConcurrentHashMap1.8的扩容实现","@type":"BlogPosting","url":"http://www.jfox.info/2017/guan-yu-java-mian-shi-ni-ying-gai-zhun-bei-zhe-xie-zhi-shi-dian.html","headline":"关于Java面试，你应该准备这些知识点","dateModified":"2017-01-01T15:48:41+00:00","datePublished":"2017-01-01T15:48:41+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/guan-yu-java-mian-shi-ni-ying-gai-zhun-bei-zhe-xie-zhi-shi-dian.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">关于Java面试，你应该准备这些知识点</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T15:48:41+00:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>原文出处： <a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/1b2f63a45476">占小狼</a></p>

<p>马老师说过，员工的离职原因很多，只有两点最真实：</p>

<p>钱，没给到位 心，受委屈了</p>

<p>当然，我是想换个平台，换个方向，想清楚为什么要跳槽，如果真的要跳槽，想要拿到一个理想的offer，除了运气，基本功也要足够的扎实，希望下面的面试经验能给你们能够提供一些帮助。</p>

<p>项目经验</p>

<p>面试官在一开始会让你进行自我介绍，主要是想让你介绍一下自己做过的一些项目，看看你对这些项目的了解程度，因为很多人简历上写的项目并非都是从头到尾都参与的，有些只是参与并实现了其中的一些模块而已，或是接手维护别人的项目，所以在你简历上所写的和面试过程中所说的项目经验，你自己必须能够了解来龙去脉，因为面试官肯定会根据你的项目描述，对项目中的实现原理，或为什么要这样实现进行提问，这时不至于木讷住而不知如何作答，如此局面只会大大降低面试分。</p>

<p>场景对话：
面试官：（拿着简历）讲讲你最近做的这个项目</p>

<p>我：&amp;……%￥#*&amp;￥@%￥！，说了一大通（不知道面试官听进去多少，面试官会挑他会的进行提问）</p>

<p>面试官：你说这个项目中用到了netty，能大概讲讲netty的线程模型么？</p>

<p>我：（幸好我看过netty的源码）netty通过Reactor模型基于多路复用器接收并处理用户请求（能讲就多讲一点），内部实现了两个线程池，boss线程池和work线程池，其中boss线程池的线程负责处理请求的accept事件，当接收到accept事件的请求时，把对应的socket封装到一个NioSocketChannel中，并交给work线程池，其中work线程池负责请求的read和write事件（通过口述加画图的方式，把请求的执行过程大概描述了一遍，时间有限，也不可能把所有的细节都说完，挑重点讲，挑记忆深刻的讲）</p>

<p>面试官：嗯，理解的还挺深入的…那你在做这个项目时有没有遇到什么困难，或者是觉得有挑战的地方？</p>

<p>我：（这时面试官想让你自己出题自己回答了，所以一定要回答，不回答就突显不出你这个项目了，要是这个问题没有准备过，只能临时发挥了，当然我就是属于临时发挥的）稍微想一下，因为之前确实碰到了这个问题，当时做这个项目时，对netty的不过熟悉，把请求的业务逻辑放在work线程池的线程中进行处理，进行压测的时候，发现qps总是上不去，后来看了源码之后才发现，由于业务逻辑的处理比较耗时，完全占用了work线程池的资源，导致新的请求一直处于等待状态。</p>

<p>面试官：那最后是如何解决的？</p>

<p>我：最后把处理业务的逻辑封装成一个task提交给一个新建的业务线程池中执行，执行完之后由work线程池执行请求的write事件。</p>

<p>面试官：好的，你知道nio中selector可能触发bug么？</p>

<p>我：嗯，对的，selector的select方法，因为底层的epoll函数可能会发生空转，从而导致cpu100%。</p>

<p>面试官：那如何解决该问题？</p>

<p>我：这个问题在netty已经解决了，通过&amp;^%&amp;$^（把netty的解决方案说一遍）</p>

<p>面试官：嗯，对了，你们这个项目有给自己定指标么？</p>

<p>我：有的，&amp;&amp;…………￥￥##@，把自己项目的指标说了一通，如何进行AB实验，如何迭代优化指标</p>

<p>面试官：嗯，好的 ，项目的问题先到这里，我们来考察一下java的基本点吧。</p>

<p>如上只是本人所做的一个项目，当然了，具体项目具体分析，也不是每个面试官问的点都一样，如果面试官不懂netty，自然会挑别的问题进行提问，不过你也可以尝试着把问题往自己熟悉的方向去靠。</p>

<p>面试知识点 1、线程池</p>

<p>线程池的实现原理，这个知识点真的很重要，几乎每次面试都会被问到，一般的提问方式有如下几种：
1、“讲讲线程池的实现原理”
2、“线程池中的coreNum和maxNum有什么不同”
3、“在不同的业务场景中，线程池参数如何设置”</p>

<p>场景对话：
面试官：平时线程池用的多么？</p>

<p>我：嗯，我的*项目中就用到了</p>

<p>面试官：那好，你讲讲线程池的实现原理</p>

<p>我：（还好我之前看过源码，但是时间久远有点模糊了），能给我笔和纸么，我画图分析给你看看，&amp;&amp;￥&amp;假设初始化一个线程池，核心线程数是5，最大线程数是10@@@</p>

<p>面试官：嗯，好的，你继续…</p>

<p>我：在纸上画了正方形，这个代表一个线程池，初始化的时候，里面是没有线程的</p>

<p>面试官：嗯，好的，你继续…</p>

<p>我：又画了一个细长的长方形，这个代表阻塞队列，一开始里面也是没有任务的</p>

<p>面试官：嗯，好的，你继续…</p>

<p>我：当来了一个任务时，在正方形中画了一个小圆圈，代表初始化了一个线程，如果再来一个任务，就再画一个圆圈，表示再初始化了一个线程，连续画了5个圆圈之后，如果第6个任务过来了…</p>

<p>面试官：嗯，好的，你继续…</p>

<p>我：这时会把第6个任务放到阻塞队列中..</p>

<p>面试官：嗯，然后呢？</p>

<p>我：现在线程池中不是有5个线程了么，如果其中一个线程空闲了，就会从阻塞队列中获取第6个任务，进行执行..</p>

<p>面试官：嗯，对的，那如果任务产生的速度比消费的速度快呢？</p>

<p>我：如果线程池的5个线程都在running状态，那么任务就先保存在阻塞队列中</p>

<p>面试官：如果队列满了，怎么办？</p>

<p>我：如果队列满了，我们不是设置了最大线程数是10么，而线程池中只有5个线程，这时会新建一个线程去执行不能保存到阻塞队列的任务，然后我又在正方形中画了5个圆圈。</p>

<p>面试官：那如果线程池中的线程数达到10个了，阻塞队列也满了，怎么办？</p>

<p>我：这种情况通过自定义reject函数去处理这里任务了，舒了一口去，以为问完了…</p>

<p>面试官：好的，那如果运行一段时间之后，阻塞队列中的任务也执行完了，线程池中的线程会怎么样？</p>

<p>我：…这个好像超过核心线程数的线程会在空闲一段时间内自动回收…因为有点不记得这个逻辑了，回答的有点虚…</p>

<p>面试官：好的，那这种情况在什么场景下会发生?</p>

<p>我：（有时候真是笨啊，很多东西都知道，但是在面试的时候一紧张，全忘记）这个…那个…我好像没有遇到过这样的情况</p>

<p>面试官：嗯，好的，你回去之后再好好想想</p>

<p>我：……..</p>

<p>我居然忘记了秒杀这个场景</p>

<p>线程池分析的文章：
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/87bff5cc8d8c">深入分析java线程池的实现原理</a></p>

<p>2、锁的实现</p>

<p>在关于锁的面试过程中，一般主要问Synchronized和ReentrantLock的实现原理，更有甚者会问读写锁。</p>

<p>场景对话：
面试官：都了解Java中的什么锁？</p>

<p>我：比如Synchronized和ReentrantLock…读写锁用的不多，就没研究了（我就怕被问读写锁，因为一直没去看）</p>

<p>面试官：那好，你先说说Synchronized的实现原理吧</p>

<p>我：嗯，Synchronized是JVM实现的一种锁，其中锁的获取和释放分别是monitorenter和monitorexit指令，该锁在实现上分为了偏向锁、轻量级锁和重量级锁，其中偏向锁在1.6是默认开启的，轻量级锁在多线程竞争的情况下会膨胀成重量级锁，有关锁的数据都保存在对象头中…&amp;&amp;@@#，（嗯，说了一大堆，面试官也没打断我）</p>

<p>面试官：哦，嗯，理解的还挺透彻，那你说说ReentrantLock的实现吧…</p>

<p>我：ReentrantLock是基于AQS实现的</p>

<p>面试官：什么是AQS？</p>

<p>我：在AQS内部会保存一个状态变量state，通过CAS修改该变量的值，修改成功的线程表示获取到该锁，没有修改成功，或者发现状态state已经是加锁状态，则通过一个Waiter对象封装线程，添加到等待队列中，并挂起等待被唤醒&amp;&amp;&amp;$$（又说了一堆）</p>

<p>面试官：能说说CAS的实现原理么？</p>

<p>我：CAS是通过unsafe类的compareAndSwap方法实现的（心里得意的一笑）</p>

<p>面试官：哦，好的，那你知道这个方法的参数的含义的么？</p>

<p>我：（这是在逼我啊…努力的回想，因为我真的看过啊）我想想啊，这个方法看的时间有点久远了，第一个参数是要修改的对象，第二个参数是对象中要修改变量的偏移量，第三个参数是修改之前的值，第四个参数是预想修改后的值….（说出来之后都有点佩服自己，这个都记得，不过面试官好像还是不肯放过我…）</p>

<p>面试官：嗯，对的，那你知道操作系统级别是如何实现的么？</p>

<p>我：（我去你大爷…）我只记得X86中有一个cmp开头的指令，具体的我忘记了…</p>

<p>面试官：嗯，好，你知道CAS指令有什么缺点么</p>

<p>我：哦，CAS的缺点是存在ABA问题</p>

<p>面试官：怎么讲？</p>

<p>我：就是一个变量V，如果变量V初次读取的时候是A，并且在准备赋值的时候检查到它仍然是A，那能说明它的值没有被其他线程修改过了吗？如果在这段期间它的值曾经被改成了B，然后又改回A，那CAS操作就会误认为它从来没有被修改过。</p>

<p>面试官：那怎么解决？</p>

<p>我：（有完没完了啊…我的心里是崩溃的）针对这种情况，java并发包中提供了一个带有标记的原子引用类”AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。</p>

<p>面试官：嗯，好的，这个问题到此为止，我们再看看别的</p>

<p>我：….我能喝口水么</p>

<p>关于锁分析的文章，希望对大家有用：
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/d8eeb31bee5c">深入浅出java同步器AQS</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/fb6e91b013cc">java中的CAS</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/19f861ab749e">深入浅出synchronized</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/4358b1466ec9">深入浅出ReentrantLock</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/a16d638bc921">java中的Unsafe</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/195ae7c77afe">java volatile关键字解惑</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/f4454164c017">深入分析Object.wait/notify实现机制</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/c5058b6fe8e5">深入分析synchronized的JVM实现</a></p>

<p>3、ConcurrentHashMap</p>

<p>当考察数据结构时，面试官一开始会问HashMap的实现原理，当你说出HashMap并非线程安全之后，会让你自己引出ConcurrentHashMap，接着就可能开始如下的对话。</p>

<p>场景对话：
面试官：谈谈ConcurrentHashMap实现原理</p>

<p>我：@＃¥@@基于分段锁的％％¥＃@＃¥，但是1.8之后改变实现方式了</p>

<p>面试官：1.8啥方式</p>

<p>我：把1.8的实现原理说了一通，其中提到了红黑树…</p>

<p>面试官：能讲下红黑树的概念吗</p>

<p>我：红黑树是一种二叉树，并且是平衡……％……¥……，</p>

<p>面试官：能讲下红黑树的。。。。。</p>

<p>我：打住，别问了，红黑树我只知道他是二叉树，比其他树多一个属性，其他的我都不知道
面试官：好的，那换个，你知道它的size方法是如何实现的么？</p>

<p>我：size方法？是想要得到Map中的元素个数么？</p>

<p>面试官：对的….</p>

<p>我：我记得好像size方法返回是不准确的，平时也不会用到这个方法…</p>

<p>面试官：如果你觉得size方法返回值不准确，那如果让你自己实现，你觉得应该怎么实现呢？</p>

<p>我：…@＃¥@@…两眼一黑</p>

<p>我：等等，让我想想…..应该可以用AtomicInteger变量进行记录…嗯，对的，每次插入或删除的时候，操作这个变量，我得意的一笑…</p>

<p>面试官：哦，是么，那如果我觉得这个AtomicInteger这个变量性能不好，还能再优化么？</p>

<p>我：懵逼脸…（当时居然把volitile变量给忘记了）…好像没有了，我想不出来了…</p>

<p>面试官：哦，那回头你再看看源码吧，jdk中已经实现了…</p>

<p>我：哦，是么….</p>

<p>面试官：那今天的面试到此结束，我们后面会通知你。</p>

<p>我：………………</p>

<p>关于ConcurrentHashMap，本人也写过不少的分析文章，希望对大家有用：</p>

<p><a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/c0642afe03e0">深入浅出ConcurrentHashMap（1.8）</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/e694f1e868ec">谈谈ConcurrentHashMap1.7和1.8的不同实现</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/23b84ba9a498">ConcurrentHashMap的红黑树实现分析</a>
<a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/f6730d5784ad">深入分析ConcurrentHashMap1.8的扩容实现</a></p>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/guan-yu-java-mian-shi-ni-ying-gai-zhun-bei-zhe-xie-zhi-shi-dian.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/springboot-de-shi-wu-guan-li.html">&laquo; SpringBoot的事务管理</a>
  
  
  <a class="next" href="/2017/shi-yong-uncss-qu-chu-wu-yong-de-css.html">使用uncss去除无用的CSS &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
