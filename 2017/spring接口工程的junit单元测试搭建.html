<!-- build time:Sat Oct 27 2018 21:00:23 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="引言前段时间对我们系统进行了微服务化拆分，最终出现几个单独的纯接口工程（没有web界面）；最近又在搞一个基于国际化的纯接口转换工程。这些工程都有一个共同的特点，就是没有web界面，只是单纯的对外提供服务。没有界面，对应研发人员来说，很难进行自测。以前我们研发的自测方式无非就两种：1、把接口工程部署到测试环境，在调用方的测试环境页面上进行测试；2、自己开发一个servlet的测试界面，进行测试。第一"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="spring接口工程的Junit单元测试搭建"><meta property="og:url" content="http://www.jfox.info/2017/spring接口工程的junit单元测试搭建.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="引言前段时间对我们系统进行了微服务化拆分，最终出现几个单独的纯接口工程（没有web界面）；最近又在搞一个基于国际化的纯接口转换工程。这些工程都有一个共同的特点，就是没有web界面，只是单纯的对外提供服务。没有界面，对应研发人员来说，很难进行自测。以前我们研发的自测方式无非就两种：1、把接口工程部署到测试环境，在调用方的测试环境页面上进行测试；2、自己开发一个servlet的测试界面，进行测试。第一"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.385Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="spring接口工程的Junit单元测试搭建"><meta name="twitter:description" content="引言前段时间对我们系统进行了微服务化拆分，最终出现几个单独的纯接口工程（没有web界面）；最近又在搞一个基于国际化的纯接口转换工程。这些工程都有一个共同的特点，就是没有web界面，只是单纯的对外提供服务。没有界面，对应研发人员来说，很难进行自测。以前我们研发的自测方式无非就两种：1、把接口工程部署到测试环境，在调用方的测试环境页面上进行测试；2、自己开发一个servlet的测试界面，进行测试。第一"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/spring接口工程的junit单元测试搭建.html"><title>spring接口工程的Junit单元测试搭建 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/spring接口工程的junit单元测试搭建.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">spring接口工程的Junit单元测试搭建</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:49:51+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p><strong>引言</strong></p><p>前段时间对我们系统进行了微服务化拆分，最终出现几个单独的纯接口工程（没有web界面）；最近又在搞一个基于国际化的纯接口转换工程。这些工程都有一个共同的特点，就是没有web界面，只是单纯的对外提供服务。没有界面，对应研发人员来说，很难进行自测。</p><p>以前我们研发的自测方式无非就两种：1、把接口工程部署到测试环境，在调用方的测试环境页面上进行测试；2、自己开发一个servlet的测试界面，进行测试。第一种方式，无法进行断点联调；第二种方式工作量大，需要为每个接口开发单独的页面，但这些页面对业务来说又没啥用。</p><p>基于以上原因，准备通过JUnit+spring bean的装配方式，搭建一个适用于纯接口工程的测试demo工程 给新同事作为参考。简单的说最终的效果就是要求不启动接口工程，采用非侵入的方式，就可以实现JUnit测试方法调用。这里所谓的非侵入，指的是不要影响业务代码。</p><p>本章所有示例代码，都已上传GitHub，地址详见文章结尾。</p><p><strong>spring bean装配方式</strong></p><p>由于我们的接口工程都是采用的spring作为Bean容器搭建的，要想使用Junit单元测试，就必须把所有相关的bean先进行装配，在测试方法调用前 被注入到spring容器。也就是说要为接口工程实现Junit单元测试，最主要的就是要自己实现bean的装配。这里有一定的工作量，所以很多系统都不愿去做。但如果设计得好，形成一个模式，就可以在各个接口工程中复用。</p><p>首先我们来分析下Spring提供的三种bean装配机制：</p><p>1、显式XML装配：在XML中进行显示的配置。这种方式一般是用在对jdbc连接池的配置，以及外部依赖接口的配置。还有一些老系统采用的老版本的spring，这些老系统基本都是采用的XMl配置的方式。</p><p>2、隐式自动装配：隐式的bean发现机制和自动装配。这是spring目前比较推崇的方式，目前对于我们内部能控制的业务bean都是采用的这种自动装配方式。但对于依赖参数或者外部bean，无法进行自动装配，我们系统一般采用的是第1种XML配置方式。其实这种情况spring更推崇我们使用第3种方式。</p><p>3、显式java装配：在java中进行显示的配置。这种方式在我们系统中目前基本没有使用，但相比第1种方式会更加灵活，spring也推荐我们使用这种方式。</p><p>由于不同的适用场景，以及不同开发人员的习惯，我们的接口工程中可能同时存在这三类装配方式。我们的首要工作就是要在执行JUnit单元测试方法之前，把这些通过不同装配方式的bean自动注入到容器。下面分别对整合这三类方式进行讲解</p><p><strong>整合“隐式自动装配”</strong></p><p>Spring的隐式自动装配有两种形式：java、xml，java方式比较灵活可以分为三种，对应隐式自动装配的方式大致如下：</p><p>下面我们分别对每种方式的使用简单讲解，再运用到Junit单元测试创建中。</p><p><strong>1、基于java**</strong>注解**：@ComponentScan标记，标记在扫描类上（非业务类）。三种典型的使用方式：</p><p>a、@ComponentScan不带参数：会扫描该被标记类根目录、以及所有子目录下bean类，并把扫描到的所有包含@Component标记的bean类自动装配并注入容器。这种方式侵入性，会在业务代码目录下创建一个扫描类，尽量避免使用，如下的UserServiceConfig类，只是为了扫描使用，类体为空：</p><pre><code>@ComponentScan
public class UserServiceConfig {
}
</code></pre><p>所在目录为：</p><p>所在的目录中UserService为接口类跳过，子目录中UserServiceImpl类被Component标记，会被扫描到，进行自动装配，UserServiceImpl代码如下：</p><pre><code>@Component(&quot;us&quot;)
public class UserServiceImpl implements UserService {
    @Autowired(required = false)
    private UserDao userDao;
    @Override
    public void add() {
        if (userDao != null){
            userDao.add();
        }
        System.out.println(&quot;service层:用户添加成功&quot;);
    }
}
</code></pre><p>在test包（不会被maven打入部署包中）创建Junit测试代码类UserServiceTest，代码如下：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=UserServiceConfig.class)
public class UserServiceTest {
    @Autowired
    private UserService us;
    @Test
    public void usNullTest(){
        Assert.notNull(us);
        us.add();
    }
}
</code></pre><p>@RunWith(SpringJUnit4ClassRunner.class)，指定使用Junit4与spring一起使用。</p><p>@ContextConfiguration(classes=UserServiceConfig.class)，指定spring自动装配路径为UserServiceConfig的跟目录，及其子目录。</p><p>执行Junit的usNullTest方法，打印信息为：</p><pre><code>service层:用户添加成功
</code></pre><p>说明UserServiceImpl自动装配成功，但是它依赖的UserDao没有被注入。</p><p>类似的我们可以在UserDao所在的根目录创建一个UserDaoConfig，并标记为@ComponentScan。</p><p>把@ContextConfiguration(classes={UserServiceConfig.class,UserDaoConfig.class})添加到junit测试类中：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes={UserServiceConfig.class,UserDaoConfig.class})
public class UserServiceTest {
    @Autowired
    private UserService us;
    @Test
    public void usNullTest(){
        Assert.notNull(us);
        us.add();
    }
}
</code></pre><p>再次执行usNullTest测试方法，打印信息为：</p><pre><code>dao层:用户添加成功
service层:用户添加成功
</code></pre><p>说明UserDao被自动装配到UserServiceImpl中，并注入到容器。该方法的Junit单元测试方法创建并测试通过，并无需部署和启动程序就可以完成测试。这里的add测试方法比较简单，正常的业务，可以还需手动传入各种不同的参数，对该方法进行测试。</p><p>但这种方法有个弊端，就是需要在每个业务bean跟目录下去创建一个配置扫描类，对业务有侵入性，而且创建配置扫描类多个也非常麻烦。在创建Junit单元测试时，你可以在test包中创建一个跟业务包相同的包路径，并把扫描类放到该路径下，可以减少侵入性，比如上述UserServiceConfig扫描类可以这样创建：</p><p>但各个子工程模块test包中的代码是彼此不可见的，所有还是有一定局限。</p><p>b、@ComponentScan(basePackages = {“com.xx1″,”com.xx2”,”com.xx3”}) 带basePackages参数，采用这种配置方式，可以完全做到非侵入式：扫描类可以创建在test包中，由Packages指定需要扫描的路径。这是我个人非常建议的方式，具体操作只需要在test包中创建一个PackageScaner类（业务代码包中不会再有扫描类），代码如下：</p><pre><code>@Configuration
@ComponentScan(&quot;com.sky.locale&quot;)
public class PackageAllScaner {
}
</code></pre><p>再创建一个全面的Junit测试类（不建议一个系统就建一个测试类，实际根据具体业务进行拆分）AllAutoServiceTest，代码如下：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=PackageAllScaner.class)
public class AllAutoServiceTest {
    @Autowired
    private UserService us;
    @Autowired
    private ProductService ps;
    @Autowired
    private OrderService os;
    @Test
    public void usNullTest(){
        Assert.notNull(us);
        us.add();
        Assert.notNull(ps);
        ps.add();
        Assert.notNull(os);
        os.add();
    }
}
</code></pre><p>运行测试方法，打印结果如下：</p><pre><code>dao层:用户添加成功
service层:用户添加成功
dao层:商品添加成功
service层:商品添加成功
dao层:订单添加成功
service层:订单添加成功
</code></pre><p>说明所有包下的自动装配都注入成功并测试通过，实际开发中不建议把多个测试写在一个测试方法，根据具体业务调整。</p><p>C、@ComponentScan(basePackageClasses = {xxx1.class, xxx2.class })指定basePackageClasses参数：这种方式可以扫描指定xxx1、xxx2类所在的目录及其子目录下被@Component标记bean，并进行自动装配。相比第二种方式，该扫描类也可以创建在test包中，在一定程度上没有侵入性。但如果需要扫描的目录下没有类，就需要自己创建一个空类作为基准，个人不是很推荐。如果一定要创建：可以在test包下创建以一个跟业务包完全相同的路径，并在该路径下创建扫描类。具体使用方式：</p><p>扫描类：</p><p>@ComponentScan(basePackageClasses = {ServiceScan.class})</p><p>public class ClassScaner {</p><p>}</p><p>ServiceScan类在test包下，上述代码会扫描业务包com.sky.locle.service中所有带@Component标记的bean：</p><p>Junit测试类：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=ClassScaner.class)
public class UserServiceTest {
    //这里就不写测试方法了，感兴趣的可以自己尝试下
}
</code></pre><p>如果待扫描的目录下存在业务类，可以使用，否则需要自己创建一个空的扫描类，具有侵入性，这时不建议使用。</p><p>“隐式自动装配”基于java的@ComponentScan标记的三种方式就将完了。总结下，我们做非侵入的Junit单元测试，最好选择第二种指定package方式@ComponentScan(basePackages = {“com.xx1″,”com.xx2”,”com.xx3”})</p><p><strong>2、XMl**</strong>配置：**基于XML配置实现的“隐式自动装配”配置方式为：&lt;context:component-scan base-package=”com.xxx” /&gt;。在实际开发中，我们经常使用的方式，效果等同于java注解的第二种方式：@ComponentScan(basePackages = {“com.xxx”})。</p><p>我们在写Junit单元测试时，不需要创建自己的xml配置文件，如果一定要创建可以在test包下，防止侵入业务代码。但我们可以在Junit测试代码中直接引用已有的xml配置文件。</p><p>假如，业务代码中已存在一个xml bean配置文件，内容如下：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                            http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
    &lt;context:component-scan base-package=&quot;com.sky.locale.service.product&quot; /&gt;
    &lt;context:component-scan base-package=&quot;com.sky.locale.dao.product&quot; /&gt;
&lt;/beans&gt;
</code></pre><p>我们Junit测试类可以直接引入使用：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:spring-test.xml&quot;})
public class XmlAutoServiceTest {
    @Autowired
    private ProductService ps;
    @Test
    public void usNullTest(){
        Assert.notNull(ps);
        ps.add();
    }
}
</code></pre><p>执行测试方法，打印信息为：</p><pre><code>dao层:商品添加成功
service层:商品添加成功
</code></pre><p>测试通过，基于“隐式自动装配”这种方式的Junit单元测试创建方式讲解结束。</p><p><strong>整合“显式XML装配**</strong>”**</p><p>显式XML装配在spring 2.5以前版本里大量使用。现在一些无法自动装配的bean也会选择使用这种方式，比如配置jdbc连接池以及外部依赖的接口。我们现在常用jdbc配置方式是，把jdbc参数信息放到.properties配置文件中，然后通过XMl装配的方式注入到容器中。</p><p>首先我们先看下常用的XML装配方式：</p><p>1、不带id的方式：</p><pre><code>&lt;!-- 不指定id，默认id为：com.sky.locale.service.explicit.impl.ExplicitTestServiceImpl#0 --&gt;
       &lt;bean class=&quot;com.sky.locale.dao.explicit.impl.ExplicitTestDaoImpl&quot; /&gt;
</code></pre><p>2、带id方式：</p><pre><code>&lt;bean id=&quot;explicitTestDao&quot; class=&quot;com.sky.locale.dao.explicit.impl.ExplicitTestDaoImpl&quot; /&gt;
</code></pre><p>3、构造方法方式，成员为引用，使用ref；成员为基础类型，使用value。</p><pre><code>&lt;bean id=&quot;explicitTestService&quot; class=&quot;com.sky.locale.service.explicit.impl.ExplicitTestServiceImpl&quot;&gt;
              &lt;constructor-arg name=&quot;explicitTestDao&quot; ref=&quot;explicitTestDao&quot;/&gt;
       &lt;/bean&gt;
</code></pre><p>4、构造方法c命令空间方式，构造方法方式的简化版：</p><pre><code>&lt;bean id=&quot;explicitTestService1&quot; class=&quot;com.sky.locale.service.explicit.impl.ExplicitTestServiceImpl&quot;
             c:explicitTestDao-ref=&quot;explicitTestDao&quot; /&gt;
</code></pre><p>5、settter方式：</p><pre><code>&lt;!-- setter注入--&gt;
       &lt;bean id=&quot;explicitTestService2&quot; class=&quot;com.sky.locale.service.explicit.impl.ExplicitTestServiceImpl&quot;&gt;
              &lt;property name=&quot;explicitTestDao&quot; ref=&quot;explicitTestDao&quot;/&gt;
              &lt;property name=&quot;name&quot; value=&quot;123&quot;/&gt;
              &lt;property name=&quot;books&quot;&gt;
                     &lt;list&gt;
                            &lt;value&gt;monkeys&lt;/value&gt;
                            &lt;value&gt;pigs&lt;/value&gt;
                     &lt;/list&gt;
              &lt;/property&gt;
       &lt;/bean&gt;
</code></pre><p>6、setter对应的p命名空间方式：</p><pre><code>&lt;!-- p 命名空间注入 --&gt;
       &lt;bean id=&quot;explicitTestService3&quot; class=&quot;com.sky.locale.service.explicit.impl.ExplicitTestServiceImpl&quot;
               p:explicitTestDao-ref=&quot;explicitTestDao&quot;
               p:name=&quot;123&quot;&gt;
              &lt;property name=&quot;books&quot;&gt;
                     &lt;list&gt;
                            &lt;value&gt;monkeys&lt;/value&gt;
                            &lt;value&gt;pigs&lt;/value&gt;
                     &lt;/list&gt;
              &lt;/property&gt;
       &lt;/bean&gt;
</code></pre><p>对于这种list，set等集合成员，还可以单独提取出来，变形成这样：</p><pre><code>&lt;!-- 使用util:list把list转移出去 --&gt;
       &lt;bean id=&quot;explicitTestService5&quot; class=&quot;com.sky.locale.service.explicit.impl.ExplicitTestServiceImpl&quot;
             p:explicitTestDao-ref=&quot;explicitTestDao&quot;
             p:name=&quot;123&quot;
             p:books-ref=&quot;books&quot;&gt;
       &lt;/bean&gt;
       &lt;util:list id=&quot;books&quot;&gt;
              &lt;value&gt;monkeys&lt;/value&gt;
              &lt;value&gt;pigs&lt;/value&gt;
       &lt;/util:list&gt;
</code></pre><p>这种提取，同样适用于c命令空间。</p><p>对于这种方式的整合到Junit，其实前面已经用到，直接在Junit测试类中指定对应的xml即可：@ContextConfiguration(locations = {“classpath:xxxx.xml”})。这里我们以Junit整合一个jdbc数据源为例进行讲解，首先看下需要装配的数据源类TestJdbcSource：</p><pre><code>public class TestJdbcSource {
    private String userName;
    private String password;
    private String uri;
    public TestJdbcSource(String userName,String password,String uri){
        this.userName = userName;
        this.password = password;
        this.uri = uri;
    }
    public void getSource(){
        System.out.println(&quot;连接数据库uri:&quot;+uri);
        System.out.println(&quot;连接数据库用户名:&quot;+userName);
        System.out.println(&quot;连接数据库密码:&quot;+password);
    }
}
</code></pre><p>然后看下装配该bean的xml配置：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!-- 不需要依赖的id，可以不用指定--&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;locations&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;classpath:test.properties&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;testDbSource&quot; class=&quot;com.sky.locale.dao.jdbc.TestJdbcSource&quot;&gt;
        &lt;constructor-arg name=&quot;uri&quot; value=&quot;${jdbc.url}&quot;/&gt;
        &lt;constructor-arg name=&quot;userName&quot; value=&quot;${jdbc.username}&quot;/&gt;
        &lt;constructor-arg name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>在看下属性配置文件test.properties内容：</p><pre><code>jdbc.url=jdbc:msyql:loadbalance://localhost/test_db
jdbc.username=root
jdbc.password=123
</code></pre><p>我们要在JUnit中使用该数据源，可以直接引入xml配置即可，代码如下：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {&quot;classpath:spring-jdbc.xml&quot;})
public class JdbcSourceTest {
    @Autowired
    private TestJdbcSource testDbSource;
    @Test
    public void jdbcTest(){
        Assert.notNull(testDbSource);
        testDbSource.getSource();
    }
}
</code></pre><p>运行测试方法，打印信息为：</p><pre><code>连接数据库uri:jdbc:msyql:loadbalance://localhost/test_db
连接数据库用户名:root
连接数据库密码:123
</code></pre><p>说明Junit整合“显示XML装配” 成功。</p><p><strong>整合”显式java装配**</strong>”**</p><p>这种方式类似“显示xml装配”，但比xml更加灵活。新版spring也推荐使用这种方式（所谓的去xml化），但可惜的是现在我们系统还基本没有使用过。我们首先看下”显式java装配”方法有那些形式：</p><p>首先创建一个空类，@Configuration表示该类为一个配置类：</p><pre><code>@Configuration
public class ExplicitTestConfig {
}
</code></pre><p>然后依次往里面添加下列方法，进行“显示java装配”。</p><p>1、没有依赖其他对象的bean，直接调用其无参构造方法：</p><pre><code>@Bean(name=&quot;explicitTestDao&quot;)
    public ExplicitTestDao explicitTestDao(){
        return new ExplicitTestDaoImpl();
    }
</code></pre><p>2、有依赖其他对象的bean，调用其构造方法，并注入需要的对象：</p><pre><code>@Bean(name = &quot;explicitTestService0&quot;)
    public ExplicitTestService explicitTestService0(){
        return new ExplicitTestServiceImpl(explicitTestDao());
}
</code></pre><p>这里以explicitTestDao()方法，会让人错误的以为多次的创建了新的对象，其实spring默认是单例，这种写法不会重复创建对象。</p><p>3、有依赖其他对象的bean，为避免第2中方式的错觉，可以直接以bean名注入：</p><pre><code>@Bean(name = &quot;explicitTestService1&quot;)
    public ExplicitTestService explicitTestService1(ExplicitTestDao explicitTestDao){
        return new ExplicitTestServiceImpl(explicitTestDao);
}
</code></pre><p>推荐使用这种方式，同时注意这里创建的bean跟2中相同，但name不同。</p><p>4、setter方式注入，与方式2对应：</p><pre><code>@Bean(name = &quot;explicitTestService2&quot;)
    public ExplicitTestService explicitTestService3(){
        ExplicitTestServiceImpl impl = new ExplicitTestServiceImpl();
        impl.setExplicitTestDao(explicitTestDao());
        return impl;
}
</code></pre><p>5、setter方式注入，与方式3对应：</p><pre><code>@Bean(name = &quot;explicitTestService3&quot;)
    public ExplicitTestService explicitTestService2(ExplicitTestDao explicitTestDao){
        ExplicitTestServiceImpl impl = new ExplicitTestServiceImpl();
        impl.setExplicitTestDao(explicitTestDao);
        return impl;
}
</code></pre><p>可以看到通过“显示java装配”的方式，可以在方法里任意的实现自己的逻辑，比”xml”更加灵活。</p><p>与Junit整合，也很简单，直接在JUnit测试类中通过注解引入上述配置类，@ContextConfiguration(classes=ExplicitTestConfig.class)即可。</p><p><strong>整合三种装配方式</strong></p><p>前面把Junit分别三种装配方式整合进行了讲解。但我们所在的项目，业务代码很有可能以上三种装配方式都有使用，这时候创建Junit单元测试，需要把不同的装配方式整合到一起。其中”自动装配”其实也是通过，java或者xml配置实现的。所有我们只需要整合java装配和xml装配。具体可以使用@import 和@importResource注解来实现。</p><p>假设有个业务测试，需要用到商品接口、用户接口、jdbc数据连接。我们可以把各个业务块的java装配、xml转配整合到一起。具体整合内容如下：</p><pre><code>@Import({UserServiceConfig.class,ProductServiceConfig.class})
@ImportResource(&quot;classpath:spring-jdbc.xml&quot;)
public class MultConfig {
}
@ComponentScan
public class UserServiceConfig {
}
@ComponentScan
public class ProductServiceConfig {
}
&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;
    &lt;!-- 不需要依赖的id，可以不用指定--&gt;
    &lt;bean class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;
        &lt;property name=&quot;locations&quot;&gt;
            &lt;list&gt;
                &lt;value&gt;classpath:test.properties&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&quot;testDbSource&quot; class=&quot;com.sky.locale.dao.jdbc.TestJdbcSource&quot;&gt;
        &lt;constructor-arg name=&quot;uri&quot; value=&quot;${jdbc.url}&quot;/&gt;
        &lt;constructor-arg name=&quot;userName&quot; value=&quot;${jdbc.username}&quot;/&gt;
        &lt;constructor-arg name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre><p>这种整合方式有点类似 我们用一个顶级的xml配置文件，整合各个业务模块xml配置一样：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;GBK&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
                     http://www.springframework.org/schema/beans/spring-beans.xsd&quot;
       default-autowire=&quot;byName&quot;&gt;
    &lt;import resource=&quot;xx1.xml&quot; /&gt;
    &lt;import resource=&quot;xx2.xml&quot; /&gt;
    &lt;import resource=&quot;xx3.xml&quot; /&gt;
&lt;/beans&gt;
</code></pre><p>整合完成后，创建Junit测试类，这时只需引入整合后的MultConfig类即可：</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(classes=MultConfig.class)
public class MultTest {
    @Autowired
    private UserService us;
    @Autowired
    private ProductService ps;
    @Autowired
    private TestJdbcSource testDbSource;
    @Test
    public void mutliTest(){
        Assert.notNull(us);
        Assert.notNull(ps);
        Assert.notNull(testDbSource);
        us.add();
        ps.add();
        testDbSource.getSource();
    }
}
</code></pre><p>执行测试方法，打印结果为：</p><pre><code>service层:用户添加成功
service层:商品添加成功
连接数据库uri:jdbc:msyql:loadbalance://localhost/test_db
连接数据库用户名:root
连接数据库密码:123
</code></pre><p>整合成功。</p><p>理论上通过这种方式，你可以把程序中所有bean都注入到容器中，而不需要部署程序，就可以对任意一个接口方法进行测试。</p><p>通过以上讲解，应该覆盖了我们在创建Junit单元测试所遇到的大部分情况。根据不同场景，灵活运用，可以让我们的纯接口工程测试更加轻松。</p><p>以上示例代码已上传到GitHub，地址：<a href="https://github.com/gantianxing/spring-test.git" target="_blank" rel="noopener">https://github.com/gantianxing/spring-test.git</a></p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/监控工具之spotlight.html" rel="next" title="【监控工具之Spotlight】"><i class="fa fa-chevron-left"></i> 【监控工具之Spotlight】</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/在java中-将string类型字符串s赋值为null后-将字符串与其他字.html" rel="prev" title="在java中，将String类型字符串s赋值为null后，将字符串与其他字符串拼接后得到结果出现了null字符串与其他字符连接的样式">在java中，将String类型字符串s赋值为null后，将字符串与其他字符串拼接后得到结果出现了null字符串与其他字符连接的样式 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->