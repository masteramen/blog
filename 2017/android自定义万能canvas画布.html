<!-- build time:Sat Oct 27 2018 21:00:19 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="分类：android进阶的小步伐（361） （2）一、需求：1.在自定义的画布中实现可缩放手势，摇一摇可对控件进行整理排序；2.画布中可以添加位置设定的控件，控件可以响应点击、长按、拖动事件；3.控件A长按事件会隐藏画布中的控件除了A之外，显示另一个控件B；当A在在底层画布中拖动，拖动结束之后回到原画布；当A移动B的位置范围响应操作（可以添加另方面功能）。二、实现思想：1、画布的的手势缩放、控件的"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="Android自定义万能Canvas画布"><meta property="og:url" content="http://www.jfox.info/2017/android自定义万能canvas画布.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="分类：android进阶的小步伐（361） （2）一、需求：1.在自定义的画布中实现可缩放手势，摇一摇可对控件进行整理排序；2.画布中可以添加位置设定的控件，控件可以响应点击、长按、拖动事件；3.控件A长按事件会隐藏画布中的控件除了A之外，显示另一个控件B；当A在在底层画布中拖动，拖动结束之后回到原画布；当A移动B的位置范围响应操作（可以添加另方面功能）。二、实现思想：1、画布的的手势缩放、控件的"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:40.325Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Android自定义万能Canvas画布"><meta name="twitter:description" content="分类：android进阶的小步伐（361） （2）一、需求：1.在自定义的画布中实现可缩放手势，摇一摇可对控件进行整理排序；2.画布中可以添加位置设定的控件，控件可以响应点击、长按、拖动事件；3.控件A长按事件会隐藏画布中的控件除了A之外，显示另一个控件B；当A在在底层画布中拖动，拖动结束之后回到原画布；当A移动B的位置范围响应操作（可以添加另方面功能）。二、实现思想：1、画布的的手势缩放、控件的"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/android自定义万能canvas画布.html"><title>Android自定义万能Canvas画布 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/android自定义万能canvas画布.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Android自定义万能Canvas画布</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:56:20+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>分类：<em>android进阶的小步伐</em></p><p>（361） （2）</p><p>一、需求：</p><p>1.在自定义的画布中实现可缩放手势，摇一摇可对控件进行整理排序；</p><p>2.画布中可以添加位置设定的控件，控件可以响应点击、长按、拖动事件；</p><p>3.控件A长按事件会隐藏画布中的控件除了A之外，显示另一个控件B；当A在在底层画布中拖动，拖动结束之后回到原画布；当A移动B的位置范围响应操作（可以添加另方面功能）。</p><p>二、实现思想：</p><p>1、画布的的手势缩放、控件的添加，在我的<a href="https://www.jfox.info/go.php?url=http://blog.csdn.net/wangyongyao1989/article/details/74157556">上一篇关于画布文章</a>中已经实现了这个功能，这里不再赘述；</p><p>2、要实现上述的几个功能只需要屏幕上添加两层画布，一层画布用于添加控件在这层中可以实现控件的点击、拖动、画布缩放、长按事件、整理排序控件。底层画布用于长按其他控件隐藏之后A控件的拖动和B控件的显示及A拖动到B之后的事件响应。</p><p>3、当A控件结束拖动（抬起时）回到第一层画布中。</p><p>三、效果展示：</p><p>四、具体实现：</p><p>1.先添加两层画布用布局可以RelativeLayout包裹着，如：</p><pre><code>&lt;RelativeLayout
     android:layout_width=&quot;match_parent&quot;
     android:layout_height=&quot;match_parent&quot;&gt;
     &lt;com.view.ActionEditorCanvasView
         android:id=&quot;@+id/action_editor_canvas_gamepad_test&quot;
         android:visibility=&quot;gone&quot;
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;/&gt;
     &lt;com.view.ActionEditorCanvasView
         android:id=&quot;@+id/action_editor_canvas_test&quot;
         android:layout_width=&quot;match_parent&quot;
         android:layout_height=&quot;match_parent&quot;/&gt;
 &lt;/RelativeLayout&gt;
</code></pre><p>2.当控件添加到画布中要获取到对应控件的位置信息（将添加的控件添加到一个集合中），判断点击时是否是落在控件之上，这些都是在view中的onTouchEvent(MotionEvent event)进行处理：</p><pre><code>private int getDown2Widget() {
       for (int i = 0; i &lt; mDrawableList.size(); i++) {
           int xcoords = mDrawableList.get(i).getXcoords();
           int ycoords = mDrawableList.get(i).getYcoords();
           double abs = Math.sqrt((DownX - xcoords) * (DownX - xcoords) + (DownY - ycoords) * (DownY - ycoords));
           //点落在控件内
           if (abs &lt; ActionWidget.RADIUS) {
               return i;
           }
       }
       return -1;
   }
</code></pre><p>3、在画布中实现Move、LongPress、Up、Click的接口回调用于对外应用：</p><pre><code>public onWidgetUpListener mOnWidgetUpListener;
public interface onWidgetUpListener{
    void onWidgetUp(int index,int x,int y);
}

public void  setOnWidgetUpListener(onWidgetUpListener mOnWidgetUpListener){
    this.mOnWidgetUpListener=mOnWidgetUpListener;
}

public onWidgetMoveListener mOnWidgetMoveListener;

public interface onWidgetMoveListener{
     void onWidgetMove(int index,int x,int y);
}

public void  setOnWidgetMoveListener(onWidgetMoveListener moveListener){
    this.mOnWidgetMoveListener=moveListener;
}

public onWidgetLongPressListener mOnWidgetLongPressListener;

public interface onWidgetLongPressListener{
    void onWidgetLongPress(int index,int x,int y);
}

public void setOnWidgetLongPressListener(onWidgetLongPressListener mOnWidgetLongPressListener){
    this.mOnWidgetLongPressListener=mOnWidgetLongPressListener;
}


public onWidgetClickListener mOnWidgetClickListener;

public interface onWidgetClickListener{
    void onWidgetClick(int index,int x,int y);
}

public void setOnWidgetClickListener(onWidgetClickListener mOnWidgetClickListener){
    this.mOnWidgetClickListener=mOnWidgetClickListener;
}
</code></pre><p>4.接下来就是处理拖动、点击、长按、抬起的事件的处理：</p><pre><code>public boolean onTouchEvent(MotionEvent event) {       
       switch (event.getAction()) {
           case MotionEvent.ACTION_DOWN: {
               mDownTime = System.currentTimeMillis();
               DownX = event.getX();//float DownX
               DownY = event.getY();//float DownY
               //判断点击的坐标范围是否在控件上
               mDown2Widget = getDown2Widget();
               moveX = 0;
               moveY = 0;
               moveX1 = 0;
               moveY1 = 0;
           }
           break;
           case MotionEvent.ACTION_MOVE: {
               moveX += Math.abs(event.getX() - DownX);//X轴距离
               moveY += Math.abs(event.getY() - DownY);//y轴距离
               moveX1 = event.getX();
               moveY1 = event.getY();
               if (moveX == 0 &amp;&amp; moveY == 0) {
                   mMoveTime = System.currentTimeMillis();
                   long DValueTime = mMoveTime - mDownTime;//计算点击下去是否有移动及事件是否符合长按的时间值，这样可以判断是否是长按事件
                   if (DValueTime&gt;200){
                       if (mOnWidgetLongPressListener!=null){
                           mOnWidgetLongPressListener.onWidgetLongPress(mDown2Widget,(int)moveX1,(int)moveY1);
                       }
                   }
                   return true;
               } else {
                   if (mDown2Widget &gt; -1) {
                       if (mOnWidgetMoveListener!=null){
                           mOnWidgetMoveListener.onWidgetMove(mDown2Widget,(int)moveX1,(int)moveY1);
                       }
                       mDrawableList.get(mDown2Widget).setXcoords((int) moveX1);//点击在控件之上进行的move则把控件坐标值重置，从而是实现控件拖动
                       mDrawableList.get(mDown2Widget).setYcoords((int) moveY1);
                       invalidate();
                   }
               }
               DownX = event.getX();
               DownY = event.getY();
           }
           break;
           case MotionEvent.ACTION_UP: {
               long moveTime = System.currentTimeMillis() - currentMS;//移动时间
               mUpTime = System.currentTimeMillis();
               long DValueTime = mUpTime - mDownTime;//判断从按下到抬起的实现，从而实现判断是否是点击
               if (mDown2Widget &gt; -1) {
                   //判断是否为拖动事件
                   if (!(moveTime &gt; 1000 &amp;&amp; (moveX &gt; 100 || moveY &gt; 100))) {
                       if (DValueTime &lt; 200) {
                           if (mOnWidgetClickListener!=null){
                               mOnWidgetClickListener.onWidgetClick(mDown2Widget,(int)moveX1,(int)moveY1);
                           }
                       }
                   }
               }
               if (mOnWidgetUpListener!=null){//判断是否是抬起事件
                   mOnWidgetUpListener.onWidgetUp(mDown2Widget,(int)moveX1,(int)moveY1);
               }
           }
           break;
       }
       return true;

   }
</code></pre><p>5、在底层画布添加控件B，并获取位置信息存起来：</p><pre><code>mBitmap= BitmapFactory.decodeResource(getResources(),R.drawable.ic_launcher);
mGamePadBitmap=new CBitmap(mBitmap,200,1000);
mXcoords = mGamePadBitmap.getXcoords();
mYcoords = mGamePadBitmap.getYcoords();
mGamePadCanvasView.addCanvasDrawable(mGamePadBitmap);
</code></pre><p>6、处理长按事件，隐藏第一层画布显示底层画布，并获取A控件位置在底层画布中画出来：</p><pre><code>mCanvasView.setOnWidgetLongPressListener(new ActionEditorCanvasView.onWidgetLongPressListener() {
     @Override
     public void onWidgetLongPress(int index, int x, int y) {
         ActionWidget actionWidget = (ActionWidget) mCanvasView.mDrawableList.get(index);
         mCanvasView.setVisibility(View.GONE);
         mGamePadCanvasView.setVisibility(View.VISIBLE);
         mGamePadWidget=new ActionWidget(x, y, mPaint);
         mGamePadCanvasView.addCanvasDrawable(mGamePadWidget);
         isGamePadCanvas=true;//把是否显示底层画布的开关开启
     }
 });
</code></pre><p>7、判断A控件是否移动B控件的位置范围之上：</p><pre><code>mCanvasView.setOnWidgetMoveListener(new ActionEditorCanvasView.onWidgetMoveListener() {
            @Override
            public void onWidgetMove(int index, int x, int y) {
                if (isGamePadCanvas){
                    if (mGamePadWidget!=null){
                        mGamePadCanvasView.mDrawableList.get(1).setXcoords(x);
                        mGamePadCanvasView.mDrawableList.get(1).setYcoords(y);
                        mGamePadCanvasView.invalidate();
                        if ((x&gt;mXcoords&amp;&amp;x&lt;mXcoords+250)&amp;&amp;(y&gt;mYcoords&amp;&amp;y&lt;mYcoords+250)){
                            Toast.makeText(ActionCanvasTestActivity.this, &quot;控件移动到控制器按钮界面！！！！！&quot; , Toast.LENGTH_SHORT).show();
                        }
                    }
               }
            }
        });
</code></pre><p>8、最后是判断抬起事件，如底层画布是显示则隐藏底层画布显示第一层画布：</p><pre><code>mCanvasView.setOnWidgetUpListener(new ActionEditorCanvasView.onWidgetUpListener() {
      @Override
      public void onWidgetUp(int index, int x, int y) {
          if (isGamePadCanvas){
              mCanvasView.setVisibility(View.VISIBLE);
              mGamePadCanvasView.setVisibility(View.GONE);
              mGamePadCanvasView.mDrawableList.remove(1);
              isGamePadCanvas=false;
          }
      }
  });
</code></pre><p>五、Demo项目地址：</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/okhttp拦截器retryandfollowupinterceptor的简单分析.html" rel="next" title="OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析"><i class="fa fa-chevron-left"></i> OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/第一章良好应用程序基石2.html" rel="prev" title="第一章.良好应用程序基石(2)">第一章.良好应用程序基石(2) <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->