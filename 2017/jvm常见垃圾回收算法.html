<!-- build time:Sat Oct 27 2018 21:00:18 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="jdk1.7.0_79众所周知，Java是一门不用程序员手动管理内存的语言，全靠JVM自动管理内存，既然是自动管理，那必然有一个垃圾内存的回收机制或者回收算法。本文将介绍几种常见的垃圾回收（下文简称GC）算法。在Java堆上分配一个内存给实例对象时，此时在虚拟机栈上引用型变量就会存放这个实例对象的起始地址。Object obj = new Object();  现在如果我们将变量赋值为null。o"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="JVM常见垃圾回收算法"><meta property="og:url" content="http://www.jfox.info/2017/jvm常见垃圾回收算法.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="jdk1.7.0_79众所周知，Java是一门不用程序员手动管理内存的语言，全靠JVM自动管理内存，既然是自动管理，那必然有一个垃圾内存的回收机制或者回收算法。本文将介绍几种常见的垃圾回收（下文简称GC）算法。在Java堆上分配一个内存给实例对象时，此时在虚拟机栈上引用型变量就会存放这个实例对象的起始地址。Object obj = new Object();  现在如果我们将变量赋值为null。o"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2017/1301/c7b2d44.png"><meta property="og:image" content="http://www.jfox.info/2017/1301/652bbeb.png"><meta property="og:image" content="http://www.jfox.info/2017/1301/2c05ddd.png"><meta property="og:image" content="http://www.jfox.info/2017/1301/7902876.png"><meta property="og:image" content="http://www.jfox.info/2017/1301/7838dea.png"><meta property="og:updated_time" content="2018-10-27T12:29:39.342Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JVM常见垃圾回收算法"><meta name="twitter:description" content="jdk1.7.0_79众所周知，Java是一门不用程序员手动管理内存的语言，全靠JVM自动管理内存，既然是自动管理，那必然有一个垃圾内存的回收机制或者回收算法。本文将介绍几种常见的垃圾回收（下文简称GC）算法。在Java堆上分配一个内存给实例对象时，此时在虚拟机栈上引用型变量就会存放这个实例对象的起始地址。Object obj = new Object();  现在如果我们将变量赋值为null。o"><meta name="twitter:image" content="http://www.jfox.info/2017/1301/c7b2d44.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/jvm常见垃圾回收算法.html"><title>JVM常见垃圾回收算法 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/jvm常见垃圾回收算法.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JVM常见垃圾回收算法</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:56:41+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p><strong><em>jdk1.7.0_79</em></strong></p><p>众所周知，Java是一门不用程序员手动管理内存的语言，全靠JVM自动管理内存，既然是自动管理，那必然有一个垃圾内存的回收机制或者回收算法。本文将介绍几种常见的垃圾回收（下文简称GC）算法。</p><p>在Java堆上分配一个内存给实例对象时，此时在虚拟机栈上引用型变量就会存放这个实例对象的起始地址。</p><pre><code>Object obj = new Object(); 
</code></pre><p><img src="/2017/1301/c7b2d44.png" alt=""></p><p>现在如果我们将变量赋值为null。</p><pre><code>obj = null;
</code></pre><p><img src="/2017/1301/652bbeb.png" alt=""></p><p>此时可以看到Java<strong>堆上的实例对象无法再次引用它，那么它就是被GC的对象，我们称之为对象“已死”</strong>。那虚拟机栈上的obj变量呢？上文<a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/yulinfeng/p/7153391.html">《</a><a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/yulinfeng/p/7153391.html">JVM入门——</a><a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/yulinfeng/p/7153391.html">运行时数据区》</a>提到过，虚拟机栈是线程独占的，也就是说随着线程初始而初始，消亡而消亡，当线程被销毁后，虚拟机栈上的内存自然会被回收，也就是说<strong>虚拟机栈上的这块内存空间不在虚拟机GC范围</strong>。下图展示了垃圾回收的内存范围：</p><p><img src="/2017/1301/2c05ddd.png" alt=""></p><p>1.<strong>对象是否“已死”算法——引用计数器算法</strong></p><p>对象中添加一个引用计数器，如果引用计数器为0则表示没有其它地方在引用它。如果有一个地方引用就+1，引用失效时就-1。看似搞笑且简单的一个算法，实际上在大部分Java虚拟机中并没有采用这种算法，因为它会带来一个致命的问题——对象循环引用。对象A指向B，对象B反过来指向A，此时它们的引用计数器都不为0，但它们俩实际上已经没有意义因为没有任何地方指向它们。所以又引出了下面的算法。</p><p><strong>2.<em>**</em></strong>对象是否“已死”算法——可达性分析算法<em>**</em></p><p>这种算法可以有效地避免对象循环引用的情况，整个对象实例以一个树呈现，根节点是一个称为“GC Roots”的对象，从这个对象开始向下搜索并作标记，遍历完这棵树过后，未被标记的对象就会判断“已死”，即为可被回收的对象。</p><p><img src="/2017/1301/7902876.png" alt=""></p><p><strong>GC算法</strong></p><p>1.<strong>标记–清除算法</strong></p><p>等待被回收对象的“标记”过程在上文已经提到过，如果在被标记后直接对对象进行清除，会带来另一个新的问题——内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</p><p>2.<strong>复制算法**</strong>（Java堆中新生代的垃圾回收算法）**</p><p>此GC算法实际上解决了标记–清除算法带来的“内存碎片化”问题。首先还是先标记处待回收内存和不用回收的内存，下一步将不用回收的内存复制到新的内存区域，这样旧的内存区域就可以全部回收，而新的内存区域则是连续的。它的缺点就是会损失掉部分系统内存，因为你总要腾出一部分内存用于复制。</p><p>在上文<a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/yulinfeng/p/7153391.html">《JVM</a><a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/yulinfeng/p/7153391.html">入门——运行时数据区》</a>提到过在Java堆中被分为了新生代和老年代，这样的划分是方便GC。Java堆中的新生代就使用了GC复制算法。在新生代中又分为了三个区域：Eden 空间、To Survivor空间、From Survivor空间。不妨将注意力回到这张图的左边新生代部分：</p><p><img src="/2017/1301/7838dea.png" alt=""></p><p>新的对象实例被创建的时候通常在Eden空间，发生在Eden空间上的GC称为Minor GC，<strong>当在新生代发生一次GC后**</strong>，<strong><strong>会将Eden</strong></strong>和其中一个Survivor空间的内存复制到另外一个Survivor中**，如果反复几次有对象一直存活，此时内存对象将会被移至老年代。可以看到新生代中Eden占了大部分，而两个Survivor实际上占了很小一部分。这是因为大部分的对象被创建过后很快就会被GC（这里也许运用了是二八原则）。</p><p>3.<strong>标记**</strong>–<strong><strong>压缩算法</strong></strong>（或称为标记-整理算法，Java堆中老年代的垃圾回收算法）**</p><p>对于新生代，大部分对象都不会存活，所以在新生代中使用复制算法较为高效，而对于老年代来讲，大部分对象可能会继续存活下去，如果此时还是利用复制算法，效率则会降低。<strong>标记–压缩算法首先还是“标记”，标记过后，将不用回收的内存对象压缩到内存一端，此时即可直接清除边界处的内存</strong>，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。老年代的垃圾回收称为“Major GC”。</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/java分支与循环.html" rel="next" title="java 分支与循环 » java面试题"><i class="fa fa-chevron-left"></i> java 分支与循环 » java面试题</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/spring学习之动态代理.html" rel="prev" title="Spring学习之动态代理">Spring学习之动态代理 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->