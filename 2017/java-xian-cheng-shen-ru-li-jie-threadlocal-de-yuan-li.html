<!-- build time:Sat Nov 03 2018 21:45:29 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta name="fileName" content="2017/0450"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="ThreadLocal与线程成员变量还有区别，ThreadLocal该类提供了线程局部变量。这个局部变量与一般的成员变量不一样，ThreadLocal的变量在被多个线程使用时候，每个线程只能拿到该变量的一个副本，这是Java API中的描述，通过阅读API源码，发现并非副本，副本什么概念？克隆品? 或者是别的样子，太模糊。准确的说，应该是ThreadLocal类型的变量内部的注册表（Map&amp;lt;"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="Java线程：深入理解ThreadLocal的原理"><meta property="og:url" content="http://www.jfox.info/2017/java-xian-cheng-shen-ru-li-jie-threadlocal-de-yuan-li.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="ThreadLocal与线程成员变量还有区别，ThreadLocal该类提供了线程局部变量。这个局部变量与一般的成员变量不一样，ThreadLocal的变量在被多个线程使用时候，每个线程只能拿到该变量的一个副本，这是Java API中的描述，通过阅读API源码，发现并非副本，副本什么概念？克隆品? 或者是别的样子，太模糊。准确的说，应该是ThreadLocal类型的变量内部的注册表（Map&amp;lt;"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:31:13.623Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java线程：深入理解ThreadLocal的原理"><meta name="twitter:description" content="ThreadLocal与线程成员变量还有区别，ThreadLocal该类提供了线程局部变量。这个局部变量与一般的成员变量不一样，ThreadLocal的变量在被多个线程使用时候，每个线程只能拿到该变量的一个副本，这是Java API中的描述，通过阅读API源码，发现并非副本，副本什么概念？克隆品? 或者是别的样子，太模糊。准确的说，应该是ThreadLocal类型的变量内部的注册表（Map&amp;lt;"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/java-xian-cheng-shen-ru-li-jie-threadlocal-de-yuan-li.html"><title>Java线程：深入理解ThreadLocal的原理 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>Tags</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/java-xian-cheng-shen-ru-li-jie-threadlocal-de-yuan-li.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java线程：深入理解ThreadLocal的原理</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:42:30+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>ThreadLocal与线程成员变量还有区别，ThreadLocal该类提供了线程局部变量。这个局部变量与一般的成员变量不一样，ThreadLocal的变量在被多个线程使用时候，每个线程只能拿到该变量的一个副本，这是Java API中的描述，通过阅读API源码，发现并非副本，副本什么概念？克隆品? 或者是别的样子，太模糊。<br>准确的说，应该是ThreadLocal类型的变量内部的注册表（Map&lt;Thread,T&gt;）发生了变化，但ThreadLocal类型的变量本身的确是一个，这才是本质！<br>下面就做个例子：<br>一、标准例子<br>定义了MyThreadLocal类，创建它的一个对象tlt，分别给四个线程使用，结果四个线程tlt变量并没有出现共用现象，二是各用各的，这说明，四个线程使用的是tlt的副本（克隆品）。</p><pre><code>/**
*　使用了ThreadLocal的类
*
*　@author　leizhimin　2010-1-5　10:35:27
*/
public　class　MyThreadLocal　{
　　　　　　　　 //定义了一个ThreadLocal变量，用来保存int或Integer数据
　　　　　　　　 private　ThreadLocal　tl　=　new　ThreadLocal()　{
　　　　　　　　　　　　　　　　 @Override
　　　　　　　　　　　　　　　　 protected　Integer　initialValue()　{
　　　　　　　　　　　　　　　　　　　　　　　　 return　0;
　　　　　　　　　　　　　　　　 }
　　　　　　　　 };
　　　　　　　　 public　Integer　getNextNum()　{
　　　　　　　　　　　　　　　　 //将tl的值获取后加1，并更新设置t1的值
　　　　　　　　　　　　　　　　 tl.set(tl.get()　+　1);
　　　　　　　　　　　　　　　　 return　tl.get();
　　　　　　　　 }
}


/**
*　测试线程
*
*　@author　leizhimin　2010-1-5　10:39:18
*/
public　class　TestThread　extends　Thread　{
　　　　　　　　 private　MyThreadLocal　tlt　=　new　MyThreadLocal();
　　　　　　　　 public　TestThread(MyThreadLocal　tlt)　{
　　　　　　　　　　　　　　　　 this.tlt　=　tlt;
　　　　　　　　 }
　　　　　　　　 @Override
　　　　　　　　 public　void　run()　{
　　　　　　　　　　　　　　　　 for　(int　i　=　0;　i　&lt;　3;　i++)　{
　　　　　　　　　　　　　　　　　　　　　　　　 System.out.println(Thread.currentThread().getName()　+　&quot;\t&quot;　+　tlt.getNextNum());
　　　　　　　　　　　　　　　　 }
　　　　　　　　 }
}


/**
*　ThreadLocal测试
*
*　@author　leizhimin　2010-1-5　10:43:48
*/
public　class　Test　{
　　　　　　　　 public　static　void　main(String[]　args)　{
　　　　　　　　　　　　　　　　 MyThreadLocal　tlt　=　new　MyThreadLocal();
　　　　　　　　　　　　　　　　 Thread　t1　=　new　TestThread(tlt);
　　　　　　　　　　　　　　　　 Thread　t2　=　new　TestThread(tlt);
　　　　　　　　　　　　　　　　 Thread　t3　=　new　TestThread(tlt);
　　　　　　　　　　　　　　　　 Thread　t4　=　new　TestThread(tlt);
　　　　　　　　　　　　　　　　 t1.start();
　　　　　　　　　　　　　　　　 t2.start();
　　　　　　　　　　　　　　　　 t3.start();
　　　　　　　　　　　　　　　　 t4.start();
　　　　　　　　 }
}
</code></pre><p>可以看出，三个线程各自独立编号，互不影响：</p><pre><code>Thread-0　　1
Thread-1　　1
Thread-0　　2
Thread-1　　2
Thread-0　　3
Thread-1　　3
Thread-2　　1
Thread-3　　1
Thread-2　　2
Thread-3　　2
Thread-2　　3
Thread-3　　3
Process　finished　with　exit　code　0
</code></pre><p>tlt对象是一个，废话tl对象也是一个，因为组合关系是一对一的。但是tl对象内部的Map随着线程的增多，会创建很多Integer对象。只是Integer和int已经通用了。所以感觉不到Integer的对象属性。<br>二、不用ThreadLocal<br>假如不用ThreadLocal，只需要将MyThreadLocal类重新定义为：</p><pre><code>/**
*　使用了ThreadLocal的类
*
*　@author　leizhimin　2010-1-5　10:35:27
*/
public　class　MyThreadLocal　{
　　　　　　　　 private　Integer　t1　=　0;
　　　　　　　　 public　Integer　getNextNum(){
　　　　　　　　　　　　　　　　 return　t1=t1+1;
　　　　　　　　 }

//　　　　　　　　//定义了一个ThreadLocal变量，用来保存int或Integer数据
//　　　　　　　　private　ThreadLocal　tl　=　new　ThreadLocal()　{
//　　　　　　　　　　　　　　　　@Override
//　　　　　　　　　　　　　　　　protected　Integer　initialValue()　{
//　　　　　　　　　　　　　　　　　　　　　　　　return　0;
//　　　　　　　　　　　　　　　　}
//　　　　　　　　};
//
//　　　　　　　　public　Integer　getNextNum()　{
//　　　　　　　　　　　　　　　　//将tl的值获取后加1，并更新设置t1的值
//　　　　　　　　　　　　　　　　tl.set(tl.get()　+　1);
//　　　　　　　　　　　　　　　　return　tl.get();
//　　　　　　　　}
}
</code></pre><p>然后运行测试：</p><pre><code>Thread-2　　1
Thread-2　　2
Thread-1　　4
Thread-1　　6
Thread-3　　3
Thread-3　　9
Thread-3　　10
Thread-1　　8
Thread-0　　7
Thread-0　　11
Thread-0　　12
Thread-2　　5　
Process　finished　with　exit　code　0
</code></pre><p>从这里可以看出，四个线程共享了tlt变量，结果每个线程都直接修改tlt的属性。</p><p>三、自己实现个ThreadLocal</p><pre><code>import　java.util.Collections;
import　java.util.HashMap;
import　java.util.Map;
/**
*　使用了ThreadLocal的类
*
*/
public　class　MyThreadLocal　{
　　　　　　　　 //定义了一个ThreadLocal变量，用来保存int或Integer数据
　　　　　　　　 private　com.lavasoft.test2.ThreadLocal　tl　=　new　com.lavasoft.test2.ThreadLocal()　{
　　　　　　　　　　　　　　　　 @Override
　　　　　　　　　　　　　　　　 protected　Integer　initialValue()　{
　　　　　　　　　　　　　　　　　　　　　　　　 return　0;
　　　　　　　　　　　　　　　　 }
　　　　　　　　 };
　　　　　　　　 public　Integer　getNextNum()　{
　　　　　　　　　　　　　　　　 //将tl的值获取后加1，并更新设置t1的值
　　　　　　　　　　　　　　　　 tl.set(tl.get()　+　1);
　　　　　　　　　　　　　　　　 return　tl.get();
　　　　　　　　 }
}
class　ThreadLocal　{
　　　　　　　　 private　Map&lt;Thread,　T&gt;　map　=　Collections.synchronizedMap(new　HashMap&lt;Thread,　T&gt;());
　　　　　　　　 public　ThreadLocal()　{
　　　　　　　　 }
　　　　　　　　 protected　T　initialValue()　{
　　　　　　　　　　　　　　　　 return　null;
　　　　　　　　 }
　　　　　　　　 public　T　get()　{
　　　　　　　　　　　　　　　　 Thread　t　=　Thread.currentThread();
　　　　　　　　　　　　　　　　 T　obj　=　map.get(t);
　　　　　　　　　　　　　　　　 if　(obj　==　null　&amp;&amp;　!map.containsKey(t))　{
　　　　　　　　　　　　　　　　　　　　　　　　 obj　=　initialValue();
　　　　　　　　　　　　　　　　　　　　　　　　 map.put(t,　obj);
　　　　　　　　　　　　　　　　 }
　　　　　　　　　　　　　　　　 return　obj;
　　　　　　　　 }
　　　　　　　　 public　void　set(T　value)　{
　　　　　　　　　　　　　　　　 map.put(Thread.currentThread(),　value);
　　　　　　　　 }
　　　　　　　　 public　void　remove()　{
　　　　　　　　　　　　　　　　 map.remove(Thread.currentThread());
　　　　　　　　 }
}
</code></pre><p>运行测试：</p><pre><code>Thread-0　　1
Thread-0　　2
Thread-0　　3
Thread-2　　1
Thread-2　　2
Thread-3　　1
Thread-2　　3
Thread-3　　2
Thread-1　　1
Thread-3　　3
Thread-1　　2
Thread-1　　3
Process　finished　with　exit　code　0
</code></pre><p>很意外，这个山寨版的ThreadLocal也同样运行很好，实现了JavaAPI中ThreadLocal的功能。</p><p>四、透过现象看本质<br>其实从程序角度看，tlt变量的确是一个，毫无疑问的。但是为什么打印出来的数字就互不影响呢？<br>是因为使用了Integer吗？—–不是。<br>原因是：protected T initialValue()和get()，因为每个线程在调用get()时候，发现Map中不存在就创建。调用它的时候，就创建了一个新变量，类型为T。每次都新建，当然各用个的互不影响了。<br>为了看清本质，将Integer换掉，重写部分类：</p><pre><code>import　java.util.Collections;
import　java.util.HashMap;
import　java.util.Map;
/**
*　使用了ThreadLocal的类
*
*/
public　class　MyThreadLocal　{
　　　　　　　　 //定义了一个ThreadLocal变量，用来保存int或Integer数据
　　　　　　　　 //　　　　　　　　private　ThreadLocal　tl　=　new　ThreadLocal()　{
　　　　　　　　 private　com.lavasoft.test2.ThreadLocal　tl　=　new　com.lavasoft.test2.ThreadLocal()　{
　　　　　　　　　　　　　　　　 @Override
　　　　　　　　　　　　　　　　 protected　Bean　initialValue()　{
　　　　　　　　　　　　　　　　　　　　　　　　 return　new　Bean();
　　　　　　　　　　　　　　　　 }
　　　　　　　　 };
　　　　　　　　 @Override
　　　　　　　　 public　String　toString()　{
　　　　　　　　　　　　　　　　 return　&quot;MyThreadLocal{&quot;　+
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 &quot;tl=&quot;　+　tl　+
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 &apos;}&apos;;
　　　　　　　　 }
　　　　　　　　 public　Bean　getBean()　{
　　　　　　　　　　　　　　　　 return　tl.get();
　　　　　　　　 }
}
class　ThreadLocal　{
　　　　　　　　 private　Map&lt;Thread,　T&gt;　map　=　Collections.synchronizedMap(new　HashMap&lt;Thread,　T&gt;());
　　　　　　　　 public　ThreadLocal()　{
　　　　　　　　 }
　　　　　　　　 protected　T　initialValue()　{
　　　　　　　　　　　　　　　　 return　null;
　　　　　　　　 }
　　　　　　　　 public　T　get()　{
　　　　　　　　　　　　　　　　 Thread　t　=　Thread.currentThread();
　　　　　　　　　　　　　　　　 T　obj　=　map.get(t);
　　　　　　　　　　　　　　　　 if　(obj　==　null　&amp;&amp;　!map.containsKey(t))　{
　　　　　　　　　　　　　　　　　　　　　　　　 obj　=　initialValue();
　　　　　　　　　　　　　　　　　　　　　　　　 map.put(t,　obj);
　　　　　　　　　　　　　　　　 }
　　　　　　　　　　　　　　　　 return　obj;
　　　　　　　　 }
　　　　　　　　 public　void　set(T　value)　{
　　　　　　　　　　　　　　　　 map.put(Thread.currentThread(),　value);
　　　　　　　　 }
　　　　　　　　 public　void　remove()　{
　　　　　　　　　　　　　　　　 map.remove(Thread.currentThread());
　　　　　　　　 }
}


/**
*　测试Bean
*
*　@author　leizhimin　2010-1-5　14:18:26
*/
public　class　Bean　{
　　　　　　　　 private　String　id　=　&quot;0&quot;;
　　　　　　　　 private　String　name　=　&quot;none&quot;;
　　　　　　　　 public　Bean()　{
　　　　　　　　 }
　　　　　　　　 public　Bean(String　id,　String　name)　{
　　　　　　　　　　　　　　　　 this.id　=　id;
　　　　　　　　　　　　　　　　 this.name　=　name;
　　　　　　　　 }
　　　　　　　　 public　String　getId()　{
　　　　　　　　　　　　　　　　 return　id;
　　　　　　　　 }
　　　　　　　　 public　void　setId(String　id)　{
　　　　　　　　　　　　　　　　 this.id　=　id;
　　　　　　　　 }
　　　　　　　　 public　String　getName()　{
　　　　　　　　　　　　　　　　 return　name;
　　　　　　　　 }
　　　　　　　　 public　void　setName(String　name)　{
　　　　　　　　　　　　　　　　 this.name　=　name;
　　　　　　　　 }
　　　　　　　　 public　String　showinfo()　{
　　　　　　　　　　　　　　　　 return　&quot;Bean{&quot;　+
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 &quot;id=&apos;&quot;　+　id　+　&apos;\&apos;&apos;　+
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 &quot;,　name=&apos;&quot;　+　name　+　&apos;\&apos;&apos;　+
　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 &apos;}&apos;;
　　　　　　　　 }
}


/**
*　测试线程
*
*　@author　leizhimin　2010-1-5　10:39:18
*/
public　class　TestThread　extends　Thread　{
　　　　　　　　 private　MyThreadLocal　tlt　=　new　MyThreadLocal();
　　　　　　　　 public　TestThread(MyThreadLocal　tlt)　{
　　　　　　　　　　　　　　　　 this.tlt　=　tlt;
　　　　　　　　 }
　　　　　　　　 @Override
　　　　　　　　 public　void　run()　{
　　　　　　　　　　　　　　　　 System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;:&quot;　+　tlt);
　　　　　　　　　　　　　　　　 for　(int　i　=　0;　i　&lt;　3;　i++)　{
　　　　　　　　　　　　　　　　　　　　　　　　 System.out.println(Thread.currentThread().getName()　+　&quot;\t&quot;　+tlt.getBean()+&quot;\t&quot;+tlt.getBean().showinfo());
　　　　　　　　　　　　　　　　 }
　　　　　　　　 }
}
</code></pre><p>然后运行测试：</p><pre><code>&gt;&gt;&gt;&gt;&gt;:MyThreadLocal{tl=com.lavasoft.test2.MyThreadLocal$1@1de3f2d}
&gt;&gt;&gt;&gt;&gt;:MyThreadLocal{tl=com.lavasoft.test2.MyThreadLocal$1@1de3f2d}
&gt;&gt;&gt;&gt;&gt;:MyThreadLocal{tl=com.lavasoft.test2.MyThreadLocal$1@1de3f2d}
&gt;&gt;&gt;&gt;&gt;:MyThreadLocal{tl=com.lavasoft.test2.MyThreadLocal$1@1de3f2d}
Thread-1　　com.lavasoft.test2.Bean@291aff　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-2　　com.lavasoft.test2.Bean@fe64b9　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-3　　com.lavasoft.test2.Bean@186db54　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-2　　com.lavasoft.test2.Bean@fe64b9　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-2　　com.lavasoft.test2.Bean@fe64b9　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-0　　com.lavasoft.test2.Bean@291aff　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-3　　com.lavasoft.test2.Bean@186db54　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-3　　com.lavasoft.test2.Bean@186db54　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-1　　com.lavasoft.test2.Bean@291aff　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-0　　com.lavasoft.test2.Bean@291aff　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-0　　com.lavasoft.test2.Bean@291aff　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Thread-1　　com.lavasoft.test2.Bean@291aff　　Bean{id=&apos;0&apos;,　name=&apos;none&apos;}
Process　finished　with　exit　code　0
</code></pre><p>从打印结果很清楚的看到，MyThreadLocal的tlt对象的确是一个，tlt对象里的ThreadLocal的tl对象也是一个，但是，将t1t给每个线程用的时候，线程会重新创建Bean对象加入到ThreadLocal的Map中去使用。</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/java-yi-chang-ji-zhi.html" rel="next" title="java异常机制 » java面试题"><i class="fa fa-chevron-left"></i> java异常机制 » java面试题</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/java-xian-cheng-shen-ru-li-jie-threadlocal-de-yuan-li.html" rel="prev" title="Java线程：深入理解ThreadLocal的原理">Java线程：深入理解ThreadLocal的原理 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">691</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">3</span> <span class="site-state-item-name">tags</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->