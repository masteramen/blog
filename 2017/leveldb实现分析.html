<!-- build time:Sat Oct 27 2018 21:00:20 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="LevelDB 介绍LevelDB 是由 Google 开发的 key-value 非关系型数据库存储系统，是基于 LSM(Log-Structured-Merge Tree) 的典型实现，LSM 的原理是：当读写数据库时，首先纪录读写操作到 Op log 文件中，然后再操作内存数据库，当达到 checkpoint 时，则写入磁盘，同时删除相应的 Op log 文件，后续重新生成新的内存文件和 O"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="LevelDB 实现分析"><meta property="og:url" content="http://www.jfox.info/2017/leveldb实现分析.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="LevelDB 介绍LevelDB 是由 Google 开发的 key-value 非关系型数据库存储系统，是基于 LSM(Log-Structured-Merge Tree) 的典型实现，LSM 的原理是：当读写数据库时，首先纪录读写操作到 Op log 文件中，然后再操作内存数据库，当达到 checkpoint 时，则写入磁盘，同时删除相应的 Op log 文件，后续重新生成新的内存文件和 O"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:39.177Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="LevelDB 实现分析"><meta name="twitter:description" content="LevelDB 介绍LevelDB 是由 Google 开发的 key-value 非关系型数据库存储系统，是基于 LSM(Log-Structured-Merge Tree) 的典型实现，LSM 的原理是：当读写数据库时，首先纪录读写操作到 Op log 文件中，然后再操作内存数据库，当达到 checkpoint 时，则写入磁盘，同时删除相应的 Op log 文件，后续重新生成新的内存文件和 O"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/leveldb实现分析.html"><title>LevelDB 实现分析 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/leveldb实现分析.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">LevelDB 实现分析</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:55:03+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h3 id="LevelDB-介绍"><a href="#LevelDB-介绍" class="headerlink" title="LevelDB 介绍"></a>LevelDB 介绍</h3><p>LevelDB 是由 Google 开发的 key-value 非关系型数据库存储系统，是基于 LSM(Log-Structured-Merge Tree) 的典型实现，LSM 的原理是：当读写数据库时，首先纪录读写操作到 Op log 文件中，然后再操作内存数据库，当达到 checkpoint 时，则写入磁盘，同时删除相应的 Op log 文件，后续重新生成新的内存文件和 Op log 文件。</p><p>LevelDB 内部采用了内存缓存机制，也就是在写数据库时，首先会存储在内存中，内存的存储结构采用了 skip list 结构，待达到 checkpoint 时，才进行落盘操作，保证了数据库的高效运转。</p><h3 id="LevelDB-总体架构"><a href="#LevelDB-总体架构" class="headerlink" title="LevelDB 总体架构"></a>LevelDB 总体架构</h3><p>如上图所示，整个 LevelDB 由以下几部分组成：</p><ol><li>Write(k,v)，对外的接口</li><li>Op log，操作日志记录文件</li><li>memtable，数据库存储的内存结构</li><li>Immutable memtable，待落盘的数据库内存数据</li><li>sstable，落盘后的磁盘存储结构</li><li>manifest，LevelDB 元信息清单，包括数据库的配置信息和中间使用的文件列表</li><li>current，当前正在使用的文件清单</li></ol><p>整体结构清晰紧凑，非常容易理解。</p><h3 id="对外接口"><a href="#对外接口" class="headerlink" title="对外接口"></a>对外接口</h3><p>DB() { };<br>virtual ~DB();<br>static Status Open(const Options&amp; options,<br>const std::string&amp; name,<br>DB*<em> dbptr);<br>virtual Status Put(const WriteOptions&amp; options,<br>const Slice&amp; key,<br>const Slice&amp; value) = 0;<br>virtual Status Delete(const WriteOptions&amp; options, const Slice&amp; key) = 0;<br>virtual Status Write(const WriteOptions&amp; options, WriteBatch</em> updates) = 0;<br>virtual Status Get(const ReadOptions&amp; options,<br>const Slice&amp; key, std::string<em> value) = 0;<br>virtual Iterator</em> NewIterator(const ReadOptions&amp; options) = 0;<br>virtual const Snapshot<em> GetSnapshot() = 0;<br>virtual void ReleaseSnapshot(const Snapshot</em> snapshot) = 0;</p><pre><code>  1 


  2 


  3 


  4 


  5 


  6 


  7 


  8 


  9 


  10 


  11 


  12 


  13 


  14 


  15 

DB(){};virtual~DB();staticStatus Open(constOptions&amp;options,                   conststd::string&amp;name,                   DB**dbptr);virtual Status Put(constWriteOptions&amp;options,                   constSlice&amp;key,                   constSlice&amp;value)=0;virtual Status Delete(constWriteOptions&amp;options,constSlice&amp;key)=0;virtual Status Write(constWriteOptions&amp;options,WriteBatch*updates)=0;virtual Status Get(constReadOptions&amp;options,                   constSlice&amp;key,std::string*value)=0;virtual Iterator*NewIterator(constReadOptions&amp;options)=0;virtual constSnapshot*GetSnapshot()=0;virtual voidReleaseSnapshot(constSnapshot*snapshot)=0;
</code></pre><p>整体接口分为：</p><p>数据库创建和删除</p><p>DB() { };<br>virtual ~DB();</p><pre><code>  1 


  2 

DB(){};virtual~DB();
</code></pre><p>数据库打开</p><p>static Status Open(const Options&amp; options,<br>const std::string&amp; name,<br>DB** dbptr);</p><pre><code>  1 


  2 


  3 

staticStatus Open(constOptions&amp;options,                   conststd::string&amp;name,                   DB**dbptr);
</code></pre><p>数据库读写删除操作</p><p>virtual Status Put(const WriteOptions&amp; options,<br>const Slice&amp; key,<br>const Slice&amp; value) = 0;<br>virtual Status Delete(const WriteOptions&amp; options, const Slice&amp; key) = 0;<br>virtual Status Get(const ReadOptions&amp; options,<br>const Slice&amp; key, std::string* value) = 0;</p><pre><code>  1 


  2 


  3 


  4 


  5 


  6 

virtual Status Put(constWriteOptions&amp;options,                   constSlice&amp;key,                   constSlice&amp;value)=0;virtual Status Delete(constWriteOptions&amp;options,constSlice&amp;key)=0;virtual Status Get(constReadOptions&amp;options,                   constSlice&amp;key,std::string*value)=0;
</code></pre><p>数据库批处理操作</p><p>virtual Status Write(const WriteOptions&amp; options, WriteBatch* updates) = 0;</p><pre><code>  1 

virtual Status Write(constWriteOptions&amp;options,WriteBatch*updates)=0;
</code></pre><p>数据库遍历操作</p><p>virtual Iterator* NewIterator(const ReadOptions&amp; options) = 0;</p><pre><code>  1 

virtual Iterator*NewIterator(constReadOptions&amp;options)=0;
</code></pre><p>获取快照操作</p><p>virtual const Snapshot<em> GetSnapshot() = 0;<br>virtual void ReleaseSnapshot(const Snapshot</em> snapshot) = 0;</p><pre><code>  1 


  2 

virtual constSnapshot*GetSnapshot()=0;virtual voidReleaseSnapshot(constSnapshot*snapshot)=0;
</code></pre><h4 id="Op-log结构分析"><a href="#Op-log结构分析" class="headerlink" title="Op log结构分析"></a>Op log结构分析</h4><p>LevelDB 使用的 Op log 日志采用了文件记录的方式，且文件使用了 mmap 方式操作，以提高效率。</p><p>Op log 存储切分为 32KB 大小的数据块，每个 32KB 数据块存储着 Op log，每 个Op log 格式如下：</p><p>其中：</p><ol><li>CRC32 为 crc 校验码，保证数据的完整性</li><li>Length，为 Op log 的数据长度</li><li>Log Type，Op log 的类型，之所以会有类型，是由于 32KB 可能存不下一条 Op log，Op log 有可能跨数据块，类型分为：</li></ol><ul><li>FULL：代表 Data 包含了所有的数据</li><li>FIRST：代表该 Data 是 Op log 的开始数据</li><li>MIDDLE：代表该 Data 是 Op log 的中间数据</li><li>LAST: 代表该 Data 是 Op log 的结束数据</li></ul><ol start="4"><li>Data，为 Op log 的实际数据</li></ol><h4 id="memtable-结构分析"><a href="#memtable-结构分析" class="headerlink" title="memtable 结构分析"></a>memtable 结构分析</h4><p>memtable 是 LevelDB 数据库的内存存储结构，采用了 skip list 结构存储，如下图所示：</p><p>skip list 是一种可以代替平衡树的存储结构，它采用概率的方式来保证平衡，而平衡树则是采用严格的旋转树结构来保证平衡，复杂度会高一些。 对于 skip list，会有 n 层链表，其中 0 层保存所有的值，越往上层，保存的值越少。每当插入一个值时，会通过概率计算该值需要插入的最高层级 k，然后从 0~k-1 层，分别插入该值。</p><p>其中每个表项的存储结构如下：</p><p>key_size | key_value | sequence_num&amp;type | value_size | value</p><p>其中：</p><p>sequence_num：表示操作的序列号，每一个数据项都会带有一个序列号，用以表示数据的新旧程度。</p><p>type：表示数据的类型，分为：</p><ul><li>kTypeValue：表明数据有效</li><li>kTypeDeletion：表明数据已经失效，在数据进行 delete 操作时会打上该标识</li></ul><h4 id="sstable-结构分析"><a href="#sstable-结构分析" class="headerlink" title="sstable 结构分析"></a>sstable 结构分析</h4><p>sstable 作为落盘的存储结构，每个 sstable 最大 2MB，从宏观来看，它属于分层的结构，即：</p><ul><li>level 0：最多存储 4 个 sstable</li><li>level 1：存储不超过 10MB 大小的 sstable</li><li>level 2：存储不超过 100MB 大小的 sstable</li></ul><p>level 3 及之后：存储大小不超过上一级大小的 10 倍</p><p>之所以这样分层，是为了提高查找效率，也是 LevelDB 名称的由来。当每一层超过限制时，会进行 compaction 操作，合并到上一层，递归进行。</p><p>从微观的角度看，每个 sstable 文件结构入下图所示：</p><p>其中：</p><ul><li>Data Block 存储具体的 k-v 数据</li><li>Meta Block 存储索引过滤信息，用于快速定位 key 是否存在于 Data Block 中</li><li>Meta Index Block 存储 Meta Block 的偏移位置及大小</li><li>Index Block 存储 Data Block 的偏移位置及大小</li><li>Footer 则存储 Meta Index Block 和 Index Block 的偏移位置及大小，相当于二级索引，Footer 的结构如下：</li></ul><p>另外 Data Block 及 Meta Block 的存储格式是统一的，都是如下格式：</p><p>其中 type 表示是否是压缩存储，目前 LevelDB 支持 key 值的 snappy 压缩或者不压缩。</p><p>而上图中的 Block data 的格式则为：</p><p>上图有几点要说明：</p><ol><li>对于 Block data 中的第一项总是不压缩存储的，不压缩存储的项称为 restarts，会被记录在上图的最尾部，同时每隔 k 个值（k 值可定制），都会存储一个不压缩的项，这些都称为 restarts，都会被记录在最尾部。</li><li>每个 restarts 表项会作为索引项存储。</li><li>除了 restarts 表项以外，其它的表项则基于该 restarts 项，计算跟他相同部分和不同部分，上图中的 shared_bytes 和 unshared_bytes 记录了相同部分长度和不同部分的长度，key_delta 则记录了不同的部分的值，value_length 和 value 则记录了 value 部分的值。</li><li>压不压缩是可选的，默认会进行 snappy 压缩。</li></ol><p>对于 Meta Block 来说，它保存了用于快速定位 key 是否在 Data Block 中的信息，具体方法是：</p><ol><li>采用了 bloom filter 的过滤机制，bloom filter 是一种 hash 机制，它对每一个 key，会计算 k 个 hash 值，然后在 k 个 bit 位记录为 1。当查找时，相应计算出 k 个 hash 值，然后比对 k 个 bit 位是否为 1，只要有一个不为 1，则不存在。</li><li>对于每一个 Data Block，所有的 key 值会传入进行 bloom filter 的 hash 计算，每个 key 存储 k 个 bit 位值。</li></ol><h4 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h4><p>对于 LevelDB 来说，它采用了简单的 sequence num 机制来管理，具体为：</p><ol><li>对于 Op log 文件，每一个 Op log 文件名中会包含一个唯一的 sequence num，每创建一个新的 Op log 文件，sequence num 则加 1，sequence num 越大，则表示文件越新，同时最新的 sequence num 会记录下来。</li><li>对于每个 key-value 对，也会对应一个 sequence num，对于同一个 key，如果后续更新值时，sequence num 也会相应更新，这样就可以根据 sequence num 的大小，找到最新的 key-value 对</li></ol><h4 id="新增特性"><a href="#新增特性" class="headerlink" title="新增特性"></a>新增特性</h4><ol><li>支持模煳查询该功能支持 key 以模煳规则匹配的方式进行数据库查询，支持＊和？两种模煳规则查询。</li><li>支持 JSON 格式数据存储该功能支持 k-v 中，v以json格式传入，后续可以通过关键字，查询json里面的数据。</li></ol><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>LevelDB 短小精悍，代码运行效率高效，且通俗易懂，是一个非常不错的 k-v 存储系统。</p><p>注：图片来源于网络</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/基于semantic既可以下拉框也可以文本框输入.html" rel="next" title="基于semantic既可以下拉框也可以文本框输入"><i class="fa fa-chevron-left"></i> 基于semantic既可以下拉框也可以文本框输入</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/linkedlist原理及源码解析.html" rel="prev" title="LinkedList原理及源码解析">LinkedList原理及源码解析 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#LevelDB-介绍"><span class="nav-number">1.</span> <span class="nav-text">LevelDB 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LevelDB-总体架构"><span class="nav-number">2.</span> <span class="nav-text">LevelDB 总体架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对外接口"><span class="nav-number">3.</span> <span class="nav-text">对外接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Op-log结构分析"><span class="nav-number">3.1.</span> <span class="nav-text">Op log结构分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#memtable-结构分析"><span class="nav-number">3.2.</span> <span class="nav-text">memtable 结构分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#sstable-结构分析"><span class="nav-number">3.3.</span> <span class="nav-text">sstable 结构分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#版本管理"><span class="nav-number">3.4.</span> <span class="nav-text">版本管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#新增特性"><span class="nav-number">3.5.</span> <span class="nav-text">新增特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#结束语"><span class="nav-number">3.6.</span> <span class="nav-text">结束语</span></a></li></ol></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->