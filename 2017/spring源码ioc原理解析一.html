<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Spring源码：IOC原理解析（一） | Java面试</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="Spring源码：IOC原理解析（一）" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="IOC(Inversion of Control)，即控制反转，意思是将对象的创建和依赖关系交给第三方容器处理，我们要用的时候告诉容器我们需要什么然后直接去拿就行了。举个例子，我们有一个工厂，它生产各种产品，当你需要某个产品，比如你需要一辆汽车，你就告诉工厂你需要一辆汽车，工厂就会直接返回给你一辆汽车，而不需要你自己通过付出劳动来得到这辆汽车，你也不用关心工厂是如何生产这辆汽车。对应到我们的程序中就是，IOC容器会帮我们创建和管理对象，当你告诉容器你需要某个对象时，容器会把这个对象返回给你，而不需要自己去new出一个对象来，对象的创建和管理会由容器自动进行，直接从容器中拿来用就可以了。IOC可以说是Spring最核心的思想，它使我们的开发变得简单（对象之间的依赖关系可以通过配置文件或者注解来创建），对于这种优秀的设计思想，我们当然有必要研究一下它的底层实现原理。 首先我们来关注一个接口，源码如下： package org.springframework.beans.factory; import org.springframework.beans.BeansException; import org.springframework.core.ResolvableType; import org.springframework.lang.Nullable; /** * * @author Rod Johnson * @author Juergen Hoeller * @author Chris Beams * @since 13 April 2001 * */publicinterface BeanFactory { String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); } 这个接口便是spring核心的bean工厂定义，它是IOC容器的顶层接口，spring中所有bean工厂都直接或间接的继承或实现了这个接口。我们平时使用的最多的ApplicationContext接口也继承了BeanFactory接口，因此它具有BeanFactory接口的所有功能，这里顺便提一下，从BeanFactory获取bean时，实例化BeanFactory容器并不会实例化所配置的bean，只有当使用某个bean(getBean)时，才会实时的实例化该bean；从ApplicationContext获取bean时，实例化ApplicationContext容器时会一并实例化容器中的所有的bean。 从BeanFactory的源码可以看出，它实现的核心功能就是根据名称或类型来返回一个bean实例。一个工厂如果要具备这种功能，结合工厂模式的思想，我们可以试想一下它需要具备以下几个条件： 1、持有各种bean的定义，只有拿到了bean的定义信息，才能根据这些信息进行实例化； 2、持有各种bean之间的依赖关系，如果一个类中持有对另一个类的引用，那么在对该类进行实例化时，必须根据类之间的依赖关系对相关类也进行实例化，因此，工厂必须获得类之间的依赖关系，否则无法正确实例化； 3、以上两种信息都依赖于我们的配置信息定义，比如xml配置文件，工厂需要一个工具来读取配置文件的信息。 以上是我们设想IOC的实现思路，只要满足以上三个条件，就能构造一个工厂，生产各种bean。但是我们还是有一些疑问，比如在第一个条件中，我们如何持有bean的定义呢？我们先来看另外一个接口： package org.springframework.beans.factory.config; import org.springframework.beans.BeanMetadataElement; import org.springframework.beans.MutablePropertyValues; import org.springframework.core.AttributeAccessor; import org.springframework.lang.Nullable; /** * 一个BeanDefinition描述一个bean实例具有的属性值，构造函数参数值，以及具体实现的进一步信息。 * * A BeanDefinition describes a bean instance, which has property values, * constructor argument values, and further information supplied by * concrete implementations. * * @author Juergen Hoeller * @author Rob Harrop * @since 19.03.2004 */publicinterface BeanDefinition extends AttributeAccessor, BeanMetadataElement { String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; int ROLE_APPLICATION = 0; int ROLE_SUPPORT = 1; int ROLE_INFRASTRUCTURE = 2; void setParentName(@Nullable String parentName); @Nullable String getParentName(); void setBeanClassName(@Nullable String beanClassName); @Nullable String getBeanClassName(); void setScope(@Nullable String scope); @Nullable String getScope(); void setLazyInit(boolean lazyInit); boolean isLazyInit(); /** * Set the names of the beans that this bean depends on being initialized. * The bean factory will guarantee that these beans get initialized first. */void setDependsOn(String... dependsOn); /** * Return the bean names that this bean depends on. */ @Nullable String[] getDependsOn(); void setAutowireCandidate(boolean autowireCandidate); boolean isAutowireCandidate(); void setPrimary(boolean primary); boolean isPrimary(); void setFactoryBeanName(@Nullable String factoryBeanName); @Nullable String getFactoryBeanName(); void setFactoryMethodName(@Nullable String factoryMethodName); @Nullable String getFactoryMethodName(); ConstructorArgumentValues getConstructorArgumentValues(); MutablePropertyValues getPropertyValues(); boolean isSingleton(); boolean isPrototype(); boolean isAbstract(); int getRole(); @Nullable String getDescription(); @Nullable String getResourceDescription(); @Nullable BeanDefinition getOriginatingBeanDefinition(); } BeanDefinition，顾名思义便是spring中的bean定义接口，spring的工厂里持有的就是此接口定义的内容。从源码可以看出，这个接口继承了两个另外两个接口，一个是AttributeAccessor接口，继承这个接口就意味着BeanDefinition接口拥有了处理属性的能力，另外一个接口是BeanMetedataElement，它可以获得bean的配置定义的元素，对于xml文件来说就是会持有bean的标签。从源码中我们可以看出，BeanDefinition接口定义了两个方法，分别是void setDependsOn(String… dependsOn)和String[] getDependsOn()，从方法的说明可以看出，这两个方法就是设置依赖的bean的名称和获取依赖的bean的名称，这就意味着只要我们有一个BeanDefinition，就能得到得到bean的定义信息和bean之间的依赖关系，从而可以生产一个完整的bean实例。 从上面两个接口，我们大致可以猜出spring是如何持有bean的定义信息及依赖关系了，没错，就是让bean工厂持有一个Map&lt;String，BeanDefinition&gt;，String型的beanName作为key，BeanDefinition型的bean定义作为value，这样就能生产一个bean实例。BeanFactory接口当然不能持有这个map对象，那么一定是在它的某个实现类里所持有的，我们找到了这个实现类，来看看源码： package org.springframework.beans.factory.support; import java.io.IOException; import java.io.NotSerializableException; import java.io.ObjectInputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.annotation.Annotation; import java.lang.ref.Reference; import java.lang.ref.WeakReference; import java.lang.reflect.Method; import java.security.AccessController; import java.security.PrivilegedAction; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.IdentityHashMap; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Optional; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import javax.inject.Provider; import org.springframework.beans.BeanUtils; import org.springframework.beans.BeansException; import org.springframework.beans.TypeConverter; import org.springframework.beans.factory.BeanCreationException; import org.springframework.beans.factory.BeanCurrentlyInCreationException; import org.springframework.beans.factory.BeanDefinitionStoreException; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.BeanFactoryAware; import org.springframework.beans.factory.BeanFactoryUtils; import org.springframework.beans.factory.BeanNotOfRequiredTypeException; import org.springframework.beans.factory.CannotLoadBeanClassException; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.InjectionPoint; import org.springframework.beans.factory.NoSuchBeanDefinitionException; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.beans.factory.ObjectFactory; import org.springframework.beans.factory.ObjectProvider; import org.springframework.beans.factory.SmartFactoryBean; import org.springframework.beans.factory.SmartInitializingSingleton; import org.springframework.beans.factory.config.AutowireCapableBeanFactory; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.config.ConfigurableBeanFactory; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.config.DependencyDescriptor; import org.springframework.beans.factory.config.NamedBeanHolder; import org.springframework.core.OrderComparator; import org.springframework.core.ResolvableType; import org.springframework.core.annotation.AnnotationUtils; import org.springframework.lang.Nullable; import org.springframework.util.Assert; import org.springframework.util.ClassUtils; import org.springframework.util.CompositeIterator; import org.springframework.util.ObjectUtils; import org.springframework.util.StringUtils; /** * 基于bean definition对象的完整bean工厂 * * Default implementation of the * {@link org.springframework.beans.factory.ListableBeanFactory} and * {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory * based on bean definition objects. * * @author Rod Johnson * @author Juergen Hoeller * @author Sam Brannen * @author Costin Leau * @author Chris Beams * @author Phillip Webb * @author Stephane Nicoll * @since 16 April 2001 * @see StaticListableBeanFactory * @see PropertiesBeanDefinitionReader * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader */ @SuppressWarnings(&quot;serial&quot;) publicclass DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable { @Nullable privatestatic Class&lt;?&gt; javaxInjectProviderClass; static { try { javaxInjectProviderClass = ClassUtils.forName(&quot;javax.inject.Provider&quot;, DefaultListableBeanFactory.class.getClassLoader()); } catch (ClassNotFoundException ex) { // JSR-330 API not available - Provider interface simply not supported then. javaxInjectProviderClass = null; } } /** Map from serialized id to factory instance */privatestaticfinal Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories = new ConcurrentHashMap&lt;&gt;(8); /** Optional id for this factory, for serialization purposes */ @Nullable private String serializationId; /** Whether to allow re-registration of a different definition with the same name */privateboolean allowBeanDefinitionOverriding = true; /** Whether to allow eager class loading even for lazy-init beans */privateboolean allowEagerClassLoading = true; /** Optional OrderComparator for dependency Lists and arrays */ @Nullable private Comparator&lt;Object&gt; dependencyComparator; /** Resolver to use for checking if a bean definition is an autowire candidate */private AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver(); /** Map from dependency type to corresponding autowired value */privatefinal Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = new ConcurrentHashMap&lt;&gt;(16); /** Map of bean definition objects, keyed by bean name *///beanFactory持有此map,这样就可以在任何时候获取bean的BeanDefinition来创建一个bean实例privatefinal Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); /** Map of singleton and non-singleton bean names, keyed by dependency type */privatefinal Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = new ConcurrentHashMap&lt;&gt;(64); /** Map of singleton-only bean names, keyed by dependency type */privatefinal Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = new ConcurrentHashMap&lt;&gt;(64); /** List of bean definition names, in registration order */privatevolatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256); /** List of names of manually registered singletons, in registration order */privatevolatile Set&lt;String&gt; manualSingletonNames = new LinkedHashSet&lt;&gt;(16); /** Cached array of bean definition names in case of frozen configuration */ @Nullable privatevolatile String[] frozenBeanDefinitionNames; /** Whether bean definition metadata may be cached for all beans */privatevolatileboolean configurationFrozen = false; } DefaultListableBeanFactory类，这个类是默认的bean工厂实现类，这里只贴出了部分源码，完整的代码太长。我们来看其中的一行代码： /** Map of bean definition objects, keyed by bean name *///beanFactory持有此map,这样就可以在任何时候获取bean的BeanDefinition来创建一个bean实例privatefinal Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); 这行代码证明了我们的猜测，从方法是说明就可以看出这是bean定义的map对象，以bean的名称作为key。到这里思路就明确了，bean工厂的初始化就是往这个map对象里加东西，把我们xml文件里定义的bean填充到这个对象里，bean工厂就可以工作了。 那么怎样将xml文件配置的bean注册到这个map对象里呢？我们可以试试以下思路： 1、需要一个工具来找到xml配置文件，可以称之为资源定位； 2、需要一个Reader来读取xml配置信息，即DOM解析； 3、将读取出来的信息注册到map对象里。 以代码来验证一下，写一个Person类作为bean： publicclass Person { publicvoid work(){ System.out.println(&quot;I am working...&quot;); } } 创建一个applicationContext.xml配置文件，配置bean： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;com.springframework.bean.test.Person&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 接下来写个测试类： publicclass Client { publicstaticvoid main(String[] args) { ClassPathResource classPathResource = new ClassPathResource(&quot;applicationContext.xml&quot;); DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(defaultListableBeanFactory); beanDefinitionReader.loadBeanDefinitions(classPathResource); System.out.println(defaultListableBeanFactory.getBeanDefinitionCount()); Person person = (Person)defaultListableBeanFactory.getBean(&quot;person&quot;); person.work(); } } 执行结果如下： 七月 06, 2017 9:41:48 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [applicationContext.xml] 1 I am working... 从结果可以看出，我们成功解析了xml文件，并注册了一个bean定义，通过getBean()方法成功返回了一个实例。上面的测试类用4行代码实现了bean工厂的初始化： 第一行，完成了资源定位； 第二行，创建了一个默认的bean工厂； 第三行，创建了一个Reader，这个Reader用来读取xml文件，将创建的defaultListableBeanFactory 作为参数传递给Reader，表示为此工厂创建Reader； 第四行，用Reader读取配置信息，并将解析的bean定义注册到defaultListableBeanFactory 中。 执行完以上四个步骤，bean工厂酒杯正确初始化了，接下来我们可以调用工厂的方法，以及获得bean实例。 但是在实际开发中不会这么复杂，spring可以更简单的一步到位，它是这么做的： publicclass TestSpringBeanFactory { publicstaticvoid main(String[] args) { ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;src/applicationContext.xml&quot;); System.out.println(ctx.getBeanDefinitionCount()); Person person = (Person) ctx.getBean(&quot;person&quot;); person.work(); } } 我们看看执行结果： 七月 06, 2017 9:42:55 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh 信息: Refreshing org.springframework.context.support.FileSystemXmlApplicationContext@20ad9418: startup date [Thu Jul 06 21:42:55 CST 2017]; root of context hierarchy 七月 06, 2017 9:42:55 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from file [C:Usersfangfuhaiworkspacespring-code-learningsrcapplicationContext.xml] 1 I am working... 从结果可以看出，spring用一行代码就完成了我们四个步骤，仔细看看日志信息就可以发现，spring也是用XmlBeanDefinitionReader 来读取、解析并注册，同时在日志信息里还多了两行，这说明在这一行代码里，spring还做了更多的事情。 我们在new一个FileSystemXmlApplicationContext对象的时候，spring到底做了那些事情呢？下一章节我们来一探究竟。" />
<meta property="og:description" content="IOC(Inversion of Control)，即控制反转，意思是将对象的创建和依赖关系交给第三方容器处理，我们要用的时候告诉容器我们需要什么然后直接去拿就行了。举个例子，我们有一个工厂，它生产各种产品，当你需要某个产品，比如你需要一辆汽车，你就告诉工厂你需要一辆汽车，工厂就会直接返回给你一辆汽车，而不需要你自己通过付出劳动来得到这辆汽车，你也不用关心工厂是如何生产这辆汽车。对应到我们的程序中就是，IOC容器会帮我们创建和管理对象，当你告诉容器你需要某个对象时，容器会把这个对象返回给你，而不需要自己去new出一个对象来，对象的创建和管理会由容器自动进行，直接从容器中拿来用就可以了。IOC可以说是Spring最核心的思想，它使我们的开发变得简单（对象之间的依赖关系可以通过配置文件或者注解来创建），对于这种优秀的设计思想，我们当然有必要研究一下它的底层实现原理。 首先我们来关注一个接口，源码如下： package org.springframework.beans.factory; import org.springframework.beans.BeansException; import org.springframework.core.ResolvableType; import org.springframework.lang.Nullable; /** * * @author Rod Johnson * @author Juergen Hoeller * @author Chris Beams * @since 13 April 2001 * */publicinterface BeanFactory { String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); } 这个接口便是spring核心的bean工厂定义，它是IOC容器的顶层接口，spring中所有bean工厂都直接或间接的继承或实现了这个接口。我们平时使用的最多的ApplicationContext接口也继承了BeanFactory接口，因此它具有BeanFactory接口的所有功能，这里顺便提一下，从BeanFactory获取bean时，实例化BeanFactory容器并不会实例化所配置的bean，只有当使用某个bean(getBean)时，才会实时的实例化该bean；从ApplicationContext获取bean时，实例化ApplicationContext容器时会一并实例化容器中的所有的bean。 从BeanFactory的源码可以看出，它实现的核心功能就是根据名称或类型来返回一个bean实例。一个工厂如果要具备这种功能，结合工厂模式的思想，我们可以试想一下它需要具备以下几个条件： 1、持有各种bean的定义，只有拿到了bean的定义信息，才能根据这些信息进行实例化； 2、持有各种bean之间的依赖关系，如果一个类中持有对另一个类的引用，那么在对该类进行实例化时，必须根据类之间的依赖关系对相关类也进行实例化，因此，工厂必须获得类之间的依赖关系，否则无法正确实例化； 3、以上两种信息都依赖于我们的配置信息定义，比如xml配置文件，工厂需要一个工具来读取配置文件的信息。 以上是我们设想IOC的实现思路，只要满足以上三个条件，就能构造一个工厂，生产各种bean。但是我们还是有一些疑问，比如在第一个条件中，我们如何持有bean的定义呢？我们先来看另外一个接口： package org.springframework.beans.factory.config; import org.springframework.beans.BeanMetadataElement; import org.springframework.beans.MutablePropertyValues; import org.springframework.core.AttributeAccessor; import org.springframework.lang.Nullable; /** * 一个BeanDefinition描述一个bean实例具有的属性值，构造函数参数值，以及具体实现的进一步信息。 * * A BeanDefinition describes a bean instance, which has property values, * constructor argument values, and further information supplied by * concrete implementations. * * @author Juergen Hoeller * @author Rob Harrop * @since 19.03.2004 */publicinterface BeanDefinition extends AttributeAccessor, BeanMetadataElement { String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; int ROLE_APPLICATION = 0; int ROLE_SUPPORT = 1; int ROLE_INFRASTRUCTURE = 2; void setParentName(@Nullable String parentName); @Nullable String getParentName(); void setBeanClassName(@Nullable String beanClassName); @Nullable String getBeanClassName(); void setScope(@Nullable String scope); @Nullable String getScope(); void setLazyInit(boolean lazyInit); boolean isLazyInit(); /** * Set the names of the beans that this bean depends on being initialized. * The bean factory will guarantee that these beans get initialized first. */void setDependsOn(String... dependsOn); /** * Return the bean names that this bean depends on. */ @Nullable String[] getDependsOn(); void setAutowireCandidate(boolean autowireCandidate); boolean isAutowireCandidate(); void setPrimary(boolean primary); boolean isPrimary(); void setFactoryBeanName(@Nullable String factoryBeanName); @Nullable String getFactoryBeanName(); void setFactoryMethodName(@Nullable String factoryMethodName); @Nullable String getFactoryMethodName(); ConstructorArgumentValues getConstructorArgumentValues(); MutablePropertyValues getPropertyValues(); boolean isSingleton(); boolean isPrototype(); boolean isAbstract(); int getRole(); @Nullable String getDescription(); @Nullable String getResourceDescription(); @Nullable BeanDefinition getOriginatingBeanDefinition(); } BeanDefinition，顾名思义便是spring中的bean定义接口，spring的工厂里持有的就是此接口定义的内容。从源码可以看出，这个接口继承了两个另外两个接口，一个是AttributeAccessor接口，继承这个接口就意味着BeanDefinition接口拥有了处理属性的能力，另外一个接口是BeanMetedataElement，它可以获得bean的配置定义的元素，对于xml文件来说就是会持有bean的标签。从源码中我们可以看出，BeanDefinition接口定义了两个方法，分别是void setDependsOn(String… dependsOn)和String[] getDependsOn()，从方法的说明可以看出，这两个方法就是设置依赖的bean的名称和获取依赖的bean的名称，这就意味着只要我们有一个BeanDefinition，就能得到得到bean的定义信息和bean之间的依赖关系，从而可以生产一个完整的bean实例。 从上面两个接口，我们大致可以猜出spring是如何持有bean的定义信息及依赖关系了，没错，就是让bean工厂持有一个Map&lt;String，BeanDefinition&gt;，String型的beanName作为key，BeanDefinition型的bean定义作为value，这样就能生产一个bean实例。BeanFactory接口当然不能持有这个map对象，那么一定是在它的某个实现类里所持有的，我们找到了这个实现类，来看看源码： package org.springframework.beans.factory.support; import java.io.IOException; import java.io.NotSerializableException; import java.io.ObjectInputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.annotation.Annotation; import java.lang.ref.Reference; import java.lang.ref.WeakReference; import java.lang.reflect.Method; import java.security.AccessController; import java.security.PrivilegedAction; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.IdentityHashMap; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Optional; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import javax.inject.Provider; import org.springframework.beans.BeanUtils; import org.springframework.beans.BeansException; import org.springframework.beans.TypeConverter; import org.springframework.beans.factory.BeanCreationException; import org.springframework.beans.factory.BeanCurrentlyInCreationException; import org.springframework.beans.factory.BeanDefinitionStoreException; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.BeanFactoryAware; import org.springframework.beans.factory.BeanFactoryUtils; import org.springframework.beans.factory.BeanNotOfRequiredTypeException; import org.springframework.beans.factory.CannotLoadBeanClassException; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.InjectionPoint; import org.springframework.beans.factory.NoSuchBeanDefinitionException; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.beans.factory.ObjectFactory; import org.springframework.beans.factory.ObjectProvider; import org.springframework.beans.factory.SmartFactoryBean; import org.springframework.beans.factory.SmartInitializingSingleton; import org.springframework.beans.factory.config.AutowireCapableBeanFactory; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.config.ConfigurableBeanFactory; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.config.DependencyDescriptor; import org.springframework.beans.factory.config.NamedBeanHolder; import org.springframework.core.OrderComparator; import org.springframework.core.ResolvableType; import org.springframework.core.annotation.AnnotationUtils; import org.springframework.lang.Nullable; import org.springframework.util.Assert; import org.springframework.util.ClassUtils; import org.springframework.util.CompositeIterator; import org.springframework.util.ObjectUtils; import org.springframework.util.StringUtils; /** * 基于bean definition对象的完整bean工厂 * * Default implementation of the * {@link org.springframework.beans.factory.ListableBeanFactory} and * {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory * based on bean definition objects. * * @author Rod Johnson * @author Juergen Hoeller * @author Sam Brannen * @author Costin Leau * @author Chris Beams * @author Phillip Webb * @author Stephane Nicoll * @since 16 April 2001 * @see StaticListableBeanFactory * @see PropertiesBeanDefinitionReader * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader */ @SuppressWarnings(&quot;serial&quot;) publicclass DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable { @Nullable privatestatic Class&lt;?&gt; javaxInjectProviderClass; static { try { javaxInjectProviderClass = ClassUtils.forName(&quot;javax.inject.Provider&quot;, DefaultListableBeanFactory.class.getClassLoader()); } catch (ClassNotFoundException ex) { // JSR-330 API not available - Provider interface simply not supported then. javaxInjectProviderClass = null; } } /** Map from serialized id to factory instance */privatestaticfinal Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories = new ConcurrentHashMap&lt;&gt;(8); /** Optional id for this factory, for serialization purposes */ @Nullable private String serializationId; /** Whether to allow re-registration of a different definition with the same name */privateboolean allowBeanDefinitionOverriding = true; /** Whether to allow eager class loading even for lazy-init beans */privateboolean allowEagerClassLoading = true; /** Optional OrderComparator for dependency Lists and arrays */ @Nullable private Comparator&lt;Object&gt; dependencyComparator; /** Resolver to use for checking if a bean definition is an autowire candidate */private AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver(); /** Map from dependency type to corresponding autowired value */privatefinal Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = new ConcurrentHashMap&lt;&gt;(16); /** Map of bean definition objects, keyed by bean name *///beanFactory持有此map,这样就可以在任何时候获取bean的BeanDefinition来创建一个bean实例privatefinal Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); /** Map of singleton and non-singleton bean names, keyed by dependency type */privatefinal Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = new ConcurrentHashMap&lt;&gt;(64); /** Map of singleton-only bean names, keyed by dependency type */privatefinal Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = new ConcurrentHashMap&lt;&gt;(64); /** List of bean definition names, in registration order */privatevolatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256); /** List of names of manually registered singletons, in registration order */privatevolatile Set&lt;String&gt; manualSingletonNames = new LinkedHashSet&lt;&gt;(16); /** Cached array of bean definition names in case of frozen configuration */ @Nullable privatevolatile String[] frozenBeanDefinitionNames; /** Whether bean definition metadata may be cached for all beans */privatevolatileboolean configurationFrozen = false; } DefaultListableBeanFactory类，这个类是默认的bean工厂实现类，这里只贴出了部分源码，完整的代码太长。我们来看其中的一行代码： /** Map of bean definition objects, keyed by bean name *///beanFactory持有此map,这样就可以在任何时候获取bean的BeanDefinition来创建一个bean实例privatefinal Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); 这行代码证明了我们的猜测，从方法是说明就可以看出这是bean定义的map对象，以bean的名称作为key。到这里思路就明确了，bean工厂的初始化就是往这个map对象里加东西，把我们xml文件里定义的bean填充到这个对象里，bean工厂就可以工作了。 那么怎样将xml文件配置的bean注册到这个map对象里呢？我们可以试试以下思路： 1、需要一个工具来找到xml配置文件，可以称之为资源定位； 2、需要一个Reader来读取xml配置信息，即DOM解析； 3、将读取出来的信息注册到map对象里。 以代码来验证一下，写一个Person类作为bean： publicclass Person { publicvoid work(){ System.out.println(&quot;I am working...&quot;); } } 创建一个applicationContext.xml配置文件，配置bean： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;com.springframework.bean.test.Person&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 接下来写个测试类： publicclass Client { publicstaticvoid main(String[] args) { ClassPathResource classPathResource = new ClassPathResource(&quot;applicationContext.xml&quot;); DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(defaultListableBeanFactory); beanDefinitionReader.loadBeanDefinitions(classPathResource); System.out.println(defaultListableBeanFactory.getBeanDefinitionCount()); Person person = (Person)defaultListableBeanFactory.getBean(&quot;person&quot;); person.work(); } } 执行结果如下： 七月 06, 2017 9:41:48 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [applicationContext.xml] 1 I am working... 从结果可以看出，我们成功解析了xml文件，并注册了一个bean定义，通过getBean()方法成功返回了一个实例。上面的测试类用4行代码实现了bean工厂的初始化： 第一行，完成了资源定位； 第二行，创建了一个默认的bean工厂； 第三行，创建了一个Reader，这个Reader用来读取xml文件，将创建的defaultListableBeanFactory 作为参数传递给Reader，表示为此工厂创建Reader； 第四行，用Reader读取配置信息，并将解析的bean定义注册到defaultListableBeanFactory 中。 执行完以上四个步骤，bean工厂酒杯正确初始化了，接下来我们可以调用工厂的方法，以及获得bean实例。 但是在实际开发中不会这么复杂，spring可以更简单的一步到位，它是这么做的： publicclass TestSpringBeanFactory { publicstaticvoid main(String[] args) { ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;src/applicationContext.xml&quot;); System.out.println(ctx.getBeanDefinitionCount()); Person person = (Person) ctx.getBean(&quot;person&quot;); person.work(); } } 我们看看执行结果： 七月 06, 2017 9:42:55 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh 信息: Refreshing org.springframework.context.support.FileSystemXmlApplicationContext@20ad9418: startup date [Thu Jul 06 21:42:55 CST 2017]; root of context hierarchy 七月 06, 2017 9:42:55 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from file [C:Usersfangfuhaiworkspacespring-code-learningsrcapplicationContext.xml] 1 I am working... 从结果可以看出，spring用一行代码就完成了我们四个步骤，仔细看看日志信息就可以发现，spring也是用XmlBeanDefinitionReader 来读取、解析并注册，同时在日志信息里还多了两行，这说明在这一行代码里，spring还做了更多的事情。 我们在new一个FileSystemXmlApplicationContext对象的时候，spring到底做了那些事情呢？下一章节我们来一探究竟。" />
<link rel="canonical" href="http://www.jfox.info/2017/spring%E6%BA%90%E7%A0%81ioc%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%80.html" />
<meta property="og:url" content="http://www.jfox.info/2017/spring%E6%BA%90%E7%A0%81ioc%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%80.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T15:53:55+00:00" />
<script type="application/ld+json">
{"description":"IOC(Inversion of Control)，即控制反转，意思是将对象的创建和依赖关系交给第三方容器处理，我们要用的时候告诉容器我们需要什么然后直接去拿就行了。举个例子，我们有一个工厂，它生产各种产品，当你需要某个产品，比如你需要一辆汽车，你就告诉工厂你需要一辆汽车，工厂就会直接返回给你一辆汽车，而不需要你自己通过付出劳动来得到这辆汽车，你也不用关心工厂是如何生产这辆汽车。对应到我们的程序中就是，IOC容器会帮我们创建和管理对象，当你告诉容器你需要某个对象时，容器会把这个对象返回给你，而不需要自己去new出一个对象来，对象的创建和管理会由容器自动进行，直接从容器中拿来用就可以了。IOC可以说是Spring最核心的思想，它使我们的开发变得简单（对象之间的依赖关系可以通过配置文件或者注解来创建），对于这种优秀的设计思想，我们当然有必要研究一下它的底层实现原理。 首先我们来关注一个接口，源码如下： package org.springframework.beans.factory; import org.springframework.beans.BeansException; import org.springframework.core.ResolvableType; import org.springframework.lang.Nullable; /** * * @author Rod Johnson * @author Juergen Hoeller * @author Chris Beams * @since 13 April 2001 * */publicinterface BeanFactory { String FACTORY_BEAN_PREFIX = &quot;&amp;&quot;; Object getBean(String name) throws BeansException; &lt;T&gt; T getBean(String name, @Nullable Class&lt;T&gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType) throws BeansException; &lt;T&gt; T getBean(Class&lt;T&gt; requiredType, Object... args) throws BeansException; boolean containsBean(String name); boolean isSingleton(String name) throws NoSuchBeanDefinitionException; boolean isPrototype(String name) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, ResolvableType typeToMatch) throws NoSuchBeanDefinitionException; boolean isTypeMatch(String name, @Nullable Class&lt;?&gt; typeToMatch) throws NoSuchBeanDefinitionException; @Nullable Class&lt;?&gt; getType(String name) throws NoSuchBeanDefinitionException; String[] getAliases(String name); } 这个接口便是spring核心的bean工厂定义，它是IOC容器的顶层接口，spring中所有bean工厂都直接或间接的继承或实现了这个接口。我们平时使用的最多的ApplicationContext接口也继承了BeanFactory接口，因此它具有BeanFactory接口的所有功能，这里顺便提一下，从BeanFactory获取bean时，实例化BeanFactory容器并不会实例化所配置的bean，只有当使用某个bean(getBean)时，才会实时的实例化该bean；从ApplicationContext获取bean时，实例化ApplicationContext容器时会一并实例化容器中的所有的bean。 从BeanFactory的源码可以看出，它实现的核心功能就是根据名称或类型来返回一个bean实例。一个工厂如果要具备这种功能，结合工厂模式的思想，我们可以试想一下它需要具备以下几个条件： 1、持有各种bean的定义，只有拿到了bean的定义信息，才能根据这些信息进行实例化； 2、持有各种bean之间的依赖关系，如果一个类中持有对另一个类的引用，那么在对该类进行实例化时，必须根据类之间的依赖关系对相关类也进行实例化，因此，工厂必须获得类之间的依赖关系，否则无法正确实例化； 3、以上两种信息都依赖于我们的配置信息定义，比如xml配置文件，工厂需要一个工具来读取配置文件的信息。 以上是我们设想IOC的实现思路，只要满足以上三个条件，就能构造一个工厂，生产各种bean。但是我们还是有一些疑问，比如在第一个条件中，我们如何持有bean的定义呢？我们先来看另外一个接口： package org.springframework.beans.factory.config; import org.springframework.beans.BeanMetadataElement; import org.springframework.beans.MutablePropertyValues; import org.springframework.core.AttributeAccessor; import org.springframework.lang.Nullable; /** * 一个BeanDefinition描述一个bean实例具有的属性值，构造函数参数值，以及具体实现的进一步信息。 * * A BeanDefinition describes a bean instance, which has property values, * constructor argument values, and further information supplied by * concrete implementations. * * @author Juergen Hoeller * @author Rob Harrop * @since 19.03.2004 */publicinterface BeanDefinition extends AttributeAccessor, BeanMetadataElement { String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; int ROLE_APPLICATION = 0; int ROLE_SUPPORT = 1; int ROLE_INFRASTRUCTURE = 2; void setParentName(@Nullable String parentName); @Nullable String getParentName(); void setBeanClassName(@Nullable String beanClassName); @Nullable String getBeanClassName(); void setScope(@Nullable String scope); @Nullable String getScope(); void setLazyInit(boolean lazyInit); boolean isLazyInit(); /** * Set the names of the beans that this bean depends on being initialized. * The bean factory will guarantee that these beans get initialized first. */void setDependsOn(String... dependsOn); /** * Return the bean names that this bean depends on. */ @Nullable String[] getDependsOn(); void setAutowireCandidate(boolean autowireCandidate); boolean isAutowireCandidate(); void setPrimary(boolean primary); boolean isPrimary(); void setFactoryBeanName(@Nullable String factoryBeanName); @Nullable String getFactoryBeanName(); void setFactoryMethodName(@Nullable String factoryMethodName); @Nullable String getFactoryMethodName(); ConstructorArgumentValues getConstructorArgumentValues(); MutablePropertyValues getPropertyValues(); boolean isSingleton(); boolean isPrototype(); boolean isAbstract(); int getRole(); @Nullable String getDescription(); @Nullable String getResourceDescription(); @Nullable BeanDefinition getOriginatingBeanDefinition(); } BeanDefinition，顾名思义便是spring中的bean定义接口，spring的工厂里持有的就是此接口定义的内容。从源码可以看出，这个接口继承了两个另外两个接口，一个是AttributeAccessor接口，继承这个接口就意味着BeanDefinition接口拥有了处理属性的能力，另外一个接口是BeanMetedataElement，它可以获得bean的配置定义的元素，对于xml文件来说就是会持有bean的标签。从源码中我们可以看出，BeanDefinition接口定义了两个方法，分别是void setDependsOn(String… dependsOn)和String[] getDependsOn()，从方法的说明可以看出，这两个方法就是设置依赖的bean的名称和获取依赖的bean的名称，这就意味着只要我们有一个BeanDefinition，就能得到得到bean的定义信息和bean之间的依赖关系，从而可以生产一个完整的bean实例。 从上面两个接口，我们大致可以猜出spring是如何持有bean的定义信息及依赖关系了，没错，就是让bean工厂持有一个Map&lt;String，BeanDefinition&gt;，String型的beanName作为key，BeanDefinition型的bean定义作为value，这样就能生产一个bean实例。BeanFactory接口当然不能持有这个map对象，那么一定是在它的某个实现类里所持有的，我们找到了这个实现类，来看看源码： package org.springframework.beans.factory.support; import java.io.IOException; import java.io.NotSerializableException; import java.io.ObjectInputStream; import java.io.ObjectStreamException; import java.io.Serializable; import java.lang.annotation.Annotation; import java.lang.ref.Reference; import java.lang.ref.WeakReference; import java.lang.reflect.Method; import java.security.AccessController; import java.security.PrivilegedAction; import java.util.ArrayList; import java.util.Arrays; import java.util.Collection; import java.util.Collections; import java.util.Comparator; import java.util.IdentityHashMap; import java.util.Iterator; import java.util.LinkedHashMap; import java.util.LinkedHashSet; import java.util.List; import java.util.Map; import java.util.Optional; import java.util.Set; import java.util.concurrent.ConcurrentHashMap; import javax.inject.Provider; import org.springframework.beans.BeanUtils; import org.springframework.beans.BeansException; import org.springframework.beans.TypeConverter; import org.springframework.beans.factory.BeanCreationException; import org.springframework.beans.factory.BeanCurrentlyInCreationException; import org.springframework.beans.factory.BeanDefinitionStoreException; import org.springframework.beans.factory.BeanFactory; import org.springframework.beans.factory.BeanFactoryAware; import org.springframework.beans.factory.BeanFactoryUtils; import org.springframework.beans.factory.BeanNotOfRequiredTypeException; import org.springframework.beans.factory.CannotLoadBeanClassException; import org.springframework.beans.factory.FactoryBean; import org.springframework.beans.factory.InjectionPoint; import org.springframework.beans.factory.NoSuchBeanDefinitionException; import org.springframework.beans.factory.NoUniqueBeanDefinitionException; import org.springframework.beans.factory.ObjectFactory; import org.springframework.beans.factory.ObjectProvider; import org.springframework.beans.factory.SmartFactoryBean; import org.springframework.beans.factory.SmartInitializingSingleton; import org.springframework.beans.factory.config.AutowireCapableBeanFactory; import org.springframework.beans.factory.config.BeanDefinition; import org.springframework.beans.factory.config.BeanDefinitionHolder; import org.springframework.beans.factory.config.ConfigurableBeanFactory; import org.springframework.beans.factory.config.ConfigurableListableBeanFactory; import org.springframework.beans.factory.config.DependencyDescriptor; import org.springframework.beans.factory.config.NamedBeanHolder; import org.springframework.core.OrderComparator; import org.springframework.core.ResolvableType; import org.springframework.core.annotation.AnnotationUtils; import org.springframework.lang.Nullable; import org.springframework.util.Assert; import org.springframework.util.ClassUtils; import org.springframework.util.CompositeIterator; import org.springframework.util.ObjectUtils; import org.springframework.util.StringUtils; /** * 基于bean definition对象的完整bean工厂 * * Default implementation of the * {@link org.springframework.beans.factory.ListableBeanFactory} and * {@link BeanDefinitionRegistry} interfaces: a full-fledged bean factory * based on bean definition objects. * * @author Rod Johnson * @author Juergen Hoeller * @author Sam Brannen * @author Costin Leau * @author Chris Beams * @author Phillip Webb * @author Stephane Nicoll * @since 16 April 2001 * @see StaticListableBeanFactory * @see PropertiesBeanDefinitionReader * @see org.springframework.beans.factory.xml.XmlBeanDefinitionReader */ @SuppressWarnings(&quot;serial&quot;) publicclass DefaultListableBeanFactory extends AbstractAutowireCapableBeanFactory implements ConfigurableListableBeanFactory, BeanDefinitionRegistry, Serializable { @Nullable privatestatic Class&lt;?&gt; javaxInjectProviderClass; static { try { javaxInjectProviderClass = ClassUtils.forName(&quot;javax.inject.Provider&quot;, DefaultListableBeanFactory.class.getClassLoader()); } catch (ClassNotFoundException ex) { // JSR-330 API not available - Provider interface simply not supported then. javaxInjectProviderClass = null; } } /** Map from serialized id to factory instance */privatestaticfinal Map&lt;String, Reference&lt;DefaultListableBeanFactory&gt;&gt; serializableFactories = new ConcurrentHashMap&lt;&gt;(8); /** Optional id for this factory, for serialization purposes */ @Nullable private String serializationId; /** Whether to allow re-registration of a different definition with the same name */privateboolean allowBeanDefinitionOverriding = true; /** Whether to allow eager class loading even for lazy-init beans */privateboolean allowEagerClassLoading = true; /** Optional OrderComparator for dependency Lists and arrays */ @Nullable private Comparator&lt;Object&gt; dependencyComparator; /** Resolver to use for checking if a bean definition is an autowire candidate */private AutowireCandidateResolver autowireCandidateResolver = new SimpleAutowireCandidateResolver(); /** Map from dependency type to corresponding autowired value */privatefinal Map&lt;Class&lt;?&gt;, Object&gt; resolvableDependencies = new ConcurrentHashMap&lt;&gt;(16); /** Map of bean definition objects, keyed by bean name *///beanFactory持有此map,这样就可以在任何时候获取bean的BeanDefinition来创建一个bean实例privatefinal Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); /** Map of singleton and non-singleton bean names, keyed by dependency type */privatefinal Map&lt;Class&lt;?&gt;, String[]&gt; allBeanNamesByType = new ConcurrentHashMap&lt;&gt;(64); /** Map of singleton-only bean names, keyed by dependency type */privatefinal Map&lt;Class&lt;?&gt;, String[]&gt; singletonBeanNamesByType = new ConcurrentHashMap&lt;&gt;(64); /** List of bean definition names, in registration order */privatevolatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;&gt;(256); /** List of names of manually registered singletons, in registration order */privatevolatile Set&lt;String&gt; manualSingletonNames = new LinkedHashSet&lt;&gt;(16); /** Cached array of bean definition names in case of frozen configuration */ @Nullable privatevolatile String[] frozenBeanDefinitionNames; /** Whether bean definition metadata may be cached for all beans */privatevolatileboolean configurationFrozen = false; } DefaultListableBeanFactory类，这个类是默认的bean工厂实现类，这里只贴出了部分源码，完整的代码太长。我们来看其中的一行代码： /** Map of bean definition objects, keyed by bean name *///beanFactory持有此map,这样就可以在任何时候获取bean的BeanDefinition来创建一个bean实例privatefinal Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;&gt;(256); 这行代码证明了我们的猜测，从方法是说明就可以看出这是bean定义的map对象，以bean的名称作为key。到这里思路就明确了，bean工厂的初始化就是往这个map对象里加东西，把我们xml文件里定义的bean填充到这个对象里，bean工厂就可以工作了。 那么怎样将xml文件配置的bean注册到这个map对象里呢？我们可以试试以下思路： 1、需要一个工具来找到xml配置文件，可以称之为资源定位； 2、需要一个Reader来读取xml配置信息，即DOM解析； 3、将读取出来的信息注册到map对象里。 以代码来验证一下，写一个Person类作为bean： publicclass Person { publicvoid work(){ System.out.println(&quot;I am working...&quot;); } } 创建一个applicationContext.xml配置文件，配置bean： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;person&quot; class=&quot;com.springframework.bean.test.Person&quot;&gt;&lt;/bean&gt; &lt;/beans&gt; 接下来写个测试类： publicclass Client { publicstaticvoid main(String[] args) { ClassPathResource classPathResource = new ClassPathResource(&quot;applicationContext.xml&quot;); DefaultListableBeanFactory defaultListableBeanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(defaultListableBeanFactory); beanDefinitionReader.loadBeanDefinitions(classPathResource); System.out.println(defaultListableBeanFactory.getBeanDefinitionCount()); Person person = (Person)defaultListableBeanFactory.getBean(&quot;person&quot;); person.work(); } } 执行结果如下： 七月 06, 2017 9:41:48 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from class path resource [applicationContext.xml] 1 I am working... 从结果可以看出，我们成功解析了xml文件，并注册了一个bean定义，通过getBean()方法成功返回了一个实例。上面的测试类用4行代码实现了bean工厂的初始化： 第一行，完成了资源定位； 第二行，创建了一个默认的bean工厂； 第三行，创建了一个Reader，这个Reader用来读取xml文件，将创建的defaultListableBeanFactory 作为参数传递给Reader，表示为此工厂创建Reader； 第四行，用Reader读取配置信息，并将解析的bean定义注册到defaultListableBeanFactory 中。 执行完以上四个步骤，bean工厂酒杯正确初始化了，接下来我们可以调用工厂的方法，以及获得bean实例。 但是在实际开发中不会这么复杂，spring可以更简单的一步到位，它是这么做的： publicclass TestSpringBeanFactory { publicstaticvoid main(String[] args) { ApplicationContext ctx = new FileSystemXmlApplicationContext(&quot;src/applicationContext.xml&quot;); System.out.println(ctx.getBeanDefinitionCount()); Person person = (Person) ctx.getBean(&quot;person&quot;); person.work(); } } 我们看看执行结果： 七月 06, 2017 9:42:55 下午 org.springframework.context.support.AbstractApplicationContext prepareRefresh 信息: Refreshing org.springframework.context.support.FileSystemXmlApplicationContext@20ad9418: startup date [Thu Jul 06 21:42:55 CST 2017]; root of context hierarchy 七月 06, 2017 9:42:55 下午 org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitions 信息: Loading XML bean definitions from file [C:Usersfangfuhaiworkspacespring-code-learningsrcapplicationContext.xml] 1 I am working... 从结果可以看出，spring用一行代码就完成了我们四个步骤，仔细看看日志信息就可以发现，spring也是用XmlBeanDefinitionReader 来读取、解析并注册，同时在日志信息里还多了两行，这说明在这一行代码里，spring还做了更多的事情。 我们在new一个FileSystemXmlApplicationContext对象的时候，spring到底做了那些事情呢？下一章节我们来一探究竟。","@type":"BlogPosting","url":"http://www.jfox.info/2017/spring%E6%BA%90%E7%A0%81ioc%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%80.html","headline":"Spring源码：IOC原理解析（一）","dateModified":"2017-01-01T15:53:55+00:00","datePublished":"2017-01-01T15:53:55+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/spring%E6%BA%90%E7%A0%81ioc%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%80.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Spring源码：IOC原理解析（一）</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T15:53:55+00:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>IOC(Inversion of Control)，即控制反转，意思是将对象的创建和依赖关系交给第三方容器处理，我们要用的时候告诉容器我们需要什么然后直接去拿就行了。举个例子，我们有一个工厂，它生产各种产品，当你需要某个产品，比如你需要一辆汽车，你就告诉工厂你需要一辆汽车，工厂就会直接返回给你一辆汽车，而不需要你自己通过付出劳动来得到这辆汽车，你也不用关心工厂是如何生产这辆汽车。对应到我们的程序中就是，IOC容器会帮我们创建和管理对象，当你告诉容器你需要某个对象时，容器会把这个对象返回给你，而不需要自己去new出一个对象来，对象的创建和管理会由容器自动进行，直接从容器中拿来用就可以了。IOC可以说是Spring最核心的思想，它使我们的开发变得简单（对象之间的依赖关系可以通过配置文件或者注解来创建），对于这种优秀的设计思想，我们当然有必要研究一下它的底层实现原理。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="err">首先我们来关注一个接口，源码如下：</span>     

<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">BeansException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">ResolvableType</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">Nullable</span><span class="p">;</span>

<span class="p">/**</span>
 <span class="p">*</span> 
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Rod</span> <span class="n">Johnson</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Juergen</span> <span class="n">Hoeller</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Chris</span> <span class="n">Beams</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">since</span> <span class="m">13</span> <span class="n">April</span> <span class="m">2001</span>
 <span class="p">*</span> 
 <span class="p">*/</span><span class="n">publicinterface</span> <span class="n">BeanFactory</span> <span class="p">{</span>

    
    <span class="k">String</span> <span class="n">FACTORY_BEAN_PREFIX</span> <span class="p">=</span> <span class="s2">"&amp;"</span><span class="p">;</span>


    
    <span class="n">Object</span> <span class="n">getBean</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">)</span> <span class="n">throws</span> <span class="n">BeansException</span><span class="p">;</span>

    
    <span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">T</span> <span class="n">getBean</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">,</span> <span class="p">@</span><span class="n">Nullable</span> <span class="n">Class</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">requiredType</span><span class="p">)</span> <span class="n">throws</span> <span class="n">BeansException</span><span class="p">;</span>

    
    <span class="n">Object</span> <span class="n">getBean</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">,</span> <span class="n">Object</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="n">throws</span> <span class="n">BeansException</span><span class="p">;</span>

    
    <span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">T</span> <span class="n">getBean</span><span class="p">(</span><span class="n">Class</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">requiredType</span><span class="p">)</span> <span class="n">throws</span> <span class="n">BeansException</span><span class="p">;</span>

    
    <span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">T</span> <span class="n">getBean</span><span class="p">(</span><span class="n">Class</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">requiredType</span><span class="p">,</span> <span class="n">Object</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="n">throws</span> <span class="n">BeansException</span><span class="p">;</span>


    
    <span class="k">boolean</span> <span class="n">containsBean</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">);</span>

    
    <span class="k">boolean</span> <span class="n">isSingleton</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">)</span> <span class="n">throws</span> <span class="n">NoSuchBeanDefinitionException</span><span class="p">;</span>

    
    <span class="k">boolean</span> <span class="n">isPrototype</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">)</span> <span class="n">throws</span> <span class="n">NoSuchBeanDefinitionException</span><span class="p">;</span>

    
    <span class="k">boolean</span> <span class="n">isTypeMatch</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">,</span> <span class="n">ResolvableType</span> <span class="n">typeToMatch</span><span class="p">)</span> <span class="n">throws</span> <span class="n">NoSuchBeanDefinitionException</span><span class="p">;</span>

    
    <span class="k">boolean</span> <span class="n">isTypeMatch</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">,</span> <span class="p">@</span><span class="n">Nullable</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">typeToMatch</span><span class="p">)</span> <span class="n">throws</span> <span class="n">NoSuchBeanDefinitionException</span><span class="p">;</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">getType</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">)</span> <span class="n">throws</span> <span class="n">NoSuchBeanDefinitionException</span><span class="p">;</span>

    
    <span class="k">String</span><span class="p">[]</span> <span class="nf">getAliases</span><span class="p">(</span><span class="k">String</span> <span class="n">name</span><span class="p">);</span>

<span class="p">}</span>

   <span class="err">这个接口便是</span><span class="n">spring</span><span class="err">核心的</span><span class="n">bean</span><span class="err">工厂定义，它是</span><span class="n">IOC</span><span class="err">容器的顶层接口，</span><span class="n">spring</span><span class="err">中所有</span><span class="n">bean</span><span class="err">工厂都直接或间接的继承或实现了这个接口。我们平时使用的最多的</span><span class="n">ApplicationContext</span><span class="err">接口也继承了</span><span class="n">BeanFactory</span><span class="err">接口，因此它具有</span><span class="n">BeanFactory</span><span class="err">接口的所有功能，这里顺便提一下，从</span><span class="n">BeanFactory</span><span class="err">获取</span><span class="n">bean</span><span class="err">时，实例化</span><span class="n">BeanFactory</span><span class="err">容器并不会实例化所配置的</span><span class="n">bean</span><span class="err">，只有当使用某个</span><span class="n">bean</span><span class="p">(</span><span class="n">getBean</span><span class="p">)</span><span class="err">时，才会实时的实例化该</span><span class="n">bean</span><span class="err">；从</span><span class="n">ApplicationContext</span><span class="err">获取</span><span class="n">bean</span><span class="err">时，实例化</span><span class="n">ApplicationContext</span><span class="err">容器时会一并实例化容器中的所有的</span><span class="n">bean</span><span class="err">。</span>

   <span class="err">从</span><span class="n">BeanFactory</span><span class="err">的源码可以看出，它实现的核心功能就是根据名称或类型来返回一个</span><span class="n">bean</span><span class="err">实例。一个工厂如果要具备这种功能，结合工厂模式的思想，我们可以试想一下它需要具备以下几个条件：</span>

   <span class="m">1</span><span class="err">、持有各种</span><span class="n">bean</span><span class="err">的定义，只有拿到了</span><span class="n">bean</span><span class="err">的定义信息，才能根据这些信息进行实例化；</span>

   <span class="m">2</span><span class="err">、持有各种</span><span class="n">bean</span><span class="err">之间的依赖关系，如果一个类中持有对另一个类的引用，那么在对该类进行实例化时，必须根据类之间的依赖关系对相关类也进行实例化，因此，工厂必须获得类之间的依赖关系，否则无法正确实例化；</span>

   <span class="m">3</span><span class="err">、以上两种信息都依赖于我们的配置信息定义，比如</span><span class="n">xml</span><span class="err">配置文件，工厂需要一个工具来读取配置文件的信息。</span>

   <span class="err">以上是我们设想</span><span class="n">IOC</span><span class="err">的实现思路，只要满足以上三个条件，就能构造一个工厂，生产各种</span><span class="n">bean</span><span class="err">。但是我们还是有一些疑问，比如在第一个条件中，我们如何持有</span><span class="n">bean</span><span class="err">的定义呢？我们先来看另外一个接口：</span>        

<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">BeanMetadataElement</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">MutablePropertyValues</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">AttributeAccessor</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">Nullable</span><span class="p">;</span>

<span class="p">/**</span>
 <span class="p">*</span> <span class="err">一个</span><span class="n">BeanDefinition</span><span class="err">描述一个</span><span class="n">bean</span><span class="err">实例具有的属性值，构造函数参数值，以及具体实现的进一步信息。</span>
 <span class="p">*</span> 
 <span class="p">*</span> <span class="n">A</span> <span class="n">BeanDefinition</span> <span class="n">describes</span> <span class="n">a</span> <span class="n">bean</span> <span class="n">instance</span><span class="p">,</span> <span class="n">which</span> <span class="n">has</span> <span class="n">property</span> <span class="n">values</span><span class="p">,</span>
 <span class="p">*</span> <span class="n">constructor</span> <span class="n">argument</span> <span class="n">values</span><span class="p">,</span> <span class="k">and</span> <span class="n">further</span> <span class="n">information</span> <span class="n">supplied</span> <span class="n">by</span>
 <span class="p">*</span> <span class="n">concrete</span> <span class="n">implementations</span><span class="p">.</span>
 <span class="p">*</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Juergen</span> <span class="n">Hoeller</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Rob</span> <span class="n">Harrop</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">since</span> <span class="m">19.03.2004</span>
 <span class="p">*/</span><span class="n">publicinterface</span> <span class="n">BeanDefinition</span> <span class="n">extends</span> <span class="n">AttributeAccessor</span><span class="p">,</span> <span class="n">BeanMetadataElement</span> <span class="p">{</span>

    
    <span class="k">String</span> <span class="n">SCOPE_SINGLETON</span> <span class="p">=</span> <span class="n">ConfigurableBeanFactory</span><span class="p">.</span><span class="n">SCOPE_SINGLETON</span><span class="p">;</span>

    
    <span class="k">String</span> <span class="n">SCOPE_PROTOTYPE</span> <span class="p">=</span> <span class="n">ConfigurableBeanFactory</span><span class="p">.</span><span class="n">SCOPE_PROTOTYPE</span><span class="p">;</span>


    <span class="n">int</span> <span class="n">ROLE_APPLICATION</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

    
    <span class="n">int</span> <span class="n">ROLE_SUPPORT</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>

    
    <span class="n">int</span> <span class="n">ROLE_INFRASTRUCTURE</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>


    <span class="n">void</span> <span class="n">setParentName</span><span class="p">(@</span><span class="n">Nullable</span> <span class="k">String</span> <span class="n">parentName</span><span class="p">);</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="k">String</span> <span class="n">getParentName</span><span class="p">();</span>

    
    <span class="n">void</span> <span class="n">setBeanClassName</span><span class="p">(@</span><span class="n">Nullable</span> <span class="k">String</span> <span class="n">beanClassName</span><span class="p">);</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="k">String</span> <span class="n">getBeanClassName</span><span class="p">();</span>

    
    <span class="n">void</span> <span class="n">setScope</span><span class="p">(@</span><span class="n">Nullable</span> <span class="k">String</span> <span class="n">scope</span><span class="p">);</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="k">String</span> <span class="n">getScope</span><span class="p">();</span>

    
    <span class="n">void</span> <span class="n">setLazyInit</span><span class="p">(</span><span class="k">boolean</span> <span class="n">lazyInit</span><span class="p">);</span>

    
    <span class="k">boolean</span> <span class="n">isLazyInit</span><span class="p">();</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="k">Set</span> <span class="n">the</span> <span class="n">names</span> <span class="k">of</span> <span class="n">the</span> <span class="n">beans</span> <span class="n">that</span> <span class="n">this</span> <span class="n">bean</span> <span class="n">depends</span> <span class="n">on</span> <span class="n">being</span> <span class="n">initialized</span><span class="p">.</span>
     <span class="p">*</span> <span class="n">The</span> <span class="n">bean</span> <span class="n">factory</span> <span class="n">will</span> <span class="n">guarantee</span> <span class="n">that</span> <span class="n">these</span> <span class="n">beans</span> <span class="n">get</span> <span class="n">initialized</span> <span class="n">first</span><span class="p">.</span>
     <span class="p">*/</span><span class="n">void</span> <span class="n">setDependsOn</span><span class="p">(</span><span class="k">String</span><span class="p">...</span> <span class="n">dependsOn</span><span class="p">);</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">Return</span> <span class="n">the</span> <span class="n">bean</span> <span class="n">names</span> <span class="n">that</span> <span class="n">this</span> <span class="n">bean</span> <span class="n">depends</span> <span class="n">on</span><span class="p">.</span>
     <span class="p">*/</span>
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="k">String</span><span class="p">[]</span> <span class="n">getDependsOn</span><span class="p">();</span>

    
    <span class="n">void</span> <span class="n">setAutowireCandidate</span><span class="p">(</span><span class="k">boolean</span> <span class="n">autowireCandidate</span><span class="p">);</span>

    
    <span class="k">boolean</span> <span class="n">isAutowireCandidate</span><span class="p">();</span>

    
    <span class="n">void</span> <span class="n">setPrimary</span><span class="p">(</span><span class="k">boolean</span> <span class="n">primary</span><span class="p">);</span>

    
    <span class="k">boolean</span> <span class="n">isPrimary</span><span class="p">();</span>

    
    <span class="n">void</span> <span class="n">setFactoryBeanName</span><span class="p">(@</span><span class="n">Nullable</span> <span class="k">String</span> <span class="n">factoryBeanName</span><span class="p">);</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="k">String</span> <span class="n">getFactoryBeanName</span><span class="p">();</span>

    
    <span class="n">void</span> <span class="n">setFactoryMethodName</span><span class="p">(@</span><span class="n">Nullable</span> <span class="k">String</span> <span class="n">factoryMethodName</span><span class="p">);</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="k">String</span> <span class="n">getFactoryMethodName</span><span class="p">();</span>

    
    <span class="n">ConstructorArgumentValues</span> <span class="n">getConstructorArgumentValues</span><span class="p">();</span>

    
    <span class="n">MutablePropertyValues</span> <span class="n">getPropertyValues</span><span class="p">();</span>


    <span class="k">boolean</span> <span class="n">isSingleton</span><span class="p">();</span>

    
    <span class="k">boolean</span> <span class="n">isPrototype</span><span class="p">();</span>

    
    <span class="k">boolean</span> <span class="n">isAbstract</span><span class="p">();</span>

    
    <span class="n">int</span> <span class="n">getRole</span><span class="p">();</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="k">String</span> <span class="n">getDescription</span><span class="p">();</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="k">String</span> <span class="n">getResourceDescription</span><span class="p">();</span>

    
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="n">BeanDefinition</span> <span class="n">getOriginatingBeanDefinition</span><span class="p">();</span>

<span class="p">}</span>

   <span class="n">BeanDefinition</span><span class="err">，顾名思义便是</span><span class="n">spring</span><span class="err">中的</span><span class="n">bean</span><span class="err">定义接口，</span><span class="n">spring</span><span class="err">的工厂里持有的就是此接口定义的内容。从源码可以看出，这个接口继承了两个另外两个接口，一个是</span><span class="n">AttributeAccessor</span><span class="err">接口，继承这个接口就意味着</span><span class="n">BeanDefinition</span><span class="err">接口拥有了处理属性的能力，另外一个接口是</span><span class="n">BeanMetedataElement</span><span class="err">，它可以获得</span><span class="n">bean</span><span class="err">的配置定义的元素，对于</span><span class="n">xml</span><span class="err">文件来说就是会持有</span><span class="n">bean</span><span class="err">的标签。从源码中我们可以看出，</span><span class="n">BeanDefinition</span><span class="err">接口定义了两个方法，分别是</span><span class="n">void</span> <span class="n">setDependsOn</span><span class="p">(</span><span class="k">String</span><span class="err">…</span> <span class="n">dependsOn</span><span class="p">)</span><span class="err">和</span><span class="k">String</span><span class="p">[]</span> <span class="n">getDependsOn</span><span class="p">()</span><span class="err">，从方法的说明可以看出，这两个方法就是设置依赖的</span><span class="n">bean</span><span class="err">的名称和获取依赖的</span><span class="n">bean</span><span class="err">的名称，这就意味着只要我们有一个</span><span class="n">BeanDefinition</span><span class="err">，就能得到得到</span><span class="n">bean</span><span class="err">的定义信息和</span><span class="n">bean</span><span class="err">之间的依赖关系，从而可以生产一个完整的</span><span class="n">bean</span><span class="err">实例。</span>

   <span class="err">从上面两个接口，我们大致可以猜出</span><span class="n">spring</span><span class="err">是如何持有</span><span class="n">bean</span><span class="err">的定义信息及依赖关系了，没错，就是让</span><span class="n">bean</span><span class="err">工厂持有一个</span><span class="n">Map</span><span class="p">&lt;</span><span class="k">String</span><span class="err">，</span><span class="n">BeanDefinition</span><span class="p">&gt;</span><span class="err">，</span><span class="n">String</span><span class="err">型的</span><span class="n">beanName</span><span class="err">作为</span><span class="n">key</span><span class="err">，</span><span class="n">BeanDefinition</span><span class="err">型的</span><span class="n">bean</span><span class="err">定义作为</span><span class="n">value</span><span class="err">，这样就能生产一个</span><span class="n">bean</span><span class="err">实例。</span><span class="n">BeanFactory</span><span class="err">接口当然不能持有这个</span><span class="n">map</span><span class="err">对象，那么一定是在它的某个实现类里所持有的，我们找到了这个实现类，来看看源码：</span>

<span class="k">package</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">support</span><span class="p">;</span>

<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">IOException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">NotSerializableException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">ObjectInputStream</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">ObjectStreamException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">io</span><span class="p">.</span><span class="n">Serializable</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">Annotation</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">ref</span><span class="p">.</span><span class="n">Reference</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">ref</span><span class="p">.</span><span class="n">WeakReference</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">Method</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">security</span><span class="p">.</span><span class="n">AccessController</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">security</span><span class="p">.</span><span class="n">PrivilegedAction</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">ArrayList</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Arrays</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Collection</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Collections</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Comparator</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">IdentityHashMap</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Iterator</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">LinkedHashMap</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">LinkedHashSet</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="k">List</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Map</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Optional</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="k">Set</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">ConcurrentHashMap</span><span class="p">;</span>
<span class="n">import</span> <span class="n">javax</span><span class="p">.</span><span class="n">inject</span><span class="p">.</span><span class="n">Provider</span><span class="p">;</span>

<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">BeanUtils</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">BeansException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">TypeConverter</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">BeanCreationException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">BeanCurrentlyInCreationException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">BeanDefinitionStoreException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">BeanFactory</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">BeanFactoryAware</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">BeanFactoryUtils</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">BeanNotOfRequiredTypeException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">CannotLoadBeanClassException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">FactoryBean</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">InjectionPoint</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">NoSuchBeanDefinitionException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">NoUniqueBeanDefinitionException</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">ObjectFactory</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">ObjectProvider</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">SmartFactoryBean</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">SmartInitializingSingleton</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">AutowireCapableBeanFactory</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">BeanDefinition</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">BeanDefinitionHolder</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">ConfigurableBeanFactory</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">ConfigurableListableBeanFactory</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">DependencyDescriptor</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">NamedBeanHolder</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">OrderComparator</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">ResolvableType</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">core</span><span class="p">.</span><span class="n">annotation</span><span class="p">.</span><span class="n">AnnotationUtils</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">Nullable</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Assert</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">ClassUtils</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">CompositeIterator</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">ObjectUtils</span><span class="p">;</span>
<span class="n">import</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">StringUtils</span><span class="p">;</span>

<span class="p">/**</span>
 <span class="p">*</span> <span class="err">基于</span><span class="n">bean</span> <span class="n">definition</span><span class="err">对象的完整</span><span class="n">bean</span><span class="err">工厂</span>
 <span class="p">*</span> 
 <span class="p">*</span> <span class="n">Default</span> <span class="n">implementation</span> <span class="k">of</span> <span class="n">the</span>
 <span class="p">*</span> <span class="p">{@</span><span class="n">link</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">ListableBeanFactory</span><span class="p">}</span> <span class="k">and</span>
 <span class="p">*</span> <span class="p">{@</span><span class="n">link</span> <span class="n">BeanDefinitionRegistry</span><span class="p">}</span> <span class="n">interfaces</span><span class="p">:</span> <span class="n">a</span> <span class="n">full</span><span class="p">-</span><span class="n">fledged</span> <span class="n">bean</span> <span class="n">factory</span>
 <span class="p">*</span> <span class="n">based</span> <span class="n">on</span> <span class="n">bean</span> <span class="n">definition</span> <span class="n">objects</span><span class="p">.</span>
 <span class="p">*</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Rod</span> <span class="n">Johnson</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Juergen</span> <span class="n">Hoeller</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Sam</span> <span class="n">Brannen</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Costin</span> <span class="n">Leau</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Chris</span> <span class="n">Beams</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Phillip</span> <span class="n">Webb</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">author</span> <span class="n">Stephane</span> <span class="n">Nicoll</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">since</span> <span class="m">16</span> <span class="n">April</span> <span class="m">2001</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">see</span> <span class="n">StaticListableBeanFactory</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">see</span> <span class="n">PropertiesBeanDefinitionReader</span>
 <span class="p">*</span> <span class="p">@</span><span class="n">see</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">xml</span><span class="p">.</span><span class="n">XmlBeanDefinitionReader</span>
 <span class="p">*/</span>
<span class="p">@</span><span class="n">SuppressWarnings</span><span class="p">(</span><span class="s2">"serial"</span><span class="p">)</span>
<span class="n">publicclass</span> <span class="n">DefaultListableBeanFactory</span> <span class="n">extends</span> <span class="n">AbstractAutowireCapableBeanFactory</span>
        <span class="n">implements</span> <span class="n">ConfigurableListableBeanFactory</span><span class="p">,</span> <span class="n">BeanDefinitionRegistry</span><span class="p">,</span> <span class="n">Serializable</span> <span class="p">{</span>

    <span class="p">@</span><span class="n">Nullable</span>
    <span class="n">privatestatic</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">javaxInjectProviderClass</span><span class="p">;</span>

    <span class="n">static</span> <span class="p">{</span>
        <span class="n">try</span> <span class="p">{</span>
            <span class="n">javaxInjectProviderClass</span> <span class="p">=</span>
                    <span class="n">ClassUtils</span><span class="p">.</span><span class="n">forName</span><span class="p">(</span><span class="s2">"javax.inject.Provider"</span><span class="p">,</span> <span class="n">DefaultListableBeanFactory</span><span class="p">.</span><span class="n">class</span><span class="p">.</span><span class="n">getClassLoader</span><span class="p">());</span>
        <span class="p">}</span>
        <span class="n">catch</span> <span class="p">(</span><span class="n">ClassNotFoundException</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">//</span> <span class="n">JSR</span><span class="p">-</span><span class="m">330</span> <span class="n">API</span> <span class="k">not</span> <span class="n">available</span> <span class="p">-</span> <span class="n">Provider</span> <span class="n">interface</span> <span class="n">simply</span> <span class="k">not</span> <span class="n">supported</span> <span class="k">then</span><span class="p">.</span>
            <span class="n">javaxInjectProviderClass</span> <span class="p">=</span> <span class="n">null</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>


    <span class="p">/**</span> <span class="n">Map</span> <span class="k">from</span> <span class="n">serialized</span> <span class="n">id</span> <span class="k">to</span> <span class="n">factory</span> <span class="n">instance</span> <span class="p">*/</span><span class="n">privatestaticfinal</span> <span class="n">Map</span><span class="p">&lt;</span><span class="k">String</span><span class="p">,</span> <span class="n">Reference</span><span class="p">&lt;</span><span class="n">DefaultListableBeanFactory</span><span class="p">&gt;&gt;</span> <span class="n">serializableFactories</span> <span class="p">=</span>
            <span class="n">new</span> <span class="n">ConcurrentHashMap</span><span class="p">&lt;&gt;(</span><span class="m">8</span><span class="p">);</span>

    <span class="p">/**</span> <span class="n">Optional</span> <span class="n">id</span> <span class="n">for</span> <span class="n">this</span> <span class="n">factory</span><span class="p">,</span> <span class="n">for</span> <span class="n">serialization</span> <span class="n">purposes</span> <span class="p">*/</span>
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="n">private</span> <span class="k">String</span> <span class="n">serializationId</span><span class="p">;</span>

    <span class="p">/**</span> <span class="n">Whether</span> <span class="k">to</span> <span class="n">allow</span> <span class="n">re</span><span class="p">-</span><span class="n">registration</span> <span class="k">of</span> <span class="n">a</span> <span class="n">different</span> <span class="n">definition</span> <span class="k">with</span> <span class="n">the</span> <span class="n">same</span> <span class="n">name</span> <span class="p">*/</span><span class="n">privateboolean</span> <span class="n">allowBeanDefinitionOverriding</span> <span class="p">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="p">/**</span> <span class="n">Whether</span> <span class="k">to</span> <span class="n">allow</span> <span class="n">eager</span> <span class="n">class</span> <span class="n">loading</span> <span class="n">even</span> <span class="n">for</span> <span class="n">lazy</span><span class="p">-</span><span class="n">init</span> <span class="n">beans</span> <span class="p">*/</span><span class="n">privateboolean</span> <span class="n">allowEagerClassLoading</span> <span class="p">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="p">/**</span> <span class="n">Optional</span> <span class="n">OrderComparator</span> <span class="n">for</span> <span class="n">dependency</span> <span class="n">Lists</span> <span class="k">and</span> <span class="n">arrays</span> <span class="p">*/</span>
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="n">private</span> <span class="n">Comparator</span><span class="p">&lt;</span><span class="n">Object</span><span class="p">&gt;</span> <span class="n">dependencyComparator</span><span class="p">;</span>

    <span class="p">/**</span> <span class="n">Resolver</span> <span class="k">to</span> <span class="n">use</span> <span class="n">for</span> <span class="n">checking</span> <span class="k">if</span> <span class="n">a</span> <span class="n">bean</span> <span class="n">definition</span> <span class="n">is</span> <span class="n">an</span> <span class="n">autowire</span> <span class="n">candidate</span> <span class="p">*/</span><span class="n">private</span> <span class="n">AutowireCandidateResolver</span> <span class="n">autowireCandidateResolver</span> <span class="p">=</span> <span class="n">new</span> <span class="n">SimpleAutowireCandidateResolver</span><span class="p">();</span>

    <span class="p">/**</span> <span class="n">Map</span> <span class="k">from</span> <span class="n">dependency</span> <span class="n">type</span> <span class="k">to</span> <span class="n">corresponding</span> <span class="n">autowired</span> <span class="n">value</span> <span class="p">*/</span><span class="n">privatefinal</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">Class</span><span class="p">&lt;?&gt;,</span> <span class="n">Object</span><span class="p">&gt;</span> <span class="n">resolvableDependencies</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ConcurrentHashMap</span><span class="p">&lt;&gt;(</span><span class="m">16</span><span class="p">);</span>

    <span class="p">/**</span> <span class="n">Map</span> <span class="k">of</span> <span class="n">bean</span> <span class="n">definition</span> <span class="n">objects</span><span class="p">,</span> <span class="n">keyed</span> <span class="n">by</span> <span class="n">bean</span> <span class="n">name</span> <span class="p">*///</span><span class="n">beanFactory</span><span class="err">持有此</span><span class="n">map</span><span class="p">,</span><span class="err">这样就可以在任何时候获取</span><span class="n">bean</span><span class="err">的</span><span class="n">BeanDefinition</span><span class="err">来创建一个</span><span class="n">bean</span><span class="err">实例</span><span class="n">privatefinal</span> <span class="n">Map</span><span class="p">&lt;</span><span class="k">String</span><span class="p">,</span> <span class="n">BeanDefinition</span><span class="p">&gt;</span> <span class="n">beanDefinitionMap</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ConcurrentHashMap</span><span class="p">&lt;&gt;(</span><span class="m">256</span><span class="p">);</span>

    <span class="p">/**</span> <span class="n">Map</span> <span class="k">of</span> <span class="n">singleton</span> <span class="k">and</span> <span class="n">non</span><span class="p">-</span><span class="n">singleton</span> <span class="n">bean</span> <span class="n">names</span><span class="p">,</span> <span class="n">keyed</span> <span class="n">by</span> <span class="n">dependency</span> <span class="n">type</span> <span class="p">*/</span><span class="n">privatefinal</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">Class</span><span class="p">&lt;?&gt;,</span> <span class="k">String</span><span class="p">[]&gt;</span> <span class="n">allBeanNamesByType</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ConcurrentHashMap</span><span class="p">&lt;&gt;(</span><span class="m">64</span><span class="p">);</span>

    <span class="p">/**</span> <span class="n">Map</span> <span class="k">of</span> <span class="n">singleton</span><span class="p">-</span><span class="n">only</span> <span class="n">bean</span> <span class="n">names</span><span class="p">,</span> <span class="n">keyed</span> <span class="n">by</span> <span class="n">dependency</span> <span class="n">type</span> <span class="p">*/</span><span class="n">privatefinal</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">Class</span><span class="p">&lt;?&gt;,</span> <span class="k">String</span><span class="p">[]&gt;</span> <span class="n">singletonBeanNamesByType</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ConcurrentHashMap</span><span class="p">&lt;&gt;(</span><span class="m">64</span><span class="p">);</span>

    <span class="p">/**</span> <span class="k">List</span> <span class="k">of</span> <span class="n">bean</span> <span class="n">definition</span> <span class="n">names</span><span class="p">,</span> <span class="k">in</span> <span class="n">registration</span> <span class="n">order</span> <span class="p">*/</span><span class="n">privatevolatile</span> <span class="k">List</span><span class="p">&lt;</span><span class="k">String</span><span class="p">&gt;</span> <span class="n">beanDefinitionNames</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ArrayList</span><span class="p">&lt;&gt;(</span><span class="m">256</span><span class="p">);</span>

    <span class="p">/**</span> <span class="k">List</span> <span class="k">of</span> <span class="n">names</span> <span class="k">of</span> <span class="n">manually</span> <span class="n">registered</span> <span class="n">singletons</span><span class="p">,</span> <span class="k">in</span> <span class="n">registration</span> <span class="n">order</span> <span class="p">*/</span><span class="n">privatevolatile</span> <span class="k">Set</span><span class="p">&lt;</span><span class="k">String</span><span class="p">&gt;</span> <span class="n">manualSingletonNames</span> <span class="p">=</span> <span class="n">new</span> <span class="n">LinkedHashSet</span><span class="p">&lt;&gt;(</span><span class="m">16</span><span class="p">);</span>

    <span class="p">/**</span> <span class="n">Cached</span> <span class="k">array</span> <span class="k">of</span> <span class="n">bean</span> <span class="n">definition</span> <span class="n">names</span> <span class="k">in</span> <span class="k">case</span> <span class="k">of</span> <span class="n">frozen</span> <span class="n">configuration</span> <span class="p">*/</span>
    <span class="p">@</span><span class="n">Nullable</span>
    <span class="n">privatevolatile</span> <span class="k">String</span><span class="p">[]</span> <span class="n">frozenBeanDefinitionNames</span><span class="p">;</span>

    <span class="p">/**</span> <span class="n">Whether</span> <span class="n">bean</span> <span class="n">definition</span> <span class="n">metadata</span> <span class="n">may</span> <span class="n">be</span> <span class="n">cached</span> <span class="n">for</span> <span class="n">all</span> <span class="n">beans</span> <span class="p">*/</span><span class="n">privatevolatileboolean</span> <span class="n">configurationFrozen</span> <span class="p">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

   <span class="n">DefaultListableBeanFactory</span><span class="err">类，这个类是默认的</span><span class="n">bean</span><span class="err">工厂实现类，这里只贴出了部分源码，完整的代码太长。我们来看其中的一行代码：</span>

<span class="p">/**</span> <span class="n">Map</span> <span class="k">of</span> <span class="n">bean</span> <span class="n">definition</span> <span class="n">objects</span><span class="p">,</span> <span class="n">keyed</span> <span class="n">by</span> <span class="n">bean</span> <span class="n">name</span> <span class="p">*///</span><span class="n">beanFactory</span><span class="err">持有此</span><span class="n">map</span><span class="p">,</span><span class="err">这样就可以在任何时候获取</span><span class="n">bean</span><span class="err">的</span><span class="n">BeanDefinition</span><span class="err">来创建一个</span><span class="n">bean</span><span class="err">实例</span><span class="n">privatefinal</span> <span class="n">Map</span><span class="p">&lt;</span><span class="k">String</span><span class="p">,</span> <span class="n">BeanDefinition</span><span class="p">&gt;</span> <span class="n">beanDefinitionMap</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ConcurrentHashMap</span><span class="p">&lt;&gt;(</span><span class="m">256</span><span class="p">);</span>

   <span class="err">这行代码证明了我们的猜测，从方法是说明就可以看出这是</span><span class="n">bean</span><span class="err">定义的</span><span class="n">map</span><span class="err">对象，以</span><span class="n">bean</span><span class="err">的名称作为</span><span class="n">key</span><span class="err">。到这里思路就明确了，</span><span class="n">bean</span><span class="err">工厂的初始化就是往这个</span><span class="n">map</span><span class="err">对象里加东西，把我们</span><span class="n">xml</span><span class="err">文件里定义的</span><span class="n">bean</span><span class="err">填充到这个对象里，</span><span class="n">bean</span><span class="err">工厂就可以工作了。</span>

   <span class="err">那么怎样将</span><span class="n">xml</span><span class="err">文件配置的</span><span class="n">bean</span><span class="err">注册到这个</span><span class="n">map</span><span class="err">对象里呢？我们可以试试以下思路：</span>

   <span class="m">1</span><span class="err">、需要一个工具来找到</span><span class="n">xml</span><span class="err">配置文件，可以称之为资源定位；</span>

   <span class="m">2</span><span class="err">、需要一个</span><span class="n">Reader</span><span class="err">来读取</span><span class="n">xml</span><span class="err">配置信息，即</span><span class="n">DOM</span><span class="err">解析；</span>

   <span class="m">3</span><span class="err">、将读取出来的信息注册到</span><span class="n">map</span><span class="err">对象里。</span>

   <span class="err">以代码来验证一下，写一个</span><span class="n">Person</span><span class="err">类作为</span><span class="n">bean</span><span class="err">：</span>

<span class="n">publicclass</span> <span class="n">Person</span> <span class="p">{</span>

    <span class="n">publicvoid</span> <span class="n">work</span><span class="p">(){</span>
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">"I am working..."</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

   <span class="err">创建一个</span><span class="n">applicationContext</span><span class="p">.</span><span class="n">xml</span><span class="err">配置文件，配置</span><span class="n">bean</span><span class="err">：</span>

<span class="p">&lt;?</span><span class="n">xml</span> <span class="k">version</span><span class="p">=</span><span class="s2">"1.0"</span> <span class="n">encoding</span><span class="p">=</span><span class="s2">"UTF-8"</span><span class="p">?&gt;</span>
<span class="p">&lt;</span><span class="n">beans</span> <span class="n">xmlns</span><span class="p">=</span><span class="s2">"http://www.springframework.org/schema/beans"</span>
    <span class="n">xmlns</span><span class="p">:</span><span class="n">xsi</span><span class="p">=</span><span class="s2">"http://www.w3.org/2001/XMLSchema-instance"</span>
    <span class="n">xsi</span><span class="p">:</span><span class="n">schemaLocation</span><span class="p">=</span><span class="s2">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span><span class="p">&gt;</span>

    <span class="p">&lt;</span><span class="n">bean</span> <span class="n">id</span><span class="p">=</span><span class="s2">"person"</span> <span class="n">class</span><span class="p">=</span><span class="s2">"com.springframework.bean.test.Person"</span><span class="p">&gt;&lt;/</span><span class="n">bean</span><span class="p">&gt;</span>
    
<span class="p">&lt;/</span><span class="n">beans</span><span class="p">&gt;</span>

   <span class="err">接下来写个测试类：</span>

<span class="n">publicclass</span> <span class="n">Client</span> <span class="p">{</span>

    <span class="n">publicstaticvoid</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">ClassPathResource</span> <span class="n">classPathResource</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ClassPathResource</span><span class="p">(</span><span class="s2">"applicationContext.xml"</span><span class="p">);</span>
        
        <span class="n">DefaultListableBeanFactory</span> <span class="n">defaultListableBeanFactory</span> <span class="p">=</span> <span class="n">new</span> <span class="n">DefaultListableBeanFactory</span><span class="p">();</span>
        
        <span class="n">XmlBeanDefinitionReader</span> <span class="n">beanDefinitionReader</span> <span class="p">=</span> <span class="n">new</span> <span class="n">XmlBeanDefinitionReader</span><span class="p">(</span><span class="n">defaultListableBeanFactory</span><span class="p">);</span>
        
        <span class="n">beanDefinitionReader</span><span class="p">.</span><span class="n">loadBeanDefinitions</span><span class="p">(</span><span class="n">classPathResource</span><span class="p">);</span>
        
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">defaultListableBeanFactory</span><span class="p">.</span><span class="n">getBeanDefinitionCount</span><span class="p">());</span>
        
        <span class="n">Person</span> <span class="n">person</span> <span class="p">=</span> <span class="p">(</span><span class="n">Person</span><span class="p">)</span><span class="n">defaultListableBeanFactory</span><span class="p">.</span><span class="n">getBean</span><span class="p">(</span><span class="s2">"person"</span><span class="p">);</span>
        
        <span class="n">person</span><span class="p">.</span><span class="n">work</span><span class="p">();</span>
        
    <span class="p">}</span>
<span class="p">}</span>

   <span class="err">执行结果如下：</span>

<span class="err">七月</span> <span class="m">06</span><span class="p">,</span> <span class="m">2017</span> <span class="m">9</span><span class="p">:</span><span class="m">41</span><span class="p">:</span><span class="m">48</span> <span class="err">下午</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">xml</span><span class="p">.</span><span class="n">XmlBeanDefinitionReader</span> <span class="n">loadBeanDefinitions</span>
<span class="err">信息</span><span class="p">:</span> <span class="n">Loading</span> <span class="n">XML</span> <span class="n">bean</span> <span class="n">definitions</span> <span class="k">from</span> <span class="n">class</span> <span class="n">path</span> <span class="n">resource</span> <span class="p">[</span><span class="n">applicationContext</span><span class="p">.</span><span class="n">xml</span><span class="p">]</span>
<span class="m">1</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">working</span><span class="p">...</span>

   <span class="err">从结果可以看出，我们成功解析了</span><span class="n">xml</span><span class="err">文件，并注册了一个</span><span class="n">bean</span><span class="err">定义，通过</span><span class="n">getBean</span><span class="p">()</span><span class="err">方法成功返回了一个实例。上面的测试类用</span><span class="m">4</span><span class="err">行代码实现了</span><span class="n">bean</span><span class="err">工厂的初始化：</span>

   <span class="err">第一行，完成了资源定位；</span>

   <span class="err">第二行，创建了一个默认的</span><span class="n">bean</span><span class="err">工厂；</span>

   <span class="err">第三行，创建了一个</span><span class="n">Reader</span><span class="err">，这个</span><span class="n">Reader</span><span class="err">用来读取</span><span class="n">xml</span><span class="err">文件，将创建的</span><span class="n">defaultListableBeanFactory</span> <span class="err">作为参数传递给</span><span class="n">Reader</span><span class="err">，表示为此工厂创建</span><span class="n">Reader</span><span class="err">；</span>

   <span class="err">第四行，用</span><span class="n">Reader</span><span class="err">读取配置信息，并将解析的</span><span class="n">bean</span><span class="err">定义注册到</span><span class="n">defaultListableBeanFactory</span> <span class="err">中。</span>

   <span class="err">执行完以上四个步骤，</span><span class="n">bean</span><span class="err">工厂酒杯正确初始化了，接下来我们可以调用工厂的方法，以及获得</span><span class="n">bean</span><span class="err">实例。</span>

   <span class="err">但是在实际开发中不会这么复杂，</span><span class="n">spring</span><span class="err">可以更简单的一步到位，它是这么做的：</span>

<span class="n">publicclass</span> <span class="n">TestSpringBeanFactory</span> <span class="p">{</span>
    
    <span class="n">publicstaticvoid</span> <span class="n">main</span><span class="p">(</span><span class="k">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="n">ApplicationContext</span> <span class="n">ctx</span> <span class="p">=</span> <span class="n">new</span> <span class="n">FileSystemXmlApplicationContext</span><span class="p">(</span><span class="s2">"src/applicationContext.xml"</span><span class="p">);</span>
        
        <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">getBeanDefinitionCount</span><span class="p">());</span>
        
        <span class="n">Person</span> <span class="n">person</span> <span class="p">=</span> <span class="p">(</span><span class="n">Person</span><span class="p">)</span> <span class="n">ctx</span><span class="p">.</span><span class="n">getBean</span><span class="p">(</span><span class="s2">"person"</span><span class="p">);</span>
        
        <span class="n">person</span><span class="p">.</span><span class="n">work</span><span class="p">();</span>
        
    <span class="p">}</span>

<span class="p">}</span>

   <span class="err">我们看看执行结果：</span>

<span class="err">七月</span> <span class="m">06</span><span class="p">,</span> <span class="m">2017</span> <span class="m">9</span><span class="p">:</span><span class="m">42</span><span class="p">:</span><span class="m">55</span> <span class="err">下午</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">support</span><span class="p">.</span><span class="n">AbstractApplicationContext</span> <span class="n">prepareRefresh</span>
<span class="err">信息</span><span class="p">:</span> <span class="n">Refreshing</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">context</span><span class="p">.</span><span class="n">support</span><span class="p">.</span><span class="n">FileSystemXmlApplicationContext</span><span class="p">@</span><span class="m">20</span><span class="n">ad9418</span><span class="p">:</span> <span class="n">startup</span> <span class="n">date</span> <span class="p">[</span><span class="n">Thu</span> <span class="n">Jul</span> <span class="m">06</span> <span class="m">21</span><span class="p">:</span><span class="m">42</span><span class="p">:</span><span class="m">55</span> <span class="n">CST</span> <span class="m">2017</span><span class="p">];</span> <span class="n">root</span> <span class="k">of</span> <span class="n">context</span> <span class="n">hierarchy</span>
<span class="err">七月</span> <span class="m">06</span><span class="p">,</span> <span class="m">2017</span> <span class="m">9</span><span class="p">:</span><span class="m">42</span><span class="p">:</span><span class="m">55</span> <span class="err">下午</span> <span class="n">org</span><span class="p">.</span><span class="n">springframework</span><span class="p">.</span><span class="n">beans</span><span class="p">.</span><span class="n">factory</span><span class="p">.</span><span class="n">xml</span><span class="p">.</span><span class="n">XmlBeanDefinitionReader</span> <span class="n">loadBeanDefinitions</span>
<span class="err">信息</span><span class="p">:</span> <span class="n">Loading</span> <span class="n">XML</span> <span class="n">bean</span> <span class="n">definitions</span> <span class="k">from</span> <span class="n">file</span> <span class="p">[</span><span class="n">C</span><span class="p">:</span><span class="n">Usersfangfuhaiworkspacespring</span><span class="p">-</span><span class="n">code</span><span class="p">-</span><span class="n">learningsrcapplicationContext</span><span class="p">.</span><span class="n">xml</span><span class="p">]</span>
<span class="m">1</span>
<span class="n">I</span> <span class="n">am</span> <span class="n">working</span><span class="p">...</span>

   <span class="err">从结果可以看出，</span><span class="n">spring</span><span class="err">用一行代码就完成了我们四个步骤，仔细看看日志信息就可以发现，</span><span class="n">spring</span><span class="err">也是用</span><span class="n">XmlBeanDefinitionReader</span> <span class="err">来读取、解析并注册，同时在日志信息里还多了两行，这说明在这一行代码里，</span><span class="n">spring</span><span class="err">还做了更多的事情。</span>

   <span class="err">我们在</span><span class="n">new</span><span class="err">一个</span><span class="n">FileSystemXmlApplicationContext</span><span class="err">对象的时候，</span><span class="n">spring</span><span class="err">到底做了那些事情呢？下一章节我们来一探究竟。</span>
</code></pre></div></div>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/spring%E6%BA%90%E7%A0%81ioc%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%80.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/%E6%A3%8B%E7%89%8C%E6%BA%90%E7%A0%81%E5%BC%80%E5%8F%91%E7%89%9B%E7%89%9B%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF.html">&laquo; 棋牌源码开发-牛牛算法思路</a>
  
  
  <a class="next" href="/2017/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B8%B8%E8%A7%81%E6%AD%BB%E9%94%81%E5%8E%9F%E5%9B%A0%E5%8F%8A%E5%A4%84%E7%90%86.html">数据库常见死锁原因及处理 &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
