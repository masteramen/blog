<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>浅入深出之Java集合框架（上） | Java面试</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="浅入深出之Java集合框架（上）" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="由于Java中的集合框架的内容比较多，在这里分为三个部分介绍Java的集合框架，内容是从浅到深，如果已经有java基础的小伙伴可以直接跳到&lt;浅入深出之Java集合框架（下）&gt;。" />
<meta property="og:description" content="由于Java中的集合框架的内容比较多，在这里分为三个部分介绍Java的集合框架，内容是从浅到深，如果已经有java基础的小伙伴可以直接跳到&lt;浅入深出之Java集合框架（下）&gt;。" />
<link rel="canonical" href="http://www.jfox.info/2017/%E6%B5%85%E5%85%A5%E6%B7%B1%E5%87%BA%E4%B9%8Bjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%8A-2.html" />
<meta property="og:url" content="http://www.jfox.info/2017/%E6%B5%85%E5%85%A5%E6%B7%B1%E5%87%BA%E4%B9%8Bjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%8A-2.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T23:55:18+08:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","headline":"浅入深出之Java集合框架（上）","dateModified":"2017-01-01T23:55:18+08:00","datePublished":"2017-01-01T23:55:18+08:00","url":"http://www.jfox.info/2017/%E6%B5%85%E5%85%A5%E6%B7%B1%E5%87%BA%E4%B9%8Bjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%8A-2.html","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/%E6%B5%85%E5%85%A5%E6%B7%B1%E5%87%BA%E4%B9%8Bjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%8A-2.html"},"description":"由于Java中的集合框架的内容比较多，在这里分为三个部分介绍Java的集合框架，内容是从浅到深，如果已经有java基础的小伙伴可以直接跳到&lt;浅入深出之Java集合框架（下）&gt;。","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">浅入深出之Java集合框架（上）</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T23:55:18+08:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>由于Java中的集合框架的内容比较多，在这里分为三个部分介绍Java的集合框架，内容是从浅到深，如果已经有java基础的小伙伴可以直接跳到&lt;浅入深出之Java集合框架（下）&gt;。</p>

<p>目录：</p>

<p>*浅入深出之Java集合框架（中）   努力赶制中。。关注后更新会提醒哦！
*</p>

<p><em>浅入深出之Java集合框架（下）　</em>努力赶制中。。<em>关注后更新会提醒哦！</em>**</p>

<h2 id="一集合概述">一、集合概述</h2>

<h4 id="1集合的概念">1）集合的概念</h4>

<p>现实生活中的集合：很多事物凑在一起。</p>

<p>数学中的集合：具有共同属性的事物的总体。</p>

<p>Java中的集合类：是一种工具类，就像是容器，储存任意数量的具有共同属性的对象。</p>

<h4 id="2集合的作用">2）集合的作用</h4>

<p>如果一个类的内部有多相同类型的属性，并且它们的作用和意义是一样的。比如说，一个学生可以选多个课程，对于一个学生类来说，XX课程就是他的一个属性，而xx课程通常不只有一个。对于像这种情况，如果把每一个课程都定一个属性就太繁琐了，这里我们就要用到集合的概念。</p>

<p><img src="9451b7f.png" alt="" />     <img src="/wp-content/uploads/2017/07/1499503991.png" alt="" /></p>

<p>综上所述，集合的作用有以下几点：</p>

<ol>
  <li>在类的内部，对数据进行组织。</li>
  <li>简单而快速的搜索大数量的条目。</li>
  <li>有的集合接口，提供了一系列排列有序的元素，并且可以在序列中间快速的插入或者删除有关元素。</li>
  <li>有的集合接口，提供了映射关系，可以通过关键字（key）去快速查找到对应的唯一对象，而这个关键字可以是任意类型。</li>
</ol>

<h4 id="3集合和数组的对比">3)集合和数组的对比</h4>

<p>可以看出集合和数组的功能类似，都是把一系列的数据放入到一个容器中，但是在类的内部我们为什么要用集合而不是数组呢？</p>

<ol>
  <li>数组的长度固定，集合长度可变。集合的优势就在于，集合的长度是随着里面的内容而扩充的，而数组的长度是已经定义好的。</li>
  <li>数组只能通过下标访问元素，类型固定（数组下标只能是整形的），而有的集合可以通过任意类型查找所映射的具体对象（key关键字可以是任意类型）。</li>
</ol>

<h2 id="二java集合框架体系结构">二、Java集合框架体系结构</h2>

<p>我们来简单看一下java集合框架：(还有很多接口和类没有列出，这里只列出常用的接口和类)</p>

<p><img src="1c55fd2.png" alt="" /></p>

<p>如图所示，JAVA集合框架体系结构：Collection与Map是两个根接口。</p>

<p><strong>Collection接口：</strong>内部存储的是一个个独立的对象。包含：</p>

<p>1、List接口：序列，存储元素排列有序且可重复。实现类:ArrayList，数组序列；实现类：LinkedList，链表。</p>

<p>2、Queue接口：队列，存储元素排列有序且可重复。实现类：LinkedList，链表。</p>

<p>3、Set接口：集，存储元素无序且不可重复。实现类：HashSet，哈希集。</p>

<p><strong>Map接口：</strong>内部以&lt;Key,Value&gt;（任意类型）的一个映射去存储数据，这一个映射就是Entry类（Map的内部类）的实例。包括：实现类：HashMap，哈希表。</p>

<p>Collection接口是List、Set、Queue接口的父接口，Collection接口定义了可用于操作List、Set和Queue的方法–增删改查。（具体的Collection接口的方法可以通过查API，这里就不列举了。）</p>

<p>其中，ArrayList、HashSet和HashMap是使用最多的三个实现类，这里我们将逐个介绍这三个实现类。</p>

<p>在这篇文章中将先介绍ArrayList的用法。</p>

<h2 id="三arraylist实现类">三、ArrayList实现类</h2>

<p>List接口及其实现类–ArrayList</p>

<p>List可以精确的控制每个元素的插入位置，或删除某个位置元素；</p>

<p>List有add()插入方法和get()获取方法；</p>

<p>ArrayList–数组序列，是List的一个重要实现类</p>

<p>ArrayList底层是由数组实现的，这也是其名字的由来。</p>

<p>那么如何使用这些集合呢？我们来通过一个小例子，写一个小程序来更直观的学习集合的使用方法。（之后的文章的例子也是基于此的）</p>

<p><strong>»»»»»»»»»»»»»»»»»»»»»</strong></p>

<p>程序功能——模拟学生选课功能</p>

<ol>
  <li>选择课程（往集合添加课程）</li>
  <li>删除所选的某门课程（删除集合中的元素）</li>
  <li>查看所选课程</li>
  <li>修改所选课程</li>
</ol>

<p><strong>»»»»»»»»»»»»»»»»»»»»»</strong></p>

<p>以下是该程序的代码片段，因为是用于测试来介绍集合的使用，所以请不要在意细节，代码会一步步改进的。</p>

<h4 id="1创建学生类和课程类">1)创建学生类和课程类</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1/** 2 * 学生类
 3 * @author hysum
 4 *
 5*/ 6publicclass Student implements {
 7private String name;//学生姓名 8private String id;//学生id 9private Set courses;//所选课程的set集合1011public Student(){}
12public Student(String id,String name){
13this.id=id;
14this.name=name;
15this.courses=new HashSet();//初始化集合16    }
17public String getName() {
18return name;
19    }
20publicvoid setName(String name) {
21this.name = name;
22    }
23public String getId() {
24return id;
25    }
26publicvoid setId(String id) {
27this.id = id;
28    }
29public Set getCourses() {
30return courses;
31    }
32publicvoid setCourses(Set courses) {
33this.courses = courses;
34     }

 1/** 2 * 课程类
 3 * @author hysum
 4 *
 5*/ 6publicclass Course {
 7private String id;//课程id 8private String name;//课程名称 910public Course(){
1112    }
13public Course(String name){
14this.name=name;
15    }
16public String getId() {
17return id;
18    }
19publicvoid setId(String id) {
20this.id = id;
21    }
22public String getName() {
23return name;
24    }
25publicvoid setName(String name) {
26this.name = name;
27    }
28public Course(String id,String name){
29this.id=id;
30this.name=name;
31    }
32 }
</code></pre></div></div>

<h4 id="2创建备选课程类">2）创建备选课程类</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1/** 2 * 备选课程类
 3 * 
 4 * @author hysum
 5 *
 6*/ 7publicclass ListCourse {
 8private List CoresesToSelect;// 备选课程 9private Student stu;
10privatestatic Scanner in;
11    {
12         in = new Scanner(System.in);
13    }
14public ListCourse() {
15this.CoresesToSelect = new ArrayList();// 初始化List集合16    }
17public List getCoresesToSelect() {
18return CoresesToSelect;
19    }
2021publicvoid setCoresesToSelect(List coresesToSelect) {
22         CoresesToSelect = coresesToSelect;
23    }   26 }
</code></pre></div></div>

<p><strong>注意：</strong></p>

<p>List是接口，所以在构造方法中不能直接实例化，而通过ArrayList()实例化！！！</p>

<p>例：public List coursesToSelect = new ArrayList();</p>

<p>Set、Map都类似，不可以直接对他实例化，要借助相应的实例化类如HashSet(),HashMap();</p>

<h4 id="3在备选课程里添加课程">3）在备选课程里添加课程</h4>

<p>(添加元素)List下总共有4个为List插入元素的方法 ：</p>

<p>1.add(element);</p>

<p>2.add(index,element);</p>

<p>3.addAll(Arrays.asList(对象数组名));</p>

<p>4.addAll(index,Arrays.asList(对象数组名));</p>

<p>以下用代码示例：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1/* 2 * 添加备选课程
 3*/ 4publicvoid AddCourse() {
 5         Course cr1=new Course("1","数据结构");//创建课程对象 6this.CoresesToSelect.add(cr1);//用add(element)添加  7         Course temp=(Course)this.CoresesToSelect.get(0);//用get方法取出，注意类型转换 8     System.out.println("添加了课程："+temp.getId()+" "+temp.getName());
 910         Course cr2=new Course("2","C语言");//创建课程对象11this.CoresesToSelect.add(0,cr2);//用add(index,element)添加 12     temp=(Course)this.CoresesToSelect.get(0);
13         System.out.println("添加了课程："+temp.getId()+" "+temp.getName());  
14 }      

1 Course[] course = { new Course("1", "数据结构"), new Course("2", "C语言"), new Course("3", "汇编语言"),
2new Course("4", "离散数学") };
3this.CoresesToSelect.addAll(Arrays.asList(course));//用addAll(Arrays.asList(对象数组名))添加
</code></pre></div></div>

<p><strong>注意：</strong></p>

<p>1.对象被存入集合都变成object类型了 取出时需要类型强转。（之后会用泛型来解决这个问题）</p>

<p>例：Course temp = (Course)coursesToSelect.get(0);</p>

<p>2.添加进list中的位置（index）介于[0，length]之间；0代表插到队头，length代表插到队尾。</p>

<p>3.如果添加到List中的长度大于他目前的长度，则系统会出现异常，即数组下表越界异常,如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 Course cr2=new Course("2","C语言");//创建课程对象2this.CoresesToSelect.add(2,cr2);//用add方法添加,超出集合现有长度 temp=(Course)
</code></pre></div></div>

<p><img src="5306c6c.png" alt="" /></p>

<h4 id="4备选课程取出打印">4）备选课程取出打印</h4>

<p>以下三种方法都是用来取出List中元素的方法：</p>

<p>—–for循环—–</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1publicvoid testGet(){
2int size=CoursesToSelect.size();
3for(int i=0;i&lt;size;i++){
4 Course cr=(Course) CoursesToSelect.get(i);
5 System.out.println("取出的课程："+cr.getId()+":"+cr.getName());
6}
7 }
</code></pre></div></div>

<p>—–迭代器—–</p>

<p>Iterator是一个接口,依赖于集合存在的。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 Iterator it=CourseToSelect.iterator();
2while(it.hasNext()){
3 Course cr=(Course) it.next();
4 System.out.println("课程:" + cr.id + ":" + cr.name);
5 }
</code></pre></div></div>

<p>—–for each(推荐使用)—–</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1for(Object obj:CoursesToSelect){//遍历集合中的每一个元素，作为每一个Object变量2 Course cr=(Course) obj;
3 System.out.println("课程:" + cr.id + ":" + cr.name);
4 }
</code></pre></div></div>

<h4 id="5备选课程修改">5）备选课程修改</h4>

<p>使用set（index,Object element）修改元素，index表示索引位置，element表示新对象。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1/*2     * 修改备选课程
3*/4publicvoid Modify(int index, Course c) {// 传入要修改的参数5this.CoresesToSelect.set(index, c);
6     }
</code></pre></div></div>

<h4 id="6删除备选课程元素">6）删除备选课程元素</h4>

<p>List中有remove(index),remove(对象值)和removeAll(Arrays.asList(对象数组名))方法来删除容器中元素的值(用法和add类似)。</p>

<p>Course是信息课程类，有id和name属性；courseToSelect是list的序列容器对象。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1/* 2     * 删除备选课程，跟添加方法类似
 3*/ 4publicvoid Remove(int index) {// 通过索引位置删除 5this.CoresesToSelect.remove(index);
 6    }
 7 8publicvoid Remove(Course c) {// 通过课程对象删除 9this.CoresesToSelect.remove(c);
1011    }
1213publicvoid Remove(Course[] c) {// 通过集合对象删除14this.CoresesToSelect.removeAll(Arrays.asList(c));
1516     }
</code></pre></div></div>

<p>注意：</p>

<p>1.remove(index);删除位置要大于0并且小于List(序列容器)的长度。如果要删除全部可以用for循环嵌套此方法。</p>

<p>2.remove(object);先要获得删除的值，用法是先定义一个信息变量通过get()来存放要删除的值,然后用remove(删除的对象值);</p>

<p>3.removeAll(Arrays.asList());要删除指定的多个位置  Arrays.asLIst(对象数组名);作用是把数组转换为集合。用法是先创建信息对象数组存放删除元素的值，然后再用removeAll(Arrays.asList(对象数组名))方法,删除集合数组的元素。</p>

<h2 id="四应用泛型管理课程">四、应用泛型管理课程</h2>

<p>在上面的几个例子中，小伙伴是否发现对于集合的取出和遍历都要将Object对象进行强制转换后才能使用，每次这样做不仅增加了编程难度还使代码特别繁琐，这里我们可以利用<strong>泛型</strong>来帮助我们更加方便地使用java集合。</p>

<p>首先，我们要知道没有使用泛型的话，集合中的元素,可以是任意类型的对象(对象的引用)，如果把某个对象放入集合,则会忽略他的类型把他当做Object处理。</p>

<p>那么我们就在刚才的例子里往备选课程类里的CoresesToSelect的List集合添加一些奇怪的东西会发什么有趣的事呢？</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1/*2     * 往List中添加一些奇怪的东西
3*/4publicvoid testType(){
5      System.out.println("能否往List中添加一些奇怪的东西呢?");
6this.CoresesToSelect.add("我不是课程，我是字符串！");
7      }
</code></pre></div></div>

<p>当调用取出课程方法取出该元素时，运行时出错：</p>

<p><img src="918f4c9.png" alt="" /></p>

<p>这是因为取出该元素时String类型不能强制转换为Course类型，那有什么办法来避免集合中被添加不希望添加的类型呢？</p>

<p>泛型则是规定了某个集合只可以存放特定类型的对象，会在编译期间进行类型检查，可以直接指定类型获取的集合元素。</p>

<p><strong>泛型：指规定了某个集合只能存放特定类型的对象。</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>语法：ArrayList&lt;String&gt; array=new ArrayList&lt;String&gt;();  //规定array中只能存放String类型的对象
</code></pre></div></div>

<p>那么，了解了泛型之后，上面的例子里都可以加上泛型了，修改如下（只列出修改的部分）：<strong>（自行对比）</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1private Set&lt;Course&gt; courses;//所选课程的set集合2this.courses=new HashSet&lt;Course&gt;();//初始化集合3public Set&lt;Course&gt; getCourses() {
4return courses;
5    }
6publicvoid setCourses(Set&lt;Course&gt; courses) {
7this.courses = courses;
8     }

 1private List&lt;Course&gt; CoresesToSelect;// 备选课程 2public ListCourse() {
 3this.CoresesToSelect = new ArrayList&lt;Course&gt;();// 初始化List集合 4    }
 5public List&lt;Course&gt; getCoresesToSelect() {
 6return CoresesToSelect;
 7    }
 8 9publicvoid setCoresesToSelect(List&lt;Course&gt; coresesToSelect) {
10         CoresesToSelect = coresesToSelect;
11     }
</code></pre></div></div>

<p>foreach循环的修改：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1for (Course obj : CoresesToSelect) {        
2     System.out.println("添加了课程：" + obj.getId() + " " + obj.getName());4 }
</code></pre></div></div>

<p>运用了泛型的话，用foreach语句时 存储变量应该为泛型的类型。for(Course a:courseToSelect),不必再用Object取出再强转，因为已经规定容器里装的都是Course类型。</p>

<p>使用泛型要<strong>注意</strong>：</p>

<p>1.泛型集合中，不能添加泛型规定的类型和其子类以外的对象，否则会报错！</p>

<p>2.泛型中可以添加规定的类型的子类型的对象。如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1publicvoid testChild() {
2         ChildCourse ccr = new ChildCourse();
3         ccr.id = "3";
4         ccr.name = "我是子类型的课程对象实例~~";
5        courses.add(ccr);
6 }
</code></pre></div></div>

<p>3.不能直接添加基本类型（int,float等）的对象，如果要添加，需要使用其包装类。如：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1publicvoid testBasicType() {
2 List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
3 list.add(1);
4 System.out.println("基本类型必须使用包装类作为泛型！" + list.get(0));
5 }
</code></pre></div></div>

<h2 id="五通过set集合管理课程">五、通过Set集合管理课程</h2>

<p>Set集合和List一样是Collection接口的子接口。它的方法跟List类似，但有稍许不同，因为Set集合是无序且不重复的。</p>

<h4 id="1添加学生选课的课程">1）添加学生选课的课程</h4>

<p>add方法跟ArrayList一样</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1 li.stu=new Student("1","小明");
 2         System.out.println("欢迎"+li.stu.getName()+"同学选择课程");
 3for(int i=0;i&lt;3;i++){//循环三次添加选课 4             System.out.println("请选第"+(i+1)+"门课程：");
 5             String Id=in.next();
 6for(Course c:li.getCoresesToSelect()){
 7if(c.getId().equals(Id)){
 8                    li.stu.getCourses().add(c);
 9                }
10            }
1112         }
</code></pre></div></div>

<p><strong>注意：</strong>Set 中添加某个对象，无论添加多少次，最终只会保留一个该对象（的引用）。同时，保留的是第一次添加的那一个。<strong>Set集合是无序的不可重复的。</strong></p>

<h4 id="2打印输出学生选的课程">2）打印输出学生选的课程</h4>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1//输出学生选的课程2for(Course c:li.stu.getCourses()){
3             System.out.println(c.getId()+" "+c.getName());
45         }
</code></pre></div></div>

<p><strong>注意：</strong>循环遍历Set中的每一个元素只能用foreach或iterator，不能像List一样用get()方法。<strong>因为是无序的每次的输出结果都有些差别。</strong></p>

<p><strong>»»»»»»»»»»»»»»»»»»»»»</strong></p>

<p><strong>总结：</strong></p>

<p>1、Set没有像List中set()方法一样就修改，因为List是有序的，可以指定位置，而Set是无序的，可以用循环遍历方式修改。</p>

<p>2、查询遍历时，Set不能用get()方法去获取，因为无序没有指定索引ID，但可以使用foreach和iterator来遍历，但是每次遍历出来可能顺序都不一样，还是因为无序造成的。</p>

<p>3、Set中的size(),add(),addAll(),remove(),removeAll()与List类似。</p>

<p>4、Set还可以添加null(但只能添加一个null，因为不重复)；</p>

<p>本篇主要讲述了List和Set的基本操作：增删改查，下一篇我将介绍Map接口的基本操作，有兴趣的小伙伴可以加一下方的<strong>“关注”</strong>哦！博主正在努力加载中。。。。。。</p>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/%E6%B5%85%E5%85%A5%E6%B7%B1%E5%87%BA%E4%B9%8Bjava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%B8%8A-2.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/tienlen%E6%B8%B8%E6%88%8F%E6%A8%A1%E5%9E%8B%E7%AE%97%E6%B3%95%E7%B1%BB%E4%BC%BC%E6%96%97%E5%9C%B0%E4%B8%BB%E6%B8%B8%E6%88%8F%E7%AE%97%E6%B3%95.html">&laquo; TienLen游戏模型、算法，类似斗地主游戏算法</a>
  
  
  <a class="next" href="/2017/%E4%B8%8Egooglecloudplatf%E4%B8%8A%E7%9A%84kubernetes%E6%B7%B7%E5%90%88%E4%BD%BF%E7%94%A8.html">与Google Cloud Platf上的Kubernetes混合使用 &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
