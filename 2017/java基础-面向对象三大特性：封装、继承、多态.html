<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>JAVA基础——面向对象三大特性：封装、继承、多态 | Java面试</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="JAVA基础——面向对象三大特性：封装、继承、多态" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。" />
<meta property="og:description" content="将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。" />
<link rel="canonical" href="http://www.jfox.info/2017/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7:%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.html" />
<meta property="og:url" content="http://www.jfox.info/2017/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7:%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T15:52:13+00:00" />
<script type="application/ld+json">
{"description":"将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。","@type":"BlogPosting","url":"http://www.jfox.info/2017/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7:%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.html","headline":"JAVA基础——面向对象三大特性：封装、继承、多态","dateModified":"2017-01-01T15:52:13+00:00","datePublished":"2017-01-01T15:52:13+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7:%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">JAVA基础——面向对象三大特性：封装、继承、多态</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T15:52:13+00:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问。</p>

<p>　　2、好处：</p>

<ul>
  <li>　　　只能通过规定的方法访问数据。</li>
  <li>　　 隐藏类的实例细节，方便修改和实现。　</li>
</ul>

<p>　　3、封装的实现步骤</p>

<p>　　　　需要注意：对封装的属性不一定要通过get/set方法，其他方法也可以对封装的属性进行操作。当然最好使用get/set方法，比较标准。</p>

<h3 id="a访问修饰符">A、访问修饰符</h3>

<p>　　　　从表格可以看出<strong>从上到下封装性越来越差</strong>。</p>

<h3 id="bthis关键字">B、this关键字</h3>

<p>　1.this关键字<strong>代表当前对象</strong></p>

<p>　　this.属性 操作当前对象的属性</p>

<p>　　this.方法 调用当前对象的方法。</p>

<p>　2.封装对象的属性的时候，经常会使用this关键字。</p>

<p>　3.当getter和setter函数参数名和成员函数名重合的时候，<strong>可以使用this</strong><strong>区别。如：</strong></p>

<h3 id="cjava-中的内部类">C、Java 中的内部类</h3>

<p>　内部类（ Inner Class ）就是定义在另外一个类<strong>里面</strong>的类。与之对应，包含内部类的类被称为外部类。</p>

<p>　那么问题来了：那为什么要将一个类定义在另一个类里面呢？清清爽爽的独立的一个类多好啊！！</p>

<p>　答：内部类的主要作用如下：</p>

<p>　　1. 内部类提供了<strong>更好的封装</strong>，可以把内部类<strong>隐藏</strong>在外部类之内，<strong>不允许</strong>同一个包中的其他类访问该类。</p>

<p>　　2. 内部类的方法可以<strong>直接访问外部类的所有数据</strong>，包括<strong>私有的数据</strong>。</p>

<p>　　3. 内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便。</p>

<p>内部类可分为以下几种：</p>

<p>　　各个内部类的具体使用请转移到另一篇随文：<a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/hysum/p/7101974.html">http://www.cnblogs.com/hysum/p/7101974.html</a></p>

<h2 id="二继承">二、继承</h2>

<h3 id="1继承的概念">1、继承的概念</h3>

<p>　继承是类与类的一种关系，是一种“is a”的关系。比如“狗”继承“动物”，这里动物类是狗类的父类或者基类，狗类是动物类的子类或者派生类。如下图所示：</p>

<p>　注：java中的继承是<strong>单继承</strong>，即<strong>一个类只有一个父类。</strong></p>

<p><strong>2、继承的好处</strong></p>

<p><strong>　子类拥有父类的所有属性和方法（除了private修饰的属性不能拥有）从而实现了实现代码的复用；　</strong></p>

<p>3、<strong>语法规则</strong>，只要在子类加上extends关键字继承相应的父类就可以了：</p>

<p><strong>A、方法的重写</strong></p>

<p>子类如果对继承的父类的方法不满意（不适合），可以自己编写继承的方法，这种方式就称为<strong>方法的重写。当调用方法时会优先调用子类的方法。</strong></p>

<p><strong>　重写要注意：</strong></p>

<p>a、返回值类型</p>

<p>　　b、方法名</p>

<p>　　c、参数类型及个数</p>

<p>都要与父类继承的方法相同，才叫方法的重写。</p>

<p><strong>　重载和重写的区别：</strong></p>

<p>方法重载：在同一个类中处理不同数据的多个相同方法名的多态手段。</p>

<p>　　方法重写：相对继承而言，子类中对父类已经存在的方法进行区别化的修改。</p>

<p><strong>B、继承的初始化顺序</strong></p>

<p>　　1、初始化父类再初始化子类</p>

<p>　　2、先执行初始化对象中属性，再执行构造方法中的初始化。</p>

<p>基于上面两点，我们就知道实例化一个子类，java程序的执行顺序是：</p>

<p><strong>父类对象属性初始化—-&gt;父类对象构造方法—-&gt;子类对象属性初始化—&gt;子类对象构造方法　　　</strong></p>

<p>下面有个形象的图：</p>

<p><strong>C、final关键字</strong></p>

<p>　使用final关键字做标识有“最终的”含义。</p>

<p>　　1. final 修饰类，则该类<strong>不允许被继承。</strong></p>

<p>　　2. final 修饰方法，则该方法不允许被<strong>覆盖(重写)</strong>。</p>

<p>　　3. final 修饰属性，则该类的该属性不会进行隐式的初始化，所以 该final 属性的<strong>初始化属性必须有值</strong>，或在<strong>构造方法中赋值(但只能选其一，且必须选其一，因为没有默认值！)，</strong>且初始化之后就不能改了，<strong>只能赋值一次</strong>。</p>

<p>　　4. final 修饰变量，则该变量的值只能赋一次值，在声明变量的时候才能赋值，即变为<strong>常量</strong>。</p>

<p><strong>D、super关键字</strong></p>

<p>　在对象的内部使用，可以代表父类对象。</p>

<p>　　1、访问父类的属性：super.age</p>

<p>　　 2、访问父类的方法：super.eat()</p>

<p>　super的应用：</p>

<p>　首先我们知道子类的构造的过程当中必须调用父类的构造方法。其实这个过程已经隐式地使用了我们的super关键字。</p>

<p>　这是因为如果子类的构造方法中没有显示调用父类的构造方法，则系统默认调用父类无参的构造方法。</p>

<p>　那么如果自己用super关键字在子类里调用父类的构造方法，则必须在子类的构造方法中的<strong>第一行</strong>。</p>

<p><strong>要注意的是：如果子类构造方法中既没有显示调用父类的构造方法，而父类没有无参的构造方法，则编译出错。</strong></p>

<p>（补充说明，虽然没有显示声明父类的无参的构造方法，系统会自动默认生成一个无参构造方法，但是，如果你声明了一个有参的构造方法，而没有声明无参的构造方法，这时系统不会动默认生成一个无参构造方法，此时称为父类有没有无参的构造方法。）</p>

<p><strong>E、Object类</strong></p>

<p>　Object类是所有类的父类，如果一个类没有使用extends关键字明确标识继承另一个类，那么这个类默认继承Object类。</p>

<p><strong>　Object类中的方法，适合所有子类！！！</strong></p>

<p>那么Object类中有什么主要的方法呢？</p>

<p>　1、toString()</p>

<p>　　a. 在Object类里面定义toString()方法的时候返回的对象的哈希code码(对象地址字符串)。</p>

<p>　　我们可以发现，如果我们直接用System.out.print（对象）输出一个对象，则运行结果输出的是对象的对象地址字符串，也称为哈希code码。如：<img src="5d61ca0.png" alt="" /></p>

<p>　　哈希码是通过哈希算法生成的一个字符串，它是用来<strong>唯一</strong>区分我们对象的地址码，就像我们的身份证一样。　　</p>

<p>　　b. 可以通过重写toString()方法表示出对象的属性。</p>

<p>　　如果我们希望输出一个对象的时候，不是它的哈希码，而是它的各个属性值，那我们可以通过重写toString()方法表示出对象的属性。</p>

<p>　2、equals()</p>

<p>　　a、equals（）—-返回值是布尔类型。</p>

<p>　　b、默认的情况下，比较的是对象的<strong>引用</strong>是否指向同一块内存地址——-对象实例化时，即给对象分配内存空间，该内存空间的地址就是内存地址。使用方法如：dog.equals(dog2);</p>

<p>　　c、 如果是两个对象，但想判断两个对象的属性是否相同，则重写equals（）方法。</p>

<p>　以Dog类为例，重写后的equals（）方法如下（当然你可以根据自己想比较的属性来重写，这里我以age属性是否相同来重写equals（）方法）：</p>

<p>　上面有四个判断，它们的含义分别是：</p>

<p>　　1.判断地址是否相同—-if (this == obj)，相同则返回true</p>

<p>　　2.判断对象是否为空—-if (obj == null)，为空则返回false</p>

<p>　　3.<strong>getClass（）可以得到类对象</strong>，判断类型是否一样—–if (getClass() != obj.getClass())，不一样则返回false</p>

<p>　　4.判断属性值是否一样—-if (age != other.age)，不一样返回false</p>

<p>　　5.如果地址相同，对象不为空，类型一样，属性值一样则返回true</p>

<p>　这里要注意的是，理解obj.getClass()得到的类对象和类的对象的区别，以下用图形表示：
<img src="2f7ac19.png" alt="" /></p>

<p>　可以看到，对于类对象我们关心它属于哪个类，拥有什么属性和方法，比如我和你都是属于“人”这个类对象；而类的对象则是一个类的实例化的具体的一个对象。比如我和你是两个不同的人。</p>

<h2 id="三多态">三、多态</h2>

<p>　面向对象的最后一个特性就是多态，那么什么是多态呢？多态就是<strong>对象的多种形态。</strong></p>

<p>java里的多态主要表现在两个方面：</p>

<p><strong>　1.引用多态　　　</strong></p>

<p>　　父类的引用可以指向本类的对象；</p>

<p>　　父类的引用可以指向子类的对象；</p>

<p>　　这两句话是什么意思呢，让我们用代码来体验一下，首先我们创建一个父类Animal和一个子类Dog，在主函数里如下所示：</p>

<p>　　注意：我们不能使用一个子类的引用来指向父类的对象，如：<img src="803ab73.png" alt="" />。</p>

<p>　　这里我们必须深刻理解引用多态的意义，才能更好记忆这种多态的特性。为什么子类的引用不能用来指向父类的对象呢？我在这里通俗给大家讲解一下：就以上面的例子来说，我们能说“狗是一种动物”，但是不能说“动物是一种狗”，狗和动物是父类和子类的继承关系，它们的从属是不能颠倒的。当父类的引用指向子类的对象时，该对象将只是看成一种特殊的父类（里面有重写的方法和属性），反之，一个子类的引用来指向父类的对象是不可行的！！</p>

<p><strong>　2.方法多态</strong></p>

<p>　　根据上述创建的两个对象：本类对象和子类对象，同样都是父类的引用，当我们指向不同的对象时，它们调用的方法也是多态的。</p>

<p>　　创建本类对象时，调用的方法为本类方法；</p>

<p>　　创建子类对象时，调用的方法为子类重写的方法或者继承的方法；</p>

<p>　　使用多态的时候要注意：<strong>如果我们在子类中编写一个独有的方法（没有继承父类的方法），此时就不能通过父类的引用创建的子类对象来调用该方法！！！</strong></p>

<p><strong>　　注意： 继承是多态的基础。</strong></p>

<p><strong>A、引用类型转换　</strong></p>

<p>　了解了多态的含义后，我们在日常使用多态的特性时经常需要进行引用类型转换。</p>

<p>　引用类型转换：</p>

<p>　　1. <strong>向上类型转换</strong>(隐式/自动类型转换)，是小类型转换到大类型。</p>

<p>　 就以上述的父类Animal和一个子类Dog来说明，当父类的引用可以指向子类的对象时，就是<strong>向上类型转换</strong>。如：</p>

<p>　　 2. <strong>向下类型转换</strong>(强制类型转换)，是大类型转换到小类型(有风险,可能出现数据溢出)。</p>

<p>　　将上述代码再加上一行，我们再次将父类转换为子类引用，那么会出现错误，编译器不允许我们直接这么做<strong>，</strong>虽然我们知道这个父类引用指向的就是子类对象，但是编译器认为这种转换是存在风险的<strong>。</strong>如：</p>

<p>　　那么我们该怎么解决这个问题呢，我们可以在animal前加上（Dog）来强制类型转换。如：<img src="1cd2d55.png" alt="" /></p>

<p>　　但是如果父类引用没有指向<strong>该子类的对象</strong>，则不能向下类型转换，虽然编译器不会报错，但是运行的时候程序会出错，如：<img src="89408b4.png" alt="" /></p>

<p>　　其实这就是上面所说的子类的引用指向父类的对象，而强制转换类型也不能转换！！</p>

<p>　　还有一种情况是父类的引用指向<strong>其他子类的对象</strong>，则不能通过强制转为<strong>该子类的对象</strong>。如：</p>

<p>　　这是因为我们在编译的时候进行了强制类型转换，编译时的类型是我们强制转换的类型，所以编译器不会报错，而当我们运行的时候，程序给animal开辟的是Dog类型的内存空间，这与Cat类型内存空间不匹配，所以无法正常转换。这两种情况出错的本质是一样的，所以我们在使用强制类型转换的时候要特别注意这两种错误！！下面有个更安全的方式来实现向下类型转换。。。。</p>

<p>** 3. instanceof运算符，**来解决引用对象的类型，避免类型转换的安全性问题。</p>

<p><strong>instanceof</strong>是Java的一个二元操作符，和==，&gt;，&lt;是同一类东东。由于它是由字母组成的，所以也是Java的保留关键字。<strong>它的作用是测试它左边的对象是否是它右边的类的实例</strong>，返回boolean类型的数据。</p>

<p>　　我们来使用instanceof运算符来规避上面的错误，代码修改如下：</p>

<p>　　利用if语句和instanceof运算符来判断两个对象的类型是否一致。</p>

<p><strong>补充说明：</strong>在比较一个对象是否和另一个对象属于同一个类实例的时候，我们通常可以采用instanceof和getClass两种方法通过两者是否相等来判断，但是两者在判断上面是有差别的。Instanceof进行类型检查规则是:<strong>你属于该类吗？或者你属于该类的派生类吗？</strong>而通过getClass获得类型信息采用==来进行检查是否相等的操作是<strong>严格的判断</strong>,<strong>不会存在继承方面的考虑</strong>；</p>

<p><strong>总结：</strong>在写程序的时候，如果要进行类型转换，我们最好使用instanceof运算符来判断它左边的对象是否是它右边的类的实例，再进行强制转换。</p>

<p><strong>B、抽象类</strong></p>

<p>　定义：抽象类前使用abstract关键字修饰，则该类为抽象类。</p>

<p>　使用抽象类要注意以下几点：</p>

<p>　　1. 抽象类是约束子类必须有什么方法，而并不关注子类如何实现这些方法。</p>

<p>　　2. 抽象类应用场景：</p>

<p>　　　a. 在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法(可实现动态多态)。</p>

<p>　　　b. 从多个具有相同特征的类中抽象出一个抽象类，以这个抽象类作为子类的模板，从而避免子类设计的随意性。</p>

<p>　　3. 抽象类定义抽象方法，只有声明，不需要实现。抽象方法没有方法体以分号结束，抽象方法必须用abstract关键字来修饰。如:</p>

<p>　　4、包含抽象方法的类是抽象类。抽象类中可以包含普通的方法，也可以没有抽象方法。如：</p>

<p>　　5、抽象类不能直接创建，可以定义引用变量来指向子类对象，来实现抽象方法。以上述的Telephone抽象类为例：　　　　　</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1publicabstractclass Telephone {
2publicabstractvoid call();//抽象方法，方法体以分号结束，只有声明，不需要实现3publicvoid message(){
4         System.out.println("我是抽象类的普通方法");
5     }//抽象类中包含普通的方法6 }

1publicclass Phone extends Telephone {
23publicvoid call() {//继承抽象类的子类必须重写抽象方法
4// TODO Auto-generated method stub5         System.out.println("我重写了抽象类的方法");
6    }
78 }
</code></pre></div></div>

<p>　以上是Telephone抽象类和子类Phone的定义，下面我们看main函数里：</p>

<p>运行结果（排错之后）：</p>

<p><strong>C、接口</strong></p>

<p>　1、概念</p>

<p>　　接口可以理解为一种特殊的类，由<strong>全局常量</strong>和公共的<strong>抽象方法</strong>所组成。也可理解为一个特殊的抽象类，因为它含有抽象方法。</p>

<p>　　 如果说类是一种具体实现体，而接口定义了某一批类所需要遵守的规范，接口不关心这些类的内部数据，也不关心这些类里方法的实现细节，它只规定这些类里必须提供的某些方法。（这里与抽象类相似）</p>

<p>　2.接口定义的基本语法</p>

<p>　　　　　　[修饰符] [abstract] interface 接口名 [extends父接口1,2….]（<strong>多继承</strong>）{</p>

<p>　　　　　　　　0…n常量 (public static final)</p>

<p>　　　　　　　　0…n 抽象方法(public abstract)</p>

<p>　　　　　　}</p>

<p>　　其中[ ]里的内容表示可选项，可以写也可以不写;接口中的属性都是常量，即使定义时不添加public static final 修饰符，系统也会自动加上；接口中的方法都是抽象方法，即使定义时不添加public abstract修饰符，系统也会自动加上。</p>

<p>　3.使用接口</p>

<p>　　一个类可以实现一个或多个接口，实现接口使用implements关键字。java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口可以补充。</p>

<p><strong>　　继承父类实现接口的语法为：</strong></p>

<p>[修饰符] class 类名 extends 父类 implements 接口1，接口2…{</p>

<p>　　　　　　　类体部分//如果继承了抽象类，需要实现继承的抽象方法；要实现接口中的抽象方法</p>

<p>　　　　　}</p>

<p><strong>注意：如果要继承父类，继承父类必须在实现接口之前,即extends关键字必须在implements关键字前</strong></p>

<p>补充说明：通常我们在命名一个接口时，经常以I开头，用来区分普通的类。如：IPlayGame</p>

<p>　　以下我们来补充在上述抽象类中的例子，我们之前已经定义了一个抽象类Telephone和子类Phone，这里我们再创建一个IPlayGame的接口，然后在原来定义的两个类稍作修改，代码如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1publicinterface IPlayGame {
2publicvoid paly();//abstract 关键字可以省略，系统会自动加上3public String name="游戏名字";//static final关键字可以省略，系统会自动加上4 }

 1publicclass Phone extends Telephone implements IPlayGame{
 2 3publicvoid call() {//继承抽象类的子类必须重写抽象方法
 4// TODO Auto-generated method stub 5         System.out.println("我重写了抽象类的方法");
 6    }
 7 8    @Override
 9publicvoid paly() {
10// TODO Auto-generated method stub11         System.out.println("我重写了接口的方法");
12    }
1314 }

 1publicclass train {
 2 3 4publicstaticvoid main(String[] args) {
 5// TODO Auto-generated method stub 6         IPlayGame i=new Phone();//用接口的引用指向子类的对象 7         i.paly();//调用接口的方法 8         System.out.println(i.name);//输出接口的常量 9101112}
13 }
</code></pre></div></div>

<p>　运行结果：</p>

<p>　4.接口和匿名内部类配合使用</p>

<p>　　接口在使用过程中还经常和匿名内部类配合使用。匿名内部类就是没有没名字的内部类，多用于关注实现而不关注实现类的名称。</p>

<p>　　语法格式：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 Interface i =newinterface(){
2     Public void method{
3        System.out.println(“利用匿名内部类实现接口1”);
4}
5};
6 i.method();
</code></pre></div></div>

<p>　　还有一种写法：（直接把方法的调用写在匿名内部类的最后）</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1 Interface i =newinterface(){
2 Public void method{
3        System.out.println(“利用匿名内部类实现接口1”);
4}
5 }**.method();**
</code></pre></div></div>

<h2 id="四抽象类和接口的区别">四、抽象类和接口的区别</h2>

<p>　　我们在多态的学习过程中认识到抽象类和接口都是实现java多态特性的关键部分，两者都包含抽象方法，只关注方法的声明而不关注方法的具体实现，那么这两者又有什么区别呢？？我们在编写java程序的时候又该如何抉择呢？</p>

<p>　　参考博文：<a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/felixzh/p/5938544.html">http://www.cnblogs.com/felixzh/p/5938544.html</a></p>

<p>（1）语法层面上的区别</p>

<p>　1.一个类只能继承一个抽象类，而一个类却可以实现多个接口。
2.抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；且必须给其初值，所以实现类中不能重新定义，也不能改变其值；抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。 
3.抽象类中可以有非抽象方法，接口中则不能有非抽象方法。
4.接口可以省略abstract 关键字，抽象类不能。
5.接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；</p>

<p>（2）设计层面上的区别</p>

<p>　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 “是不是”的关系，而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。</p>

<p>　　2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。</p>

<p>　　 下面看一个网上流传最广泛的例子：门和警报的例子：门都有open( )和close( )两个动作，此时我们可以定义通过抽象类和接口来定义这个抽象概念：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1abstractclass Door {
2publicabstractvoid open();
3publicabstractvoid close();
4 }
</code></pre></div></div>

<p>　　　　或者：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1interface Door {
2publicabstractvoid open();
3publicabstractvoid close();
4 }
</code></pre></div></div>

<p>　　但是现在如果我们需要门具有报警alarm( )的功能，那么该如何实现？下面提供两种思路：</p>

<p>　　1）将这三个功能都放在抽象类里面，但是这样一来所有继承于这个抽象类的子类都具备了报警功能，但是有的门并不一定具备报警功能；</p>

<p>　　2）将这三个功能都放在接口里面，需要用到报警功能的类就需要实现这个接口中的open( )和close( )，也许这个类根本就不具备open( )和close( )这两个功能，比如火灾报警器。</p>

<p>　　从这里可以看出， Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为，open()和close()属于门本身固有的行为特性，而alarm()属于延伸的附加行为。因此最好的解决办法是<strong>单独将报警设计为一个接口，包含alarm()行为,Door设计为单独的一个抽象类，包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 1interface Alram {
 2void alarm();
 3}
 4 5abstractclass Door {
 6void open();
 7void close();
 8}
 910class AlarmDoor extends Door implements Alarm {
11void oepn() {
12//....13    }
14void close() {
15//....16    }
17void alarm() {
18//....19    }
20 }
</code></pre></div></div>

<p><strong>　　终于写完了这篇博文，java的这三大特性是面向对象编程的核心和基础，这里的概念的理解对实际编程有非常大的帮助，可能内容过于繁冗了，如果对内容有疑问请在下面留言或者私信我的邮箱，谢谢！！</strong></p>

  </div>
  <div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/java%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7:%E5%B0%81%E8%A3%85%E3%80%81%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%9A%E6%80%81.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/%E5%AE%9E%E7%8E%B0excel%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD-excel%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%E5%88%B0%E9%A1%B5%E9%9D%A2%E4%B8%AD-%E9%A1%B5%E9%9D%A2%E6%95%B0%E6%8D%AE.html">&laquo; 实现excel导入导出功能，excel导入数据到页面中，页面数据导出生成excel文件</a>
  
  
  <a class="next" href="/2017/%E9%A6%92%E5%A4%B4%E5%95%86%E5%AD%A6%E9%99%A2%E5%88%9B%E5%A7%8B%E4%BA%BA%E7%8E%8B%E6%AC%A3:%E6%88%91%E5%92%8C%E9%9B%B7%E5%86%9B%E4%B8%80%E8%B5%B7%E6%8E%A8%E9%94%80%E7%9A%84%E6%97%A5.html">馒头商学院创始人王欣：我和雷军一起推销的日 &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
