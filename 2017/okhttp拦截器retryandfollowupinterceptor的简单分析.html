<!-- build time:Sat Oct 27 2018 21:00:19 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析作者liaoweijian2017.07.11 18:28*字数 1669OKHTTP异步和同步请求简单分析OKHTTP拦截器缓存策略CacheInterceptor的简单分析OKHTTP拦截器ConnectInterceptor的简单分析OKHTTP拦截器CallServerInterceptor的简单分析OKHT"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析"><meta property="og:url" content="http://www.jfox.info/2017/okhttp拦截器retryandfollowupinterceptor的简单分析.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析作者liaoweijian2017.07.11 18:28*字数 1669OKHTTP异步和同步请求简单分析OKHTTP拦截器缓存策略CacheInterceptor的简单分析OKHTTP拦截器ConnectInterceptor的简单分析OKHTTP拦截器CallServerInterceptor的简单分析OKHT"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.420Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析"><meta name="twitter:description" content="OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析作者liaoweijian2017.07.11 18:28*字数 1669OKHTTP异步和同步请求简单分析OKHTTP拦截器缓存策略CacheInterceptor的简单分析OKHTTP拦截器ConnectInterceptor的简单分析OKHTTP拦截器CallServerInterceptor的简单分析OKHT"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/okhttp拦截器retryandfollowupinterceptor的简单分析.html"><title>OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/okhttp拦截器retryandfollowupinterceptor的简单分析.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:56:19+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析"><a href="#OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析" class="headerlink" title="OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析"></a>OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析</h1><p>作者<a href="/u/8173f323f5bb">liaoweijian</a>2017.07.11 18:28*字数 1669<br><a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/3214ef86a52d">OKHTTP异步和同步请求简单分析</a><a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/8d0bc05104ef">OKHTTP拦截器缓存策略CacheInterceptor的简单分析</a><a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/5472521f8d63">OKHTTP拦截器ConnectInterceptor的简单分析</a><a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/4510ae14dbe9">OKHTTP拦截器CallServerInterceptor的简单分析</a><a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/ede34ab5b776">OKHTTP拦截器BridgeInterceptor的简单分析</a><a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/64111e0db93c">OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析</a><a href="https://www.jfox.info/go.php?url=http://www.jianshu.com/p/d04b463806c8">OKHTTP结合官网示例分析两种自定义拦截器的区别</a></p><h1 id="1、RetryAndFollowUpInterceptor的作用"><a href="#1、RetryAndFollowUpInterceptor的作用" class="headerlink" title="1、RetryAndFollowUpInterceptor的作用"></a>1、RetryAndFollowUpInterceptor的作用</h1><p>看到该拦截器的名称就知道，它就是一个负责失败重连的拦截器，如果我们想要实现失败重连，那么就要在 OkHttpClient 进行配置，下面的代码片段是就是进行配置的。不过呢，不是所有的网络请求失败了都可以进行重连的，因此呢，它内部会进行检测网络请求异常和响应码的情况，根据这些情况判断是否需要重新进行网络请求。</p><pre><code>OkHttpClient okHttpClient = new OkHttpClient();
okHttpClient.retryOnConnectionFailure();
</code></pre><p>RetryAndFollowUpInterceptor 是 OKHTTP 内置中的第一个拦截器，其功能主要有以下几点：</p><ul><li>1.创建 StreamAllocation 对象；</li><li>2.调用 RealInterceptorChain.proceed(…)进行网络请求；</li><li>3.根据异常结果或者响应结果判断是否要进行重新请求。</li></ul><p>注意第二和第三点是在 while (true)内部执行的，也就是系统通过死循环来实现重连机制。下面阅读 OKHTTP 源码来看 RetryAndFollowUpInterceptor 内部是怎么实现以上 3 点功能的。</p><h2 id="1-1、创建-StreamAllocation-对象"><a href="#1-1、创建-StreamAllocation-对象" class="headerlink" title="1.1、创建 StreamAllocation 对象"></a>1.1、创建 StreamAllocation 对象</h2><p>StreamAllocation 在 RetryAndFollowUpInterceptor 创建，它会在 ConnectInterceptor 中真正被使用到，主要就是用于获取连接服务端的 Connection 和用于进行跟服务端进行数据传输的输入输出流 HttpStream，具体的操作不是这篇博客的重点，只要了解它的作用的就行了。</p><h2 id="1-2、网络请求"><a href="#1-2、网络请求" class="headerlink" title="1.2、网络请求"></a>1.2、网络请求</h2><p>因为在 OKHTTP 中的拦截器的执行过程是一个递归的过程，也就是它内部会通过 RealInterceptorChain 这个类去负责将所有的拦截器进行串起来。只有所有的拦截器执行完毕之后，一个网络请求的响应 Response 才会被返回。</p><pre><code>拦截器的执行过程.png 
</code></pre><p>但是呢，在执行这个过程中，难免会出现一些问题，例如连接中断，握手失败或者服务器检测到未认证等，那么这个 resposne 的返回码就不是正常的 200 了，因此说这个 response 并不一定是可用的，或者说在请求过程就已经抛出异常了，例如超时异常等，那么 RetryAndFollowUpInterceptor 需要依据这些问题进行判断是否可以进行重新连接。</p><pre><code>while(true){
    try{
        ...
        response = ((RealInterceptorChain) chain).proceed(request, 
        streamAllocation, null, null);
        ...
    }catch(RouteException e){
        //判断 RouteException  否可以重连
    }catch(IOException e){
        //判断 IOException 否可以重连
    }finally{
        //释放流
    }
    ...
}
</code></pre><h3 id="1-3、-网络请求异常的“重连机制”"><a href="#1-3、-网络请求异常的“重连机制”" class="headerlink" title="1.3、 网络请求异常的“重连机制”"></a>1.3、 网络请求异常的“重连机制”</h3><pre><code>public Response proceed(Request request, StreamAllocation 
streamAllocation, HttpStream httpStream,Connection connection) throws IOException {
</code></pre><p>在上面已经介绍过了网络请求时通过 RealInterceptorChain#proceed 方法进行的，该方法的声明中抛出了 IOException ，表示在整个网络请求过程有可能出现 IOException，但是我们看了在 catch 中还有一个异常那就是 RouteException，下面是两个异常的继承结构：</p><ul><li><p>IOException 它是编译时，需要在编译时期就要捕获或者抛出。public class IOException extends Exception</p></li><li><p>RouteException 是运行时异常，不需要显示的去捕获或者抛出。public final class RouteException extends RuntimeException</p><p>try {</p><pre><code>//网络请求
response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);
//表示是否要释放连接，在 finally 中会使用到。
releaseConnection = false;
</code></pre><p>} catch (RouteException e) {</p><pre><code>//路由异常RouteException 
// The attempt to connect via a route failed. The request will not have been sent.
//检测路由异常是否能重新连接
if (!recover(e.getLastConnectException(), true, request)) throw e.getLastConnectException();
//可以重新连接，那么就不要释放连接
releaseConnection = false;
//重新进行while循环，进行网络请求
continue;
</code></pre><p>} catch (IOException e) {</p><pre><code> //检测该IO异常是否能重新连接
// An attempt to communicate with a server failed. The request may have been sent.
if (!recover(e, false, request)) throw e;
//可以重新连接，那么就不要释放连接
releaseConnection = false;
</code></pre><p>//重新进行while循环，进行网络请求</p><pre><code>continue;
</code></pre><p>} finally {</p><pre><code>//当 releaseConnection 为true时表示需要释放连接了。
// We&apos;re throwing an unchecked exception. Release any resources.
if (releaseConnection) {
  streamAllocation.streamFailed(null);
  streamAllocation.release();
}
</code></pre></li></ul><h4 id="1-3-1、RouteException-异常的重连机制"><a href="#1-3-1、RouteException-异常的重连机制" class="headerlink" title="1.3.1、RouteException 异常的重连机制"></a>1.3.1、RouteException 异常的重连机制</h4><p>在 RouteException 的重连机制主要做了这样几件事：</p><ul><li>通过 recover 方法检测该 RouteException 是否能重新连接；</li><li>可以重新连接，那么就不要释放连接 releaseConnection = false；</li><li>continue进入下一次循环，进行网络请求；</li><li>不可以重新连接就直接走 finally 代码块释放连接。</li></ul><p>下面是通过 find Usages 得到 RouteException 被哪里抛出的图，从图可以看出 RouteException 是在获取一个 HttpStream 流和与 SOCKET 创建连接时出现异常才被抛出的，在抛异常的方法内部并没有显示地去捕获，因此异常会被 RetryAndFollowUpInterceptor#intercept 中的 catch 捕获，下面就是对捕获的异常的处理。</p><pre><code>RouteException的抛出.png 
</code></pre><p>查看源码可以知道 RouteException 和 IOException 异常检测都会调用 recover 方法进行判断，主要是第二个参数不一样，这里传入的是true，表示该异常是 RouteException ，下面 IOException 检测时传入的参数时 false 。</p><pre><code>if (!recover(e.getLastConnectException(), true, request)) throw 
e.getLastConnectException();
</code></pre><h4 id="1-3-2、-recover-方法异常检测"><a href="#1-3-2、-recover-方法异常检测" class="headerlink" title="1.3.2、 recover 方法异常检测"></a>1.3.2、 recover 方法异常检测</h4><pre><code>private boolean recover(IOException e, boolean routeException, Request userRequest) {
  streamAllocation.streamFailed(e);
  //1.判断 OkHttpClient 是否支持失败重连的机制
  // The application layer has forbidden retries.
  if (!client.retryOnConnectionFailure()) return false;
  // 在该方法中传入的 routeException值 为 true
  // We can&apos;t send the request body again.
  if (!routeException &amp;&amp; userRequest.body() instanceof UnrepeatableRequestBody) return false;
  //2.isRecoverable 检测该异常是否是致命的。
  // This exception is fatal.
  if (!isRecoverable(e, routeException)) return false;
  // No more routes to attempt.
  //3.是否有更多的路线
  if (!streamAllocation.hasMoreRoutes()) return false;
  // For failure recovery, use the same route selector with a new connection.
  return true;
}
</code></pre><p>从上面源码可以看出 recover 方法主要做了以下几件事：</p><ul><li><p>1.判断 OkHttpClient 是否支持失败重连的机制；</p></li><li><p>如果不支持重连，就表示请求失败就失败了，不能再重试了。</p></li><li><p>2.通过 isRecoverable 方法检测该异常是否是致命的；</p></li><li>3.是否有更多的路线，可以重试。</li></ul><h4 id="1-3-3、isRecoverable-方法异常检测"><a href="#1-3-3、isRecoverable-方法异常检测" class="headerlink" title="1.3.3、isRecoverable 方法异常检测"></a>1.3.3、isRecoverable 方法异常检测</h4><p>在该方法中会检测异常是否为严重异常，严重异常就不要进行重连了，下面检测的异常都做了注释。这里涉及到一个 SocketTimeoutException 的异常，表示连接超时异常，这个异常还是可以进行重连的，也就是说<strong> OKHTTP 内部在连接超时时是会自动进行重连的。</strong></p><pre><code>private boolean isRecoverable(IOException e, boolean routeException) {
  //ProtocolException 这种异常属于严重异常，不能进行重新连接
  // If there was a protocol problem, don&apos;t recover.
  if (e instanceof ProtocolException) {
    return false;
  }
  //当异常为中断异常时
  // If there was an interruption don&apos;t recover, but if there was a timeout connecting to a route
  // we should try the next route (if there is one).
  if (e instanceof InterruptedIOException) {
    return e instanceof SocketTimeoutException &amp;&amp; routeException;
  }
  // Look for known client-side or negotiation errors that are unlikely to be fixed by trying
  // again with a different route.
  //握手异常
  if (e instanceof SSLHandshakeException) {
    // If the problem was a CertificateException from the X509TrustManager,
    // do not retry.
    if (e.getCause() instanceof CertificateException) {
      return false;
    }
  }
  //验证异常
  if (e instanceof SSLPeerUnverifiedException) {
    // e.g. a certificate pinning error.
    return false;
  }
  // An example of one we might want to retry with a different route is a problem connecting to a
  // proxy and would manifest as a standard IOException. Unless it is one we know we should not
  // retry, we return true and try a new route.
  return true;
}
</code></pre><h4 id="1-3-4、IOException-异常的重连机制"><a href="#1-3-4、IOException-异常的重连机制" class="headerlink" title="1.3.4、IOException 异常的重连机制"></a>1.3.4、IOException 异常的重连机制</h4><p>IOException 异常的检测实际上和 RouteException 是一样的，只是传入 recover 方法的第二个参数为 false 而已，表示该异常不是 RouteException ，这里就不分析了。</p><pre><code>// An attempt to communicate with a server failed. The request may 
//have been sent.
if (!recover(e, false, request)) throw e;
</code></pre><h3 id="1-4、followUpRequest-响应码检测"><a href="#1-4、followUpRequest-响应码检测" class="headerlink" title="1.4、followUpRequest 响应码检测"></a>1.4、followUpRequest 响应码检测</h3><p>当代码可以执行到 followUpRequest 方法就表示这个请求是成功的，但是服务器返回的状态码可能不是 200 ok 的情况，这时还需要对该请求进行检测，其主要就是通过返回码进行判断的。</p><pre><code>private Request followUpRequest(Response userResponse) throws IOException {
  if (userResponse == null) throw new IllegalStateException();
  Connection connection = streamAllocation.connection();
  Route route = connection != null
      ? connection.route()
      : null;
  int responseCode = userResponse.code();
  final String method = userResponse.request().method();
  switch (responseCode) {
    case HTTP_PROXY_AUTH:
      Proxy selectedProxy = route != null
          ? route.proxy()
          : client.proxy();
      if (selectedProxy.type() != Proxy.Type.HTTP) {
        throw new ProtocolException(&quot;Received HTTP_PROXY_AUTH (407) code while not using proxy&quot;);
      }
      return client.proxyAuthenticator().authenticate(route, userResponse);
    case HTTP_UNAUTHORIZED:
      return client.authenticator().authenticate(route, userResponse);
    case HTTP_PERM_REDIRECT:
    case HTTP_TEMP_REDIRECT:
      // &quot;If the 307 or 308 status code is received in response to a request other than GET
      // or HEAD, the user agent MUST NOT automatically redirect the request&quot;
      if (!method.equals(&quot;GET&quot;) &amp;&amp; !method.equals(&quot;HEAD&quot;)) {
        return null;
      }
      // fall-through
    case HTTP_MULT_CHOICE:
    case HTTP_MOVED_PERM:
    case HTTP_MOVED_TEMP:
    case HTTP_SEE_OTHER:
      // Does the client allow redirects?
      if (!client.followRedirects()) return null;
      String location = userResponse.header(&quot;Location&quot;);
      if (location == null) return null;
      HttpUrl url = userResponse.request().url().resolve(location);
      // Don&apos;t follow redirects to unsupported protocols.
      if (url == null) return null;
      // If configured, don&apos;t follow redirects between SSL and non-SSL.
      boolean sameScheme = url.scheme().equals(userResponse.request().url().scheme());
      if (!sameScheme &amp;&amp; !client.followSslRedirects()) return null;
      // Redirects don&apos;t include a request body.
      Request.Builder requestBuilder = userResponse.request().newBuilder();
      if (HttpMethod.permitsRequestBody(method)) {
        if (HttpMethod.redirectsToGet(method)) {
          requestBuilder.method(&quot;GET&quot;, null);
        } else {
          requestBuilder.method(method, null);
        }
        requestBuilder.removeHeader(&quot;Transfer-Encoding&quot;);
        requestBuilder.removeHeader(&quot;Content-Length&quot;);
        requestBuilder.removeHeader(&quot;Content-Type&quot;);
      }
      // When redirecting across hosts, drop all authentication headers. This
      // is potentially annoying to the application layer since they have no
      // way to retain them.
      if (!sameConnection(userResponse, url)) {
        requestBuilder.removeHeader(&quot;Authorization&quot;);
      }
      return requestBuilder.url(url).build();
    case HTTP_CLIENT_TIMEOUT:
      // 408&apos;s are rare in practice, but some servers like HAProxy use this response code. The
      // spec says that we may repeat the request without modifications. Modern browsers also
      // repeat the request (even non-idempotent ones.)
      if (userResponse.request().body() instanceof UnrepeatableRequestBody) {
        return null;
      }
      return userResponse.request();
    default:
      return null;
  }
}
</code></pre><p>下面是服务器返回的状态码的判断，对于这些状态我都没遇到过，在这里只是将其列举出来而已。</p><ul><li><p>407 HTTP_PROXY_AUTH 表示需要经过代理服务器认证；</p></li><li><p>401 HTTP_UNAUTHORIZED 身份未认证；</p></li><li><p>307HTTP_TEMP_REDIRECT 308HTTP_PERM_REDIRECT 重定向（只有是 GET 和 HEAD）才可以；</p></li><li><p>300HTTP_MULT_CHOICE 301HTTP_MOVED_PERM ；</p></li><li><p>302 HTTP_MOVED_TEMP 303HTTP_SEE_OTHER 通过client.followRedirects()判断是否运行重定向，之后获取响应头 Location 值，这就是要重定向的地址；</p></li><li><p>HTTP_CLIENT_TIMEOUT 客户端超时的情况。</p></li></ul><h3 id="1-5、重试次数判断"><a href="#1-5、重试次数判断" class="headerlink" title="1.5、重试次数判断"></a>1.5、重试次数判断</h3><p>在 RetryAndFollowUpInterceptor 内部有一个 MAX_FOLLOW_UPS 常量，它表示该请求可以重试多少次，在 OKHTTP 内部中是不能超过 20 次，如果超过 20 次，那么就不会再请求了。</p><pre><code>private static final int MAX_FOLLOW_UPS = 20;

if (++followUpCount &gt; MAX_FOLLOW_UPS) {
  streamAllocation.release();
  throw new ProtocolException(&quot;Too many follow-up requests: &quot; + followUpCount);
}
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/java设置一段代码执行的超时时间.html" rel="next" title="Java设置一段代码执行的超时时间"><i class="fa fa-chevron-left"></i> Java设置一段代码执行的超时时间</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/android自定义万能canvas画布.html" rel="prev" title="Android自定义万能Canvas画布">Android自定义万能Canvas画布 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析"><span class="nav-number">1.</span> <span class="nav-text">OKHTTP拦截器RetryAndFollowUpInterceptor的简单分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1、RetryAndFollowUpInterceptor的作用"><span class="nav-number">2.</span> <span class="nav-text">1、RetryAndFollowUpInterceptor的作用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1、创建-StreamAllocation-对象"><span class="nav-number">2.1.</span> <span class="nav-text">1.1、创建 StreamAllocation 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2、网络请求"><span class="nav-number">2.2.</span> <span class="nav-text">1.2、网络请求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3、-网络请求异常的“重连机制”"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.3、 网络请求异常的“重连机制”</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1、RouteException-异常的重连机制"><span class="nav-number">2.2.1.1.</span> <span class="nav-text">1.3.1、RouteException 异常的重连机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2、-recover-方法异常检测"><span class="nav-number">2.2.1.2.</span> <span class="nav-text">1.3.2、 recover 方法异常检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3、isRecoverable-方法异常检测"><span class="nav-number">2.2.1.3.</span> <span class="nav-text">1.3.3、isRecoverable 方法异常检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4、IOException-异常的重连机制"><span class="nav-number">2.2.1.4.</span> <span class="nav-text">1.3.4、IOException 异常的重连机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4、followUpRequest-响应码检测"><span class="nav-number">2.2.2.</span> <span class="nav-text">1.4、followUpRequest 响应码检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5、重试次数判断"><span class="nav-number">2.2.3.</span> <span class="nav-text">1.5、重试次数判断</span></a></li></ol></li></ol></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->