<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>阿里消息队列中间件 RocketMQ源码解析：Message顺序发送与消费 | Java面试</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="阿里消息队列中间件 RocketMQ源码解析：Message顺序发送与消费" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="阿里消息队列中间件 RocketMQ源码解析：Message顺序发送与消费 RocketMQ / MyCAT / Sharding-JDBC 所有源码分析文章列表 RocketMQ / MyCAT / Sharding-JDBC 中文注释源码 GitHub 地址 您对于源码的疑问每条留言都将得到认真回复。甚至不知道如何读源码也可以请教噢。 新的源码解析文章实时收到通知。每周更新一篇左右。 认真的源码交流微信群。 1. 概述 2. Producer 顺序发送 3. Consumer 顺序消费 3.1 获得(锁定)消息队列 3.2 移除消息队列 3.3 消费消息队列 3.1.1 消费消息 3.1.2 处理消费结果 3.13 消息处理队列核心方法 1. 概述 建议前置阅读内容： 当然对 Message 发送与消费已经有一定了解的同学，可以选择跳过。 RocketMQ 提供了两种顺序级别： 普通顺序消息 ：Producer 将相关联的消息发送到相同的消息队列。 完全严格顺序 ：在 普通顺序消息 的基础上，Consumer 严格顺序消费。 绝大部分场景下只需要用到普通顺序消息。 例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，不会产生系统逻辑上BUG。另外，普通顺序消息性能能更加好。 那么什么时候使用使用完全严格顺序？如下是来自官方文档的说明： 目前已知的应用只有数据库 binlog 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息 😈上代码！！！ 2. Producer 顺序发送 官方发送顺序消息的例子： 1: package org.apache.rocketmq.example.ordermessage; 2: 3: import java.io.UnsupportedEncodingException; 4: import java.util.List; 5: import org.apache.rocketmq.client.exception.MQBrokerException; 6: import org.apache.rocketmq.client.exception.MQClientException; 7: import org.apache.rocketmq.client.producer.DefaultMQProducer; 8: import org.apache.rocketmq.client.producer.MQProducer; 9: import org.apache.rocketmq.client.producer.MessageQueueSelector; 10: import org.apache.rocketmq.client.producer.SendResult; 11: import org.apache.rocketmq.common.message.Message; 12: import org.apache.rocketmq.common.message.MessageQueue; 13: import org.apache.rocketmq.remoting.common.RemotingHelper; 14: import org.apache.rocketmq.remoting.exception.RemotingException; 15: 16: public class Producer { 17: public static void main(String[] args) throws UnsupportedEncodingException { 18: try { 19: MQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;); 20: producer.start(); 21: 22: String[] tags = new String[] {&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;}; 23: for (int i = 0; i &lt; 100; i++) { 24: int orderId = i % 10; 25: Message msg = 26: new Message(&quot;TopicTestjjj&quot;, tags[i % tags.length], &quot;KEY&quot; + i, 27: (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET)); 28: SendResult sendResult = producer.send(msg, new MessageQueueSelector() { 29: @Override 30: public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) { 31: Integer id = (Integer) arg; 32: int index = id % mqs.size(); 33: return mqs.get(index); 34: } 35: }, orderId); 36: 37: System.out.printf(&quot;%s%n&quot;, sendResult); 38: } 39: 40: producer.shutdown(); 41: } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) { 42: e.printStackTrace(); 43: } 44: } 45: } 第 28 至 35 行 ：实现了根据 id % mqs.size() 来进行消息队列的选择。当前例子，我们传递 orderId 作为参数，那么相同的 orderId 能够进入相同的消息队列。 MessageQueueSelector 接口的源码： 1: public interface MessageQueueSelector { 2: 3: /** 4: * 选择消息队列 5: * 6: * @param mqs 消息队列 7: * @param msg 消息 8: * @param arg 参数 9: * @return 消息队列 10: */ 11: MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg); 12: } Producer 选择队列发送消息方法的源码： 16: private SendResult sendSelectImpl(// 17: Message msg, // 18: MessageQueueSelector selector, // 19: Object arg, // 20: final CommunicationMode communicationMode, // 21: final SendCallback sendCallback, final long timeout// 22: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { 23: this.makeSureStateOK(); 24: Validators.checkMessage(msg, this.defaultMQProducer); 25: 26: TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); 27: if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) { 28: MessageQueue mq = null; 29: try { 30: mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg); 31: } catch (Throwable e) { 32: throw new MQClientException(&quot;select message queue throwed exception.&quot;, e); 33: } 34: 35: if (mq != null) { 36: return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout); 37: } else { 38: throw new MQClientException(&quot;select message queue return null.&quot;, null); 39: } 40: } 41: 42: throw new MQClientException(&quot;No route info for this topic, &quot; + msg.getTopic(), null); 43: } 第 30 行 ：选择消息队列。 第 36 行 ：发送消息。 3. Consumer 严格顺序消费 Consumer 在严格顺序消费时，通过 三 把锁保证严格顺序消费。 Broker 消息队列锁（分布式锁） ： 集群模式下，Consumer 从 Broker 获得该锁后，才能进行消息拉取、消费。 广播模式下，Consumer 无需该锁。 Consumer 消息队列锁（本地锁） ：Consumer 获得该锁才能操作消息队列。 Consumer 消息处理队列消费锁（本地锁） ：Consumer 获得该锁才能消费消息队列。 可能同学有疑问，为什么有 Consumer 消息队列锁还需要有 Consumer 消息队列消费锁呢？😈让我们带着疑问继续往下看。 3.1 获得(锁定)消息队列 集群模式下，Consumer 更新属于自己的消息队列时，会向 Broker 锁定该消息队列（广播模式下不需要）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下： 1: // ⬇️⬇️⬇️【RebalanceImpl.java】 2: private boolean updateProcessQueueTableInRebalance(final String topic, final Set&lt;MessageQueue&gt; mqSet, final boolean isOrder) { 3: // ..... 此处省略部分代码 4: // 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。 5: List&lt;PullRequest&gt; pullRequestList = new ArrayList&lt;&gt;(); // 拉消息请求数组 6: for (MessageQueue mq : mqSet) { 7: if (!this.processQueueTable.containsKey(mq)) { 8: if (isOrder &amp;&amp; !this.lock(mq)) { // 顺序消息锁定消息队列 9: log.warn(&quot;doRebalance, {}, add a new mq failed, {}, because lock failed&quot;, consumerGroup, mq); 10: continue; 11: } 12: 13: this.removeDirtyOffset(mq); 14: ProcessQueue pq = new ProcessQueue(); 15: long nextOffset = this.computePullFromWhere(mq); 16: if (nextOffset &gt;= 0) { 17: ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq); 18: if (pre != null) { 19: log.info(&quot;doRebalance, {}, mq already exists, {}&quot;, consumerGroup, mq); 20: } else { 21: log.info(&quot;doRebalance, {}, add a new mq, {}&quot;, consumerGroup, mq); 22: PullRequest pullRequest = new PullRequest(); 23: pullRequest.setConsumerGroup(consumerGroup); 24: pullRequest.setNextOffset(nextOffset); 25: pullRequest.setMessageQueue(mq); 26: pullRequest.setProcessQueue(pq); 27: pullRequestList.add(pullRequest); 28: changed = true; 29: } 30: } else { 31: log.warn(&quot;doRebalance, {}, add new mq failed, {}&quot;, consumerGroup, mq); 32: } 33: } 34: } 35: 36: // ..... 此处省略部分代码 37: } 38: 39: // ⬇️⬇️⬇️【RebalanceImpl.java】 40: /** 41: * 请求Broker获得指定消息队列的分布式锁 42: * 43: * @param mq 队列 44: * @return 是否成功 45: */ 46: public boolean lock(final MessageQueue mq) { 47: FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true); 48: if (findBrokerResult != null) { 49: LockBatchRequestBody requestBody = new LockBatchRequestBody(); 50: requestBody.setConsumerGroup(this.consumerGroup); 51: requestBody.setClientId(this.mQClientFactory.getClientId()); 52: requestBody.getMqSet().add(mq); 53: 54: try { 55: // 请求Broker获得指定消息队列的分布式锁 56: Set&lt;MessageQueue&gt; lockedMq = 57: this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000); 58: 59: // 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。 60: for (MessageQueue mmqq : lockedMq) { 61: ProcessQueue processQueue = this.processQueueTable.get(mmqq); 62: if (processQueue != null) { 63: processQueue.setLocked(true); 64: processQueue.setLastLockTimestamp(System.currentTimeMillis()); 65: } 66: } 67: 68: boolean lockOK = lockedMq.contains(mq); 69: log.info(&quot;the message queue lock {}, {} {}&quot;, 70: lockOK ? &quot;OK&quot; : &quot;Failed&quot;, 71: this.consumerGroup, 72: mq); 73: return lockOK; 74: } catch (Exception e) { 75: log.error(&quot;lockBatchMQ exception, &quot; + mq, e); 76: } 77: } 78: 79: return false; 80: } ⬆️⬆️⬆️ 第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。 Broker 消息队列锁会过期，默认配置 30s。因此，Consumer 需要不断向 Broker 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下： 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: public void start() { 3: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) { 4: this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { 5: @Override 6: public void run() { 7: ConsumeMessageOrderlyService.this.lockMQPeriodically(); 8: } 9: }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS); 10: } 11: } 3.2 移除消息队列 集群模式下，Consumer 移除自己的消息队列时，会向 Broker 解锁该消息队列（广播模式下不需要）。核心代码如下： 1: // ⬇️⬇️⬇️【RebalancePushImpl.java】 2: /** 3: * 移除不需要的队列相关的信息 4: * 1. 持久化消费进度，并移除之 5: * 2. 顺序消费&amp;集群模式，解锁对该队列的锁定 6: * 7: * @param mq 消息队列 8: * @param pq 消息处理队列 9: * @return 是否移除成功 10: */ 11: @Override 12: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) { 13: // 同步队列的消费进度，并移除之。 14: this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq); 15: this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq); 16: // 集群模式下，顺序消费移除时，解锁对队列的锁定 17: if (this.defaultMQPushConsumerImpl.isConsumeOrderly() 18: &amp;&amp; MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) { 19: try { 20: if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) { 21: try { 22: return this.unlockDelay(mq, pq); 23: } finally { 24: pq.getLockConsume().unlock(); 25: } 26: } else { 27: log.warn(&quot;[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}&quot;, // 28: mq, // 29: pq.getTryUnlockTimes()); 30: 31: pq.incTryUnlockTimes(); 32: } 33: } catch (Exception e) { 34: log.error(&quot;removeUnnecessaryMessageQueue Exception&quot;, e); 35: } 36: 37: return false; 38: } 39: return true; 40: } 41: 42: // ⬇️⬇️⬇️【RebalancePushImpl.java】 43: /** 44: * 延迟解锁 Broker 消息队列锁 45: * 当消息处理队列不存在消息，则直接解锁 46: * 47: * @param mq 消息队列 48: * @param pq 消息处理队列 49: * @return 是否解锁成功 50: */ 51: private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) { 52: if (pq.hasTempMessage()) { // TODO 疑问：为什么要延迟移除 53: log.info(&quot;[{}]unlockDelay, begin {} &quot;, mq.hashCode(), mq); 54: this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() { 55: @Override 56: public void run() { 57: log.info(&quot;[{}]unlockDelay, execute at once {}&quot;, mq.hashCode(), mq); 58: RebalancePushImpl.this.unlock(mq, true); 59: } 60: }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS); 61: } else { 62: this.unlock(mq, true); 63: } 64: return true; 65: } ⬆️⬆️⬆️ 第 20 至 32 行 ：获取消息队列消费锁，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的 Consumer 和当前 Consumer 同时消费该消息队列，导致消息无法严格顺序消费。 第 51 至 64 行 ：解锁 Broker 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 Broker 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。 3.3 消费消息队列 😏本节会类比并发消费消费队列，建议对照 PushConsumer并发消费消息 一起理解。 3.1.1 消费消息 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: class ConsumeRequest implements Runnable { 3: 4: /** 5: * 消息处理队列 6: */ 7: private final ProcessQueue processQueue; 8: /** 9: * 消息队列 10: */ 11: private final MessageQueue messageQueue; 12: 13: @Override 14: public void run() { 15: if (this.processQueue.isDropped()) { 16: log.warn(&quot;run, the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 17: return; 18: } 19: 20: // 获得 Consumer 消息队列锁 21: final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue); 22: synchronized (objLock) { 23: // (广播模式) 或者 (集群模式 &amp;&amp; Broker消息队列锁有效) 24: if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 25: || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())) { 26: final long beginTime = System.currentTimeMillis(); 27: // 循环 28: for (boolean continueConsume = true; continueConsume; ) { 29: if (this.processQueue.isDropped()) { 30: log.warn(&quot;the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 31: break; 32: } 33: 34: // 消息队列分布式锁未锁定，提交延迟获得锁并消费请求 35: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 36: &amp;&amp; !this.processQueue.isLocked()) { 37: log.warn(&quot;the message queue not locked, so consume later, {}&quot;, this.messageQueue); 38: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); 39: break; 40: } 41: // 消息队列分布式锁已经过期，提交延迟获得锁并消费请求 42: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 43: &amp;&amp; this.processQueue.isLockExpired()) { 44: log.warn(&quot;the message queue lock expired, so consume later, {}&quot;, this.messageQueue); 45: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); 46: break; 47: } 48: 49: // 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。 50: long interval = System.currentTimeMillis() - beginTime; 51: if (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) { 52: ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10); 53: break; 54: } 55: 56: // 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。 57: final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize(); 58: List&lt;MessageExt&gt; msgs = this.processQueue.takeMessags(consumeBatchSize); 59: if (!msgs.isEmpty()) { 60: final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue); 61: 62: ConsumeOrderlyStatus status = null; 63: 64: // ....省略代码：Hook：before 65: 66: // 执行消费 67: long beginTimestamp = System.currentTimeMillis(); 68: ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; 69: boolean hasException = false; 70: try { 71: this.processQueue.getLockConsume().lock(); // 锁定队列消费锁 72: 73: if (this.processQueue.isDropped()) { 74: log.warn(&quot;consumeMessage, the message queue not be able to consume, because it&#39;s dropped. {}&quot;, 75: this.messageQueue); 76: break; 77: } 78: 79: status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context); 80: } catch (Throwable e) { 81: log.warn(&quot;consumeMessage exception: {} Group: {} Msgs: {} MQ: {}&quot;, // 82: RemotingHelper.exceptionSimpleDesc(e), // 83: ConsumeMessageOrderlyService.this.consumerGroup, // 84: msgs, // 85: messageQueue); 86: hasException = true; 87: } finally { 88: this.processQueue.getLockConsume().unlock(); // 锁定队列消费锁 89: } 90: 91: // ....省略代码：解析消费结果状态 92: 93: // ....省略代码：Hook：after 94: 95: ConsumeMessageOrderlyService.this.getConsumerStatsManager() 96: .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT); 97: 98: // 处理消费结果 99: continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this); 100: } else { 101: continueConsume = false; 102: } 103: } 104: } else { 105: if (this.processQueue.isDropped()) { 106: log.warn(&quot;the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 107: return; 108: } 109: 110: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100); 111: } 112: } 113: } 114: 115: } ⬆️⬆️⬆️ 第 20 行 ：获得 Consumer 消息队列锁。 第 58 行 ：从消息处理队列顺序获得消息。和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。 第 71 行 ：获得 Consumer 消息处理队列消费锁。相比【Consumer消息队列锁】，其粒度较小。这就是上文提到的❓为什么有Consumer消息队列锁还需要有 Consumer 消息队列消费锁呢的原因。 第 79 行 ：执行消费。 第 99 行 ：处理消费结果。 3.1.2 处理消费结果 顺序消费消息结果 (ConsumeOrderlyStatus) 有四种情况： SUCCESS ：消费成功但不提交。 ROLLBACK ：消费失败，消费回滚。 COMMIT ：消费成功提交并且提交。 SUSPEND_CURRENT_QUEUE_A_MOMENT ：消费失败，挂起消费队列一会会，稍后继续消费。 考虑到 ROLLBACK 、COMMIT 暂时只使用在 MySQL binlog 场景，官方将这两状态标记为 @Deprecated。当然，相应的实现逻辑依然保留。 在并发消费场景时，如果消费失败，Consumer 会将消费失败消息发回到 Broker 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。 但是在完全严格顺序消费消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。 不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，Consumer 会将消费失败超过上限的消息发回到 Broker 死信队列。 让我们来看看代码： 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: /** 3: * 处理消费结果，并返回是否继续消费 4: * 5: * @param msgs 消息 6: * @param status 消费结果状态 7: * @param context 消费Context 8: * @param consumeRequest 消费请求 9: * @return 是否继续消费 10: */ 11: public boolean processConsumeResult(// 12: final List&lt;MessageExt&gt; msgs, // 13: final ConsumeOrderlyStatus status, // 14: final ConsumeOrderlyContext context, // 15: final ConsumeRequest consumeRequest// 16: ) { 17: boolean continueConsume = true; 18: long commitOffset = -1L; 19: if (context.isAutoCommit()) { 20: switch (status) { 21: case COMMIT: 22: case ROLLBACK: 23: log.warn(&quot;the message queue consume result is illegal, we think you want to ack these message {}&quot;, consumeRequest.getMessageQueue()); 24: case SUCCESS: 25: // 提交消息已消费成功到消息处理队列 26: commitOffset = consumeRequest.getProcessQueue().commit(); 27: // 统计 28: this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 29: break; 30: case SUSPEND_CURRENT_QUEUE_A_MOMENT: 31: // 统计 32: this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 33: if (checkReconsumeTimes(msgs)) { // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms 34: // 设置消息重新消费 35: consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs); 36: // 提交延迟消费请求 37: this.submitConsumeRequestLater(// 38: consumeRequest.getProcessQueue(), // 39: consumeRequest.getMessageQueue(), // 40: context.getSuspendCurrentQueueTimeMillis()); 41: continueConsume = false; 42: } else { 43: commitOffset = consumeRequest.getProcessQueue().commit(); 44: } 45: break; 46: default: 47: break; 48: } 49: } else { 50: switch (status) { 51: case SUCCESS: 52: this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 53: break; 54: case COMMIT: 55: // 提交消息已消费成功到消息处理队列 56: commitOffset = consumeRequest.getProcessQueue().commit(); 57: break; 58: case ROLLBACK: 59: // 设置消息重新消费 60: consumeRequest.getProcessQueue().rollback(); 61: this.submitConsumeRequestLater(// 62: consumeRequest.getProcessQueue(), // 63: consumeRequest.getMessageQueue(), // 64: context.getSuspendCurrentQueueTimeMillis()); 65: continueConsume = false; 66: break; 67: case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms 68: this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 69: if (checkReconsumeTimes(msgs)) { 70: // 设置消息重新消费 71: consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs); 72: // 提交延迟消费请求 73: this.submitConsumeRequestLater(// 74: consumeRequest.getProcessQueue(), // 75: consumeRequest.getMessageQueue(), // 76: context.getSuspendCurrentQueueTimeMillis()); 77: continueConsume = false; 78: } 79: break; 80: default: 81: break; 82: } 83: } 84: 85: // 消息处理队列未dropped，提交有效消费进度 86: if (commitOffset &gt;= 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) { 87: this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false); 88: } 89: 90: return continueConsume; 91: } 92: 93: private int getMaxReconsumeTimes() { 94: // default reconsume times: Integer.MAX_VALUE 95: if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) { 96: return Integer.MAX_VALUE; 97: } else { 98: return this.defaultMQPushConsumer.getMaxReconsumeTimes(); 99: } 100: } 101: 102: /** 103: * 计算是否要暂停消费 104: * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功 105: * 106: * @param msgs 消息 107: * @return 是否要暂停 108: */ 109: private boolean checkReconsumeTimes(List&lt;MessageExt&gt; msgs) { 110: boolean suspend = false; 111: if (msgs != null &amp;&amp; !msgs.isEmpty()) { 112: for (MessageExt msg : msgs) { 113: if (msg.getReconsumeTimes() &gt;= getMaxReconsumeTimes()) { 114: MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes())); 115: if (!sendMessageBack(msg)) { // 发回失败，中断 116: suspend = true; 117: msg.setReconsumeTimes(msg.getReconsumeTimes() + 1); 118: } 119: } else { 120: suspend = true; 121: msg.setReconsumeTimes(msg.getReconsumeTimes() + 1); 122: } 123: } 124: } 125: return suspend; 126: } 127: 128: /** 129: * 发回消息。 130: * 消息发回broker后，对应的消息队列是死信队列。 131: * 132: * @param msg 消息 133: * @return 是否发送成功 134: */ 135: public boolean sendMessageBack(final MessageExt msg) { 136: try { 137: // max reconsume times exceeded then send to dead letter queue. 138: Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody()); 139: String originMsgId = MessageAccessor.getOriginMessageId(msg); 140: MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId); 141: newMsg.setFlag(msg.getFlag()); 142: MessageAccessor.setProperties(newMsg, msg.getProperties()); 143: MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic()); 144: MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes())); 145: MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes())); 146: newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes()); 147: 148: this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg); 149: return true; 150: } catch (Exception e) { 151: log.error(&quot;sendMessageBack exception, group: &quot; + this.consumerGroup + &quot; msg: &quot; + msg.toString(), e); 152: } 153: 154: return false; 155: } ⬆️⬆️⬆️ 第 21 至 29 行 ：消费成功。在自动提交进度( AutoCommit )的情况下，COMMIT、ROLLBACK、SUCCESS 逻辑已经统一。 第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 Broker 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。 第 85 至 88 行 ：提交消费进度。 3.13 消息处理队列核心方法 😈涉及到的四个核心方法的源码： 1: // ⬇️⬇️⬇️【ProcessQueue.java】 2: /** 3: * 消息映射 4: * key：消息队列位置 5: */ 6: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMap = new TreeMap&lt;&gt;(); /** 7: * 消息映射临时存储（消费中的消息） 8: */ 9: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = new TreeMap&lt;&gt;(); 10: 11: /** 12: * 回滚消费中的消息 13: * 逻辑类似于{@link #makeMessageToCosumeAgain(List)} 14: */ 15: public void rollback() { 16: try { 17: this.lockTreeMap.writeLock().lockInterruptibly(); 18: try { 19: this.msgTreeMap.putAll(this.msgTreeMapTemp); 20: this.msgTreeMapTemp.clear(); 21: } finally { 22: this.lockTreeMap.writeLock().unlock(); 23: } 24: } catch (InterruptedException e) { 25: log.error(&quot;rollback exception&quot;, e); 26: } 27: } 28: 29: /** 30: * 提交消费中的消息已消费成功，返回消费进度 31: * 32: * @return 消费进度 33: */ 34: public long commit() { 35: try { 36: this.lockTreeMap.writeLock().lockInterruptibly(); 37: try { 38: // 消费进度 39: Long offset = this.msgTreeMapTemp.lastKey(); 40: 41: // 42: msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1)); 43: 44: // 45: this.msgTreeMapTemp.clear(); 46: 47: // 返回消费进度 48: if (offset != null) { 49: return offset + 1; 50: } 51: } finally { 52: this.lockTreeMap.writeLock().unlock(); 53: } 54: } catch (InterruptedException e) { 55: log.error(&quot;commit exception&quot;, e); 56: } 57: 58: return -1; 59: } 60: 61: /** 62: * 指定消息重新消费 63: * 逻辑类似于{@link #rollback()} 64: * 65: * @param msgs 消息 66: */ 67: public void makeMessageToCosumeAgain(List&lt;MessageExt&gt; msgs) { 68: try { 69: this.lockTreeMap.writeLock().lockInterruptibly(); 70: try { 71: for (MessageExt msg : msgs) { 72: this.msgTreeMapTemp.remove(msg.getQueueOffset()); 73: this.msgTreeMap.put(msg.getQueueOffset(), msg); 74: } 75: } finally { 76: this.lockTreeMap.writeLock().unlock(); 77: } 78: } catch (InterruptedException e) { 79: log.error(&quot;makeMessageToCosumeAgain exception&quot;, e); 80: } 81: } 82: 83: /** 84: * 获得持有消息前N条 85: * 86: * @param batchSize 条数 87: * @return 消息 88: */ 89: public List&lt;MessageExt&gt; takeMessags(final int batchSize) { 90: List&lt;MessageExt&gt; result = new ArrayList&lt;&gt;(batchSize); 91: final long now = System.currentTimeMillis(); 92: try { 93: this.lockTreeMap.writeLock().lockInterruptibly(); 94: this.lastConsumeTimestamp = now; 95: try { 96: if (!this.msgTreeMap.isEmpty()) { 97: for (int i = 0; i &lt; batchSize; i++) { 98: Map.Entry&lt;Long, MessageExt&gt; entry = this.msgTreeMap.pollFirstEntry(); 99: if (entry != null) { 100: result.add(entry.getValue()); 101: msgTreeMapTemp.put(entry.getKey(), entry.getValue()); 102: } else { 103: break; 104: } 105: } 106: } 107: 108: if (result.isEmpty()) { 109: consuming = false; 110: } 111: } finally { 112: this.lockTreeMap.writeLock().unlock(); 113: } 114: } catch (InterruptedException e) { 115: log.error(&quot;take Messages exception&quot;, e); 116: } 117: 118: return result; 119: }" />
<meta property="og:description" content="阿里消息队列中间件 RocketMQ源码解析：Message顺序发送与消费 RocketMQ / MyCAT / Sharding-JDBC 所有源码分析文章列表 RocketMQ / MyCAT / Sharding-JDBC 中文注释源码 GitHub 地址 您对于源码的疑问每条留言都将得到认真回复。甚至不知道如何读源码也可以请教噢。 新的源码解析文章实时收到通知。每周更新一篇左右。 认真的源码交流微信群。 1. 概述 2. Producer 顺序发送 3. Consumer 顺序消费 3.1 获得(锁定)消息队列 3.2 移除消息队列 3.3 消费消息队列 3.1.1 消费消息 3.1.2 处理消费结果 3.13 消息处理队列核心方法 1. 概述 建议前置阅读内容： 当然对 Message 发送与消费已经有一定了解的同学，可以选择跳过。 RocketMQ 提供了两种顺序级别： 普通顺序消息 ：Producer 将相关联的消息发送到相同的消息队列。 完全严格顺序 ：在 普通顺序消息 的基础上，Consumer 严格顺序消费。 绝大部分场景下只需要用到普通顺序消息。 例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，不会产生系统逻辑上BUG。另外，普通顺序消息性能能更加好。 那么什么时候使用使用完全严格顺序？如下是来自官方文档的说明： 目前已知的应用只有数据库 binlog 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息 😈上代码！！！ 2. Producer 顺序发送 官方发送顺序消息的例子： 1: package org.apache.rocketmq.example.ordermessage; 2: 3: import java.io.UnsupportedEncodingException; 4: import java.util.List; 5: import org.apache.rocketmq.client.exception.MQBrokerException; 6: import org.apache.rocketmq.client.exception.MQClientException; 7: import org.apache.rocketmq.client.producer.DefaultMQProducer; 8: import org.apache.rocketmq.client.producer.MQProducer; 9: import org.apache.rocketmq.client.producer.MessageQueueSelector; 10: import org.apache.rocketmq.client.producer.SendResult; 11: import org.apache.rocketmq.common.message.Message; 12: import org.apache.rocketmq.common.message.MessageQueue; 13: import org.apache.rocketmq.remoting.common.RemotingHelper; 14: import org.apache.rocketmq.remoting.exception.RemotingException; 15: 16: public class Producer { 17: public static void main(String[] args) throws UnsupportedEncodingException { 18: try { 19: MQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;); 20: producer.start(); 21: 22: String[] tags = new String[] {&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;}; 23: for (int i = 0; i &lt; 100; i++) { 24: int orderId = i % 10; 25: Message msg = 26: new Message(&quot;TopicTestjjj&quot;, tags[i % tags.length], &quot;KEY&quot; + i, 27: (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET)); 28: SendResult sendResult = producer.send(msg, new MessageQueueSelector() { 29: @Override 30: public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) { 31: Integer id = (Integer) arg; 32: int index = id % mqs.size(); 33: return mqs.get(index); 34: } 35: }, orderId); 36: 37: System.out.printf(&quot;%s%n&quot;, sendResult); 38: } 39: 40: producer.shutdown(); 41: } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) { 42: e.printStackTrace(); 43: } 44: } 45: } 第 28 至 35 行 ：实现了根据 id % mqs.size() 来进行消息队列的选择。当前例子，我们传递 orderId 作为参数，那么相同的 orderId 能够进入相同的消息队列。 MessageQueueSelector 接口的源码： 1: public interface MessageQueueSelector { 2: 3: /** 4: * 选择消息队列 5: * 6: * @param mqs 消息队列 7: * @param msg 消息 8: * @param arg 参数 9: * @return 消息队列 10: */ 11: MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg); 12: } Producer 选择队列发送消息方法的源码： 16: private SendResult sendSelectImpl(// 17: Message msg, // 18: MessageQueueSelector selector, // 19: Object arg, // 20: final CommunicationMode communicationMode, // 21: final SendCallback sendCallback, final long timeout// 22: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { 23: this.makeSureStateOK(); 24: Validators.checkMessage(msg, this.defaultMQProducer); 25: 26: TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); 27: if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) { 28: MessageQueue mq = null; 29: try { 30: mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg); 31: } catch (Throwable e) { 32: throw new MQClientException(&quot;select message queue throwed exception.&quot;, e); 33: } 34: 35: if (mq != null) { 36: return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout); 37: } else { 38: throw new MQClientException(&quot;select message queue return null.&quot;, null); 39: } 40: } 41: 42: throw new MQClientException(&quot;No route info for this topic, &quot; + msg.getTopic(), null); 43: } 第 30 行 ：选择消息队列。 第 36 行 ：发送消息。 3. Consumer 严格顺序消费 Consumer 在严格顺序消费时，通过 三 把锁保证严格顺序消费。 Broker 消息队列锁（分布式锁） ： 集群模式下，Consumer 从 Broker 获得该锁后，才能进行消息拉取、消费。 广播模式下，Consumer 无需该锁。 Consumer 消息队列锁（本地锁） ：Consumer 获得该锁才能操作消息队列。 Consumer 消息处理队列消费锁（本地锁） ：Consumer 获得该锁才能消费消息队列。 可能同学有疑问，为什么有 Consumer 消息队列锁还需要有 Consumer 消息队列消费锁呢？😈让我们带着疑问继续往下看。 3.1 获得(锁定)消息队列 集群模式下，Consumer 更新属于自己的消息队列时，会向 Broker 锁定该消息队列（广播模式下不需要）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下： 1: // ⬇️⬇️⬇️【RebalanceImpl.java】 2: private boolean updateProcessQueueTableInRebalance(final String topic, final Set&lt;MessageQueue&gt; mqSet, final boolean isOrder) { 3: // ..... 此处省略部分代码 4: // 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。 5: List&lt;PullRequest&gt; pullRequestList = new ArrayList&lt;&gt;(); // 拉消息请求数组 6: for (MessageQueue mq : mqSet) { 7: if (!this.processQueueTable.containsKey(mq)) { 8: if (isOrder &amp;&amp; !this.lock(mq)) { // 顺序消息锁定消息队列 9: log.warn(&quot;doRebalance, {}, add a new mq failed, {}, because lock failed&quot;, consumerGroup, mq); 10: continue; 11: } 12: 13: this.removeDirtyOffset(mq); 14: ProcessQueue pq = new ProcessQueue(); 15: long nextOffset = this.computePullFromWhere(mq); 16: if (nextOffset &gt;= 0) { 17: ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq); 18: if (pre != null) { 19: log.info(&quot;doRebalance, {}, mq already exists, {}&quot;, consumerGroup, mq); 20: } else { 21: log.info(&quot;doRebalance, {}, add a new mq, {}&quot;, consumerGroup, mq); 22: PullRequest pullRequest = new PullRequest(); 23: pullRequest.setConsumerGroup(consumerGroup); 24: pullRequest.setNextOffset(nextOffset); 25: pullRequest.setMessageQueue(mq); 26: pullRequest.setProcessQueue(pq); 27: pullRequestList.add(pullRequest); 28: changed = true; 29: } 30: } else { 31: log.warn(&quot;doRebalance, {}, add new mq failed, {}&quot;, consumerGroup, mq); 32: } 33: } 34: } 35: 36: // ..... 此处省略部分代码 37: } 38: 39: // ⬇️⬇️⬇️【RebalanceImpl.java】 40: /** 41: * 请求Broker获得指定消息队列的分布式锁 42: * 43: * @param mq 队列 44: * @return 是否成功 45: */ 46: public boolean lock(final MessageQueue mq) { 47: FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true); 48: if (findBrokerResult != null) { 49: LockBatchRequestBody requestBody = new LockBatchRequestBody(); 50: requestBody.setConsumerGroup(this.consumerGroup); 51: requestBody.setClientId(this.mQClientFactory.getClientId()); 52: requestBody.getMqSet().add(mq); 53: 54: try { 55: // 请求Broker获得指定消息队列的分布式锁 56: Set&lt;MessageQueue&gt; lockedMq = 57: this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000); 58: 59: // 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。 60: for (MessageQueue mmqq : lockedMq) { 61: ProcessQueue processQueue = this.processQueueTable.get(mmqq); 62: if (processQueue != null) { 63: processQueue.setLocked(true); 64: processQueue.setLastLockTimestamp(System.currentTimeMillis()); 65: } 66: } 67: 68: boolean lockOK = lockedMq.contains(mq); 69: log.info(&quot;the message queue lock {}, {} {}&quot;, 70: lockOK ? &quot;OK&quot; : &quot;Failed&quot;, 71: this.consumerGroup, 72: mq); 73: return lockOK; 74: } catch (Exception e) { 75: log.error(&quot;lockBatchMQ exception, &quot; + mq, e); 76: } 77: } 78: 79: return false; 80: } ⬆️⬆️⬆️ 第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。 Broker 消息队列锁会过期，默认配置 30s。因此，Consumer 需要不断向 Broker 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下： 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: public void start() { 3: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) { 4: this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { 5: @Override 6: public void run() { 7: ConsumeMessageOrderlyService.this.lockMQPeriodically(); 8: } 9: }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS); 10: } 11: } 3.2 移除消息队列 集群模式下，Consumer 移除自己的消息队列时，会向 Broker 解锁该消息队列（广播模式下不需要）。核心代码如下： 1: // ⬇️⬇️⬇️【RebalancePushImpl.java】 2: /** 3: * 移除不需要的队列相关的信息 4: * 1. 持久化消费进度，并移除之 5: * 2. 顺序消费&amp;集群模式，解锁对该队列的锁定 6: * 7: * @param mq 消息队列 8: * @param pq 消息处理队列 9: * @return 是否移除成功 10: */ 11: @Override 12: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) { 13: // 同步队列的消费进度，并移除之。 14: this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq); 15: this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq); 16: // 集群模式下，顺序消费移除时，解锁对队列的锁定 17: if (this.defaultMQPushConsumerImpl.isConsumeOrderly() 18: &amp;&amp; MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) { 19: try { 20: if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) { 21: try { 22: return this.unlockDelay(mq, pq); 23: } finally { 24: pq.getLockConsume().unlock(); 25: } 26: } else { 27: log.warn(&quot;[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}&quot;, // 28: mq, // 29: pq.getTryUnlockTimes()); 30: 31: pq.incTryUnlockTimes(); 32: } 33: } catch (Exception e) { 34: log.error(&quot;removeUnnecessaryMessageQueue Exception&quot;, e); 35: } 36: 37: return false; 38: } 39: return true; 40: } 41: 42: // ⬇️⬇️⬇️【RebalancePushImpl.java】 43: /** 44: * 延迟解锁 Broker 消息队列锁 45: * 当消息处理队列不存在消息，则直接解锁 46: * 47: * @param mq 消息队列 48: * @param pq 消息处理队列 49: * @return 是否解锁成功 50: */ 51: private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) { 52: if (pq.hasTempMessage()) { // TODO 疑问：为什么要延迟移除 53: log.info(&quot;[{}]unlockDelay, begin {} &quot;, mq.hashCode(), mq); 54: this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() { 55: @Override 56: public void run() { 57: log.info(&quot;[{}]unlockDelay, execute at once {}&quot;, mq.hashCode(), mq); 58: RebalancePushImpl.this.unlock(mq, true); 59: } 60: }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS); 61: } else { 62: this.unlock(mq, true); 63: } 64: return true; 65: } ⬆️⬆️⬆️ 第 20 至 32 行 ：获取消息队列消费锁，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的 Consumer 和当前 Consumer 同时消费该消息队列，导致消息无法严格顺序消费。 第 51 至 64 行 ：解锁 Broker 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 Broker 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。 3.3 消费消息队列 😏本节会类比并发消费消费队列，建议对照 PushConsumer并发消费消息 一起理解。 3.1.1 消费消息 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: class ConsumeRequest implements Runnable { 3: 4: /** 5: * 消息处理队列 6: */ 7: private final ProcessQueue processQueue; 8: /** 9: * 消息队列 10: */ 11: private final MessageQueue messageQueue; 12: 13: @Override 14: public void run() { 15: if (this.processQueue.isDropped()) { 16: log.warn(&quot;run, the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 17: return; 18: } 19: 20: // 获得 Consumer 消息队列锁 21: final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue); 22: synchronized (objLock) { 23: // (广播模式) 或者 (集群模式 &amp;&amp; Broker消息队列锁有效) 24: if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 25: || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())) { 26: final long beginTime = System.currentTimeMillis(); 27: // 循环 28: for (boolean continueConsume = true; continueConsume; ) { 29: if (this.processQueue.isDropped()) { 30: log.warn(&quot;the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 31: break; 32: } 33: 34: // 消息队列分布式锁未锁定，提交延迟获得锁并消费请求 35: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 36: &amp;&amp; !this.processQueue.isLocked()) { 37: log.warn(&quot;the message queue not locked, so consume later, {}&quot;, this.messageQueue); 38: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); 39: break; 40: } 41: // 消息队列分布式锁已经过期，提交延迟获得锁并消费请求 42: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 43: &amp;&amp; this.processQueue.isLockExpired()) { 44: log.warn(&quot;the message queue lock expired, so consume later, {}&quot;, this.messageQueue); 45: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); 46: break; 47: } 48: 49: // 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。 50: long interval = System.currentTimeMillis() - beginTime; 51: if (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) { 52: ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10); 53: break; 54: } 55: 56: // 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。 57: final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize(); 58: List&lt;MessageExt&gt; msgs = this.processQueue.takeMessags(consumeBatchSize); 59: if (!msgs.isEmpty()) { 60: final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue); 61: 62: ConsumeOrderlyStatus status = null; 63: 64: // ....省略代码：Hook：before 65: 66: // 执行消费 67: long beginTimestamp = System.currentTimeMillis(); 68: ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; 69: boolean hasException = false; 70: try { 71: this.processQueue.getLockConsume().lock(); // 锁定队列消费锁 72: 73: if (this.processQueue.isDropped()) { 74: log.warn(&quot;consumeMessage, the message queue not be able to consume, because it&#39;s dropped. {}&quot;, 75: this.messageQueue); 76: break; 77: } 78: 79: status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context); 80: } catch (Throwable e) { 81: log.warn(&quot;consumeMessage exception: {} Group: {} Msgs: {} MQ: {}&quot;, // 82: RemotingHelper.exceptionSimpleDesc(e), // 83: ConsumeMessageOrderlyService.this.consumerGroup, // 84: msgs, // 85: messageQueue); 86: hasException = true; 87: } finally { 88: this.processQueue.getLockConsume().unlock(); // 锁定队列消费锁 89: } 90: 91: // ....省略代码：解析消费结果状态 92: 93: // ....省略代码：Hook：after 94: 95: ConsumeMessageOrderlyService.this.getConsumerStatsManager() 96: .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT); 97: 98: // 处理消费结果 99: continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this); 100: } else { 101: continueConsume = false; 102: } 103: } 104: } else { 105: if (this.processQueue.isDropped()) { 106: log.warn(&quot;the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 107: return; 108: } 109: 110: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100); 111: } 112: } 113: } 114: 115: } ⬆️⬆️⬆️ 第 20 行 ：获得 Consumer 消息队列锁。 第 58 行 ：从消息处理队列顺序获得消息。和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。 第 71 行 ：获得 Consumer 消息处理队列消费锁。相比【Consumer消息队列锁】，其粒度较小。这就是上文提到的❓为什么有Consumer消息队列锁还需要有 Consumer 消息队列消费锁呢的原因。 第 79 行 ：执行消费。 第 99 行 ：处理消费结果。 3.1.2 处理消费结果 顺序消费消息结果 (ConsumeOrderlyStatus) 有四种情况： SUCCESS ：消费成功但不提交。 ROLLBACK ：消费失败，消费回滚。 COMMIT ：消费成功提交并且提交。 SUSPEND_CURRENT_QUEUE_A_MOMENT ：消费失败，挂起消费队列一会会，稍后继续消费。 考虑到 ROLLBACK 、COMMIT 暂时只使用在 MySQL binlog 场景，官方将这两状态标记为 @Deprecated。当然，相应的实现逻辑依然保留。 在并发消费场景时，如果消费失败，Consumer 会将消费失败消息发回到 Broker 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。 但是在完全严格顺序消费消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。 不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，Consumer 会将消费失败超过上限的消息发回到 Broker 死信队列。 让我们来看看代码： 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: /** 3: * 处理消费结果，并返回是否继续消费 4: * 5: * @param msgs 消息 6: * @param status 消费结果状态 7: * @param context 消费Context 8: * @param consumeRequest 消费请求 9: * @return 是否继续消费 10: */ 11: public boolean processConsumeResult(// 12: final List&lt;MessageExt&gt; msgs, // 13: final ConsumeOrderlyStatus status, // 14: final ConsumeOrderlyContext context, // 15: final ConsumeRequest consumeRequest// 16: ) { 17: boolean continueConsume = true; 18: long commitOffset = -1L; 19: if (context.isAutoCommit()) { 20: switch (status) { 21: case COMMIT: 22: case ROLLBACK: 23: log.warn(&quot;the message queue consume result is illegal, we think you want to ack these message {}&quot;, consumeRequest.getMessageQueue()); 24: case SUCCESS: 25: // 提交消息已消费成功到消息处理队列 26: commitOffset = consumeRequest.getProcessQueue().commit(); 27: // 统计 28: this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 29: break; 30: case SUSPEND_CURRENT_QUEUE_A_MOMENT: 31: // 统计 32: this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 33: if (checkReconsumeTimes(msgs)) { // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms 34: // 设置消息重新消费 35: consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs); 36: // 提交延迟消费请求 37: this.submitConsumeRequestLater(// 38: consumeRequest.getProcessQueue(), // 39: consumeRequest.getMessageQueue(), // 40: context.getSuspendCurrentQueueTimeMillis()); 41: continueConsume = false; 42: } else { 43: commitOffset = consumeRequest.getProcessQueue().commit(); 44: } 45: break; 46: default: 47: break; 48: } 49: } else { 50: switch (status) { 51: case SUCCESS: 52: this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 53: break; 54: case COMMIT: 55: // 提交消息已消费成功到消息处理队列 56: commitOffset = consumeRequest.getProcessQueue().commit(); 57: break; 58: case ROLLBACK: 59: // 设置消息重新消费 60: consumeRequest.getProcessQueue().rollback(); 61: this.submitConsumeRequestLater(// 62: consumeRequest.getProcessQueue(), // 63: consumeRequest.getMessageQueue(), // 64: context.getSuspendCurrentQueueTimeMillis()); 65: continueConsume = false; 66: break; 67: case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms 68: this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 69: if (checkReconsumeTimes(msgs)) { 70: // 设置消息重新消费 71: consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs); 72: // 提交延迟消费请求 73: this.submitConsumeRequestLater(// 74: consumeRequest.getProcessQueue(), // 75: consumeRequest.getMessageQueue(), // 76: context.getSuspendCurrentQueueTimeMillis()); 77: continueConsume = false; 78: } 79: break; 80: default: 81: break; 82: } 83: } 84: 85: // 消息处理队列未dropped，提交有效消费进度 86: if (commitOffset &gt;= 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) { 87: this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false); 88: } 89: 90: return continueConsume; 91: } 92: 93: private int getMaxReconsumeTimes() { 94: // default reconsume times: Integer.MAX_VALUE 95: if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) { 96: return Integer.MAX_VALUE; 97: } else { 98: return this.defaultMQPushConsumer.getMaxReconsumeTimes(); 99: } 100: } 101: 102: /** 103: * 计算是否要暂停消费 104: * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功 105: * 106: * @param msgs 消息 107: * @return 是否要暂停 108: */ 109: private boolean checkReconsumeTimes(List&lt;MessageExt&gt; msgs) { 110: boolean suspend = false; 111: if (msgs != null &amp;&amp; !msgs.isEmpty()) { 112: for (MessageExt msg : msgs) { 113: if (msg.getReconsumeTimes() &gt;= getMaxReconsumeTimes()) { 114: MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes())); 115: if (!sendMessageBack(msg)) { // 发回失败，中断 116: suspend = true; 117: msg.setReconsumeTimes(msg.getReconsumeTimes() + 1); 118: } 119: } else { 120: suspend = true; 121: msg.setReconsumeTimes(msg.getReconsumeTimes() + 1); 122: } 123: } 124: } 125: return suspend; 126: } 127: 128: /** 129: * 发回消息。 130: * 消息发回broker后，对应的消息队列是死信队列。 131: * 132: * @param msg 消息 133: * @return 是否发送成功 134: */ 135: public boolean sendMessageBack(final MessageExt msg) { 136: try { 137: // max reconsume times exceeded then send to dead letter queue. 138: Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody()); 139: String originMsgId = MessageAccessor.getOriginMessageId(msg); 140: MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId); 141: newMsg.setFlag(msg.getFlag()); 142: MessageAccessor.setProperties(newMsg, msg.getProperties()); 143: MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic()); 144: MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes())); 145: MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes())); 146: newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes()); 147: 148: this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg); 149: return true; 150: } catch (Exception e) { 151: log.error(&quot;sendMessageBack exception, group: &quot; + this.consumerGroup + &quot; msg: &quot; + msg.toString(), e); 152: } 153: 154: return false; 155: } ⬆️⬆️⬆️ 第 21 至 29 行 ：消费成功。在自动提交进度( AutoCommit )的情况下，COMMIT、ROLLBACK、SUCCESS 逻辑已经统一。 第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 Broker 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。 第 85 至 88 行 ：提交消费进度。 3.13 消息处理队列核心方法 😈涉及到的四个核心方法的源码： 1: // ⬇️⬇️⬇️【ProcessQueue.java】 2: /** 3: * 消息映射 4: * key：消息队列位置 5: */ 6: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMap = new TreeMap&lt;&gt;(); /** 7: * 消息映射临时存储（消费中的消息） 8: */ 9: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = new TreeMap&lt;&gt;(); 10: 11: /** 12: * 回滚消费中的消息 13: * 逻辑类似于{@link #makeMessageToCosumeAgain(List)} 14: */ 15: public void rollback() { 16: try { 17: this.lockTreeMap.writeLock().lockInterruptibly(); 18: try { 19: this.msgTreeMap.putAll(this.msgTreeMapTemp); 20: this.msgTreeMapTemp.clear(); 21: } finally { 22: this.lockTreeMap.writeLock().unlock(); 23: } 24: } catch (InterruptedException e) { 25: log.error(&quot;rollback exception&quot;, e); 26: } 27: } 28: 29: /** 30: * 提交消费中的消息已消费成功，返回消费进度 31: * 32: * @return 消费进度 33: */ 34: public long commit() { 35: try { 36: this.lockTreeMap.writeLock().lockInterruptibly(); 37: try { 38: // 消费进度 39: Long offset = this.msgTreeMapTemp.lastKey(); 40: 41: // 42: msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1)); 43: 44: // 45: this.msgTreeMapTemp.clear(); 46: 47: // 返回消费进度 48: if (offset != null) { 49: return offset + 1; 50: } 51: } finally { 52: this.lockTreeMap.writeLock().unlock(); 53: } 54: } catch (InterruptedException e) { 55: log.error(&quot;commit exception&quot;, e); 56: } 57: 58: return -1; 59: } 60: 61: /** 62: * 指定消息重新消费 63: * 逻辑类似于{@link #rollback()} 64: * 65: * @param msgs 消息 66: */ 67: public void makeMessageToCosumeAgain(List&lt;MessageExt&gt; msgs) { 68: try { 69: this.lockTreeMap.writeLock().lockInterruptibly(); 70: try { 71: for (MessageExt msg : msgs) { 72: this.msgTreeMapTemp.remove(msg.getQueueOffset()); 73: this.msgTreeMap.put(msg.getQueueOffset(), msg); 74: } 75: } finally { 76: this.lockTreeMap.writeLock().unlock(); 77: } 78: } catch (InterruptedException e) { 79: log.error(&quot;makeMessageToCosumeAgain exception&quot;, e); 80: } 81: } 82: 83: /** 84: * 获得持有消息前N条 85: * 86: * @param batchSize 条数 87: * @return 消息 88: */ 89: public List&lt;MessageExt&gt; takeMessags(final int batchSize) { 90: List&lt;MessageExt&gt; result = new ArrayList&lt;&gt;(batchSize); 91: final long now = System.currentTimeMillis(); 92: try { 93: this.lockTreeMap.writeLock().lockInterruptibly(); 94: this.lastConsumeTimestamp = now; 95: try { 96: if (!this.msgTreeMap.isEmpty()) { 97: for (int i = 0; i &lt; batchSize; i++) { 98: Map.Entry&lt;Long, MessageExt&gt; entry = this.msgTreeMap.pollFirstEntry(); 99: if (entry != null) { 100: result.add(entry.getValue()); 101: msgTreeMapTemp.put(entry.getKey(), entry.getValue()); 102: } else { 103: break; 104: } 105: } 106: } 107: 108: if (result.isEmpty()) { 109: consuming = false; 110: } 111: } finally { 112: this.lockTreeMap.writeLock().unlock(); 113: } 114: } catch (InterruptedException e) { 115: log.error(&quot;take Messages exception&quot;, e); 116: } 117: 118: return result; 119: }" />
<link rel="canonical" href="http://www.jfox.info/2017/%E9%98%BF%E9%87%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6rocketmq%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90message%E9%A1%BA%E5%BA%8F%E5%8F%91%E9%80%81%E4%B8%8E%E6%B6%88%E8%B4%B9.html" />
<meta property="og:url" content="http://www.jfox.info/2017/%E9%98%BF%E9%87%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6rocketmq%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90message%E9%A1%BA%E5%BA%8F%E5%8F%91%E9%80%81%E4%B8%8E%E6%B6%88%E8%B4%B9.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T15:59:07+00:00" />
<script type="application/ld+json">
{"description":"阿里消息队列中间件 RocketMQ源码解析：Message顺序发送与消费 RocketMQ / MyCAT / Sharding-JDBC 所有源码分析文章列表 RocketMQ / MyCAT / Sharding-JDBC 中文注释源码 GitHub 地址 您对于源码的疑问每条留言都将得到认真回复。甚至不知道如何读源码也可以请教噢。 新的源码解析文章实时收到通知。每周更新一篇左右。 认真的源码交流微信群。 1. 概述 2. Producer 顺序发送 3. Consumer 顺序消费 3.1 获得(锁定)消息队列 3.2 移除消息队列 3.3 消费消息队列 3.1.1 消费消息 3.1.2 处理消费结果 3.13 消息处理队列核心方法 1. 概述 建议前置阅读内容： 当然对 Message 发送与消费已经有一定了解的同学，可以选择跳过。 RocketMQ 提供了两种顺序级别： 普通顺序消息 ：Producer 将相关联的消息发送到相同的消息队列。 完全严格顺序 ：在 普通顺序消息 的基础上，Consumer 严格顺序消费。 绝大部分场景下只需要用到普通顺序消息。 例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，不会产生系统逻辑上BUG。另外，普通顺序消息性能能更加好。 那么什么时候使用使用完全严格顺序？如下是来自官方文档的说明： 目前已知的应用只有数据库 binlog 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息 😈上代码！！！ 2. Producer 顺序发送 官方发送顺序消息的例子： 1: package org.apache.rocketmq.example.ordermessage; 2: 3: import java.io.UnsupportedEncodingException; 4: import java.util.List; 5: import org.apache.rocketmq.client.exception.MQBrokerException; 6: import org.apache.rocketmq.client.exception.MQClientException; 7: import org.apache.rocketmq.client.producer.DefaultMQProducer; 8: import org.apache.rocketmq.client.producer.MQProducer; 9: import org.apache.rocketmq.client.producer.MessageQueueSelector; 10: import org.apache.rocketmq.client.producer.SendResult; 11: import org.apache.rocketmq.common.message.Message; 12: import org.apache.rocketmq.common.message.MessageQueue; 13: import org.apache.rocketmq.remoting.common.RemotingHelper; 14: import org.apache.rocketmq.remoting.exception.RemotingException; 15: 16: public class Producer { 17: public static void main(String[] args) throws UnsupportedEncodingException { 18: try { 19: MQProducer producer = new DefaultMQProducer(&quot;please_rename_unique_group_name&quot;); 20: producer.start(); 21: 22: String[] tags = new String[] {&quot;TagA&quot;, &quot;TagB&quot;, &quot;TagC&quot;, &quot;TagD&quot;, &quot;TagE&quot;}; 23: for (int i = 0; i &lt; 100; i++) { 24: int orderId = i % 10; 25: Message msg = 26: new Message(&quot;TopicTestjjj&quot;, tags[i % tags.length], &quot;KEY&quot; + i, 27: (&quot;Hello RocketMQ &quot; + i).getBytes(RemotingHelper.DEFAULT_CHARSET)); 28: SendResult sendResult = producer.send(msg, new MessageQueueSelector() { 29: @Override 30: public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) { 31: Integer id = (Integer) arg; 32: int index = id % mqs.size(); 33: return mqs.get(index); 34: } 35: }, orderId); 36: 37: System.out.printf(&quot;%s%n&quot;, sendResult); 38: } 39: 40: producer.shutdown(); 41: } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) { 42: e.printStackTrace(); 43: } 44: } 45: } 第 28 至 35 行 ：实现了根据 id % mqs.size() 来进行消息队列的选择。当前例子，我们传递 orderId 作为参数，那么相同的 orderId 能够进入相同的消息队列。 MessageQueueSelector 接口的源码： 1: public interface MessageQueueSelector { 2: 3: /** 4: * 选择消息队列 5: * 6: * @param mqs 消息队列 7: * @param msg 消息 8: * @param arg 参数 9: * @return 消息队列 10: */ 11: MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg); 12: } Producer 选择队列发送消息方法的源码： 16: private SendResult sendSelectImpl(// 17: Message msg, // 18: MessageQueueSelector selector, // 19: Object arg, // 20: final CommunicationMode communicationMode, // 21: final SendCallback sendCallback, final long timeout// 22: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException { 23: this.makeSureStateOK(); 24: Validators.checkMessage(msg, this.defaultMQProducer); 25: 26: TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic()); 27: if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) { 28: MessageQueue mq = null; 29: try { 30: mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg); 31: } catch (Throwable e) { 32: throw new MQClientException(&quot;select message queue throwed exception.&quot;, e); 33: } 34: 35: if (mq != null) { 36: return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout); 37: } else { 38: throw new MQClientException(&quot;select message queue return null.&quot;, null); 39: } 40: } 41: 42: throw new MQClientException(&quot;No route info for this topic, &quot; + msg.getTopic(), null); 43: } 第 30 行 ：选择消息队列。 第 36 行 ：发送消息。 3. Consumer 严格顺序消费 Consumer 在严格顺序消费时，通过 三 把锁保证严格顺序消费。 Broker 消息队列锁（分布式锁） ： 集群模式下，Consumer 从 Broker 获得该锁后，才能进行消息拉取、消费。 广播模式下，Consumer 无需该锁。 Consumer 消息队列锁（本地锁） ：Consumer 获得该锁才能操作消息队列。 Consumer 消息处理队列消费锁（本地锁） ：Consumer 获得该锁才能消费消息队列。 可能同学有疑问，为什么有 Consumer 消息队列锁还需要有 Consumer 消息队列消费锁呢？😈让我们带着疑问继续往下看。 3.1 获得(锁定)消息队列 集群模式下，Consumer 更新属于自己的消息队列时，会向 Broker 锁定该消息队列（广播模式下不需要）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下： 1: // ⬇️⬇️⬇️【RebalanceImpl.java】 2: private boolean updateProcessQueueTableInRebalance(final String topic, final Set&lt;MessageQueue&gt; mqSet, final boolean isOrder) { 3: // ..... 此处省略部分代码 4: // 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。 5: List&lt;PullRequest&gt; pullRequestList = new ArrayList&lt;&gt;(); // 拉消息请求数组 6: for (MessageQueue mq : mqSet) { 7: if (!this.processQueueTable.containsKey(mq)) { 8: if (isOrder &amp;&amp; !this.lock(mq)) { // 顺序消息锁定消息队列 9: log.warn(&quot;doRebalance, {}, add a new mq failed, {}, because lock failed&quot;, consumerGroup, mq); 10: continue; 11: } 12: 13: this.removeDirtyOffset(mq); 14: ProcessQueue pq = new ProcessQueue(); 15: long nextOffset = this.computePullFromWhere(mq); 16: if (nextOffset &gt;= 0) { 17: ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq); 18: if (pre != null) { 19: log.info(&quot;doRebalance, {}, mq already exists, {}&quot;, consumerGroup, mq); 20: } else { 21: log.info(&quot;doRebalance, {}, add a new mq, {}&quot;, consumerGroup, mq); 22: PullRequest pullRequest = new PullRequest(); 23: pullRequest.setConsumerGroup(consumerGroup); 24: pullRequest.setNextOffset(nextOffset); 25: pullRequest.setMessageQueue(mq); 26: pullRequest.setProcessQueue(pq); 27: pullRequestList.add(pullRequest); 28: changed = true; 29: } 30: } else { 31: log.warn(&quot;doRebalance, {}, add new mq failed, {}&quot;, consumerGroup, mq); 32: } 33: } 34: } 35: 36: // ..... 此处省略部分代码 37: } 38: 39: // ⬇️⬇️⬇️【RebalanceImpl.java】 40: /** 41: * 请求Broker获得指定消息队列的分布式锁 42: * 43: * @param mq 队列 44: * @return 是否成功 45: */ 46: public boolean lock(final MessageQueue mq) { 47: FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true); 48: if (findBrokerResult != null) { 49: LockBatchRequestBody requestBody = new LockBatchRequestBody(); 50: requestBody.setConsumerGroup(this.consumerGroup); 51: requestBody.setClientId(this.mQClientFactory.getClientId()); 52: requestBody.getMqSet().add(mq); 53: 54: try { 55: // 请求Broker获得指定消息队列的分布式锁 56: Set&lt;MessageQueue&gt; lockedMq = 57: this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000); 58: 59: // 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。 60: for (MessageQueue mmqq : lockedMq) { 61: ProcessQueue processQueue = this.processQueueTable.get(mmqq); 62: if (processQueue != null) { 63: processQueue.setLocked(true); 64: processQueue.setLastLockTimestamp(System.currentTimeMillis()); 65: } 66: } 67: 68: boolean lockOK = lockedMq.contains(mq); 69: log.info(&quot;the message queue lock {}, {} {}&quot;, 70: lockOK ? &quot;OK&quot; : &quot;Failed&quot;, 71: this.consumerGroup, 72: mq); 73: return lockOK; 74: } catch (Exception e) { 75: log.error(&quot;lockBatchMQ exception, &quot; + mq, e); 76: } 77: } 78: 79: return false; 80: } ⬆️⬆️⬆️ 第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。 Broker 消息队列锁会过期，默认配置 30s。因此，Consumer 需要不断向 Broker 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下： 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: public void start() { 3: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) { 4: this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() { 5: @Override 6: public void run() { 7: ConsumeMessageOrderlyService.this.lockMQPeriodically(); 8: } 9: }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS); 10: } 11: } 3.2 移除消息队列 集群模式下，Consumer 移除自己的消息队列时，会向 Broker 解锁该消息队列（广播模式下不需要）。核心代码如下： 1: // ⬇️⬇️⬇️【RebalancePushImpl.java】 2: /** 3: * 移除不需要的队列相关的信息 4: * 1. 持久化消费进度，并移除之 5: * 2. 顺序消费&amp;集群模式，解锁对该队列的锁定 6: * 7: * @param mq 消息队列 8: * @param pq 消息处理队列 9: * @return 是否移除成功 10: */ 11: @Override 12: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) { 13: // 同步队列的消费进度，并移除之。 14: this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq); 15: this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq); 16: // 集群模式下，顺序消费移除时，解锁对队列的锁定 17: if (this.defaultMQPushConsumerImpl.isConsumeOrderly() 18: &amp;&amp; MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) { 19: try { 20: if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) { 21: try { 22: return this.unlockDelay(mq, pq); 23: } finally { 24: pq.getLockConsume().unlock(); 25: } 26: } else { 27: log.warn(&quot;[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}&quot;, // 28: mq, // 29: pq.getTryUnlockTimes()); 30: 31: pq.incTryUnlockTimes(); 32: } 33: } catch (Exception e) { 34: log.error(&quot;removeUnnecessaryMessageQueue Exception&quot;, e); 35: } 36: 37: return false; 38: } 39: return true; 40: } 41: 42: // ⬇️⬇️⬇️【RebalancePushImpl.java】 43: /** 44: * 延迟解锁 Broker 消息队列锁 45: * 当消息处理队列不存在消息，则直接解锁 46: * 47: * @param mq 消息队列 48: * @param pq 消息处理队列 49: * @return 是否解锁成功 50: */ 51: private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) { 52: if (pq.hasTempMessage()) { // TODO 疑问：为什么要延迟移除 53: log.info(&quot;[{}]unlockDelay, begin {} &quot;, mq.hashCode(), mq); 54: this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() { 55: @Override 56: public void run() { 57: log.info(&quot;[{}]unlockDelay, execute at once {}&quot;, mq.hashCode(), mq); 58: RebalancePushImpl.this.unlock(mq, true); 59: } 60: }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS); 61: } else { 62: this.unlock(mq, true); 63: } 64: return true; 65: } ⬆️⬆️⬆️ 第 20 至 32 行 ：获取消息队列消费锁，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的 Consumer 和当前 Consumer 同时消费该消息队列，导致消息无法严格顺序消费。 第 51 至 64 行 ：解锁 Broker 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 Broker 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。 3.3 消费消息队列 😏本节会类比并发消费消费队列，建议对照 PushConsumer并发消费消息 一起理解。 3.1.1 消费消息 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: class ConsumeRequest implements Runnable { 3: 4: /** 5: * 消息处理队列 6: */ 7: private final ProcessQueue processQueue; 8: /** 9: * 消息队列 10: */ 11: private final MessageQueue messageQueue; 12: 13: @Override 14: public void run() { 15: if (this.processQueue.isDropped()) { 16: log.warn(&quot;run, the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 17: return; 18: } 19: 20: // 获得 Consumer 消息队列锁 21: final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue); 22: synchronized (objLock) { 23: // (广播模式) 或者 (集群模式 &amp;&amp; Broker消息队列锁有效) 24: if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 25: || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())) { 26: final long beginTime = System.currentTimeMillis(); 27: // 循环 28: for (boolean continueConsume = true; continueConsume; ) { 29: if (this.processQueue.isDropped()) { 30: log.warn(&quot;the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 31: break; 32: } 33: 34: // 消息队列分布式锁未锁定，提交延迟获得锁并消费请求 35: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 36: &amp;&amp; !this.processQueue.isLocked()) { 37: log.warn(&quot;the message queue not locked, so consume later, {}&quot;, this.messageQueue); 38: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); 39: break; 40: } 41: // 消息队列分布式锁已经过期，提交延迟获得锁并消费请求 42: if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel()) 43: &amp;&amp; this.processQueue.isLockExpired()) { 44: log.warn(&quot;the message queue lock expired, so consume later, {}&quot;, this.messageQueue); 45: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10); 46: break; 47: } 48: 49: // 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。 50: long interval = System.currentTimeMillis() - beginTime; 51: if (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) { 52: ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10); 53: break; 54: } 55: 56: // 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。 57: final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize(); 58: List&lt;MessageExt&gt; msgs = this.processQueue.takeMessags(consumeBatchSize); 59: if (!msgs.isEmpty()) { 60: final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue); 61: 62: ConsumeOrderlyStatus status = null; 63: 64: // ....省略代码：Hook：before 65: 66: // 执行消费 67: long beginTimestamp = System.currentTimeMillis(); 68: ConsumeReturnType returnType = ConsumeReturnType.SUCCESS; 69: boolean hasException = false; 70: try { 71: this.processQueue.getLockConsume().lock(); // 锁定队列消费锁 72: 73: if (this.processQueue.isDropped()) { 74: log.warn(&quot;consumeMessage, the message queue not be able to consume, because it&#39;s dropped. {}&quot;, 75: this.messageQueue); 76: break; 77: } 78: 79: status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context); 80: } catch (Throwable e) { 81: log.warn(&quot;consumeMessage exception: {} Group: {} Msgs: {} MQ: {}&quot;, // 82: RemotingHelper.exceptionSimpleDesc(e), // 83: ConsumeMessageOrderlyService.this.consumerGroup, // 84: msgs, // 85: messageQueue); 86: hasException = true; 87: } finally { 88: this.processQueue.getLockConsume().unlock(); // 锁定队列消费锁 89: } 90: 91: // ....省略代码：解析消费结果状态 92: 93: // ....省略代码：Hook：after 94: 95: ConsumeMessageOrderlyService.this.getConsumerStatsManager() 96: .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT); 97: 98: // 处理消费结果 99: continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this); 100: } else { 101: continueConsume = false; 102: } 103: } 104: } else { 105: if (this.processQueue.isDropped()) { 106: log.warn(&quot;the message queue not be able to consume, because it&#39;s dropped. {}&quot;, this.messageQueue); 107: return; 108: } 109: 110: ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100); 111: } 112: } 113: } 114: 115: } ⬆️⬆️⬆️ 第 20 行 ：获得 Consumer 消息队列锁。 第 58 行 ：从消息处理队列顺序获得消息。和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。 第 71 行 ：获得 Consumer 消息处理队列消费锁。相比【Consumer消息队列锁】，其粒度较小。这就是上文提到的❓为什么有Consumer消息队列锁还需要有 Consumer 消息队列消费锁呢的原因。 第 79 行 ：执行消费。 第 99 行 ：处理消费结果。 3.1.2 处理消费结果 顺序消费消息结果 (ConsumeOrderlyStatus) 有四种情况： SUCCESS ：消费成功但不提交。 ROLLBACK ：消费失败，消费回滚。 COMMIT ：消费成功提交并且提交。 SUSPEND_CURRENT_QUEUE_A_MOMENT ：消费失败，挂起消费队列一会会，稍后继续消费。 考虑到 ROLLBACK 、COMMIT 暂时只使用在 MySQL binlog 场景，官方将这两状态标记为 @Deprecated。当然，相应的实现逻辑依然保留。 在并发消费场景时，如果消费失败，Consumer 会将消费失败消息发回到 Broker 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。 但是在完全严格顺序消费消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。 不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，Consumer 会将消费失败超过上限的消息发回到 Broker 死信队列。 让我们来看看代码： 1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】 2: /** 3: * 处理消费结果，并返回是否继续消费 4: * 5: * @param msgs 消息 6: * @param status 消费结果状态 7: * @param context 消费Context 8: * @param consumeRequest 消费请求 9: * @return 是否继续消费 10: */ 11: public boolean processConsumeResult(// 12: final List&lt;MessageExt&gt; msgs, // 13: final ConsumeOrderlyStatus status, // 14: final ConsumeOrderlyContext context, // 15: final ConsumeRequest consumeRequest// 16: ) { 17: boolean continueConsume = true; 18: long commitOffset = -1L; 19: if (context.isAutoCommit()) { 20: switch (status) { 21: case COMMIT: 22: case ROLLBACK: 23: log.warn(&quot;the message queue consume result is illegal, we think you want to ack these message {}&quot;, consumeRequest.getMessageQueue()); 24: case SUCCESS: 25: // 提交消息已消费成功到消息处理队列 26: commitOffset = consumeRequest.getProcessQueue().commit(); 27: // 统计 28: this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 29: break; 30: case SUSPEND_CURRENT_QUEUE_A_MOMENT: 31: // 统计 32: this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 33: if (checkReconsumeTimes(msgs)) { // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms 34: // 设置消息重新消费 35: consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs); 36: // 提交延迟消费请求 37: this.submitConsumeRequestLater(// 38: consumeRequest.getProcessQueue(), // 39: consumeRequest.getMessageQueue(), // 40: context.getSuspendCurrentQueueTimeMillis()); 41: continueConsume = false; 42: } else { 43: commitOffset = consumeRequest.getProcessQueue().commit(); 44: } 45: break; 46: default: 47: break; 48: } 49: } else { 50: switch (status) { 51: case SUCCESS: 52: this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 53: break; 54: case COMMIT: 55: // 提交消息已消费成功到消息处理队列 56: commitOffset = consumeRequest.getProcessQueue().commit(); 57: break; 58: case ROLLBACK: 59: // 设置消息重新消费 60: consumeRequest.getProcessQueue().rollback(); 61: this.submitConsumeRequestLater(// 62: consumeRequest.getProcessQueue(), // 63: consumeRequest.getMessageQueue(), // 64: context.getSuspendCurrentQueueTimeMillis()); 65: continueConsume = false; 66: break; 67: case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms 68: this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size()); 69: if (checkReconsumeTimes(msgs)) { 70: // 设置消息重新消费 71: consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs); 72: // 提交延迟消费请求 73: this.submitConsumeRequestLater(// 74: consumeRequest.getProcessQueue(), // 75: consumeRequest.getMessageQueue(), // 76: context.getSuspendCurrentQueueTimeMillis()); 77: continueConsume = false; 78: } 79: break; 80: default: 81: break; 82: } 83: } 84: 85: // 消息处理队列未dropped，提交有效消费进度 86: if (commitOffset &gt;= 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) { 87: this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false); 88: } 89: 90: return continueConsume; 91: } 92: 93: private int getMaxReconsumeTimes() { 94: // default reconsume times: Integer.MAX_VALUE 95: if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) { 96: return Integer.MAX_VALUE; 97: } else { 98: return this.defaultMQPushConsumer.getMaxReconsumeTimes(); 99: } 100: } 101: 102: /** 103: * 计算是否要暂停消费 104: * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功 105: * 106: * @param msgs 消息 107: * @return 是否要暂停 108: */ 109: private boolean checkReconsumeTimes(List&lt;MessageExt&gt; msgs) { 110: boolean suspend = false; 111: if (msgs != null &amp;&amp; !msgs.isEmpty()) { 112: for (MessageExt msg : msgs) { 113: if (msg.getReconsumeTimes() &gt;= getMaxReconsumeTimes()) { 114: MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes())); 115: if (!sendMessageBack(msg)) { // 发回失败，中断 116: suspend = true; 117: msg.setReconsumeTimes(msg.getReconsumeTimes() + 1); 118: } 119: } else { 120: suspend = true; 121: msg.setReconsumeTimes(msg.getReconsumeTimes() + 1); 122: } 123: } 124: } 125: return suspend; 126: } 127: 128: /** 129: * 发回消息。 130: * 消息发回broker后，对应的消息队列是死信队列。 131: * 132: * @param msg 消息 133: * @return 是否发送成功 134: */ 135: public boolean sendMessageBack(final MessageExt msg) { 136: try { 137: // max reconsume times exceeded then send to dead letter queue. 138: Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody()); 139: String originMsgId = MessageAccessor.getOriginMessageId(msg); 140: MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId); 141: newMsg.setFlag(msg.getFlag()); 142: MessageAccessor.setProperties(newMsg, msg.getProperties()); 143: MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic()); 144: MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes())); 145: MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes())); 146: newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes()); 147: 148: this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg); 149: return true; 150: } catch (Exception e) { 151: log.error(&quot;sendMessageBack exception, group: &quot; + this.consumerGroup + &quot; msg: &quot; + msg.toString(), e); 152: } 153: 154: return false; 155: } ⬆️⬆️⬆️ 第 21 至 29 行 ：消费成功。在自动提交进度( AutoCommit )的情况下，COMMIT、ROLLBACK、SUCCESS 逻辑已经统一。 第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 Broker 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。 第 85 至 88 行 ：提交消费进度。 3.13 消息处理队列核心方法 😈涉及到的四个核心方法的源码： 1: // ⬇️⬇️⬇️【ProcessQueue.java】 2: /** 3: * 消息映射 4: * key：消息队列位置 5: */ 6: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMap = new TreeMap&lt;&gt;(); /** 7: * 消息映射临时存储（消费中的消息） 8: */ 9: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = new TreeMap&lt;&gt;(); 10: 11: /** 12: * 回滚消费中的消息 13: * 逻辑类似于{@link #makeMessageToCosumeAgain(List)} 14: */ 15: public void rollback() { 16: try { 17: this.lockTreeMap.writeLock().lockInterruptibly(); 18: try { 19: this.msgTreeMap.putAll(this.msgTreeMapTemp); 20: this.msgTreeMapTemp.clear(); 21: } finally { 22: this.lockTreeMap.writeLock().unlock(); 23: } 24: } catch (InterruptedException e) { 25: log.error(&quot;rollback exception&quot;, e); 26: } 27: } 28: 29: /** 30: * 提交消费中的消息已消费成功，返回消费进度 31: * 32: * @return 消费进度 33: */ 34: public long commit() { 35: try { 36: this.lockTreeMap.writeLock().lockInterruptibly(); 37: try { 38: // 消费进度 39: Long offset = this.msgTreeMapTemp.lastKey(); 40: 41: // 42: msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1)); 43: 44: // 45: this.msgTreeMapTemp.clear(); 46: 47: // 返回消费进度 48: if (offset != null) { 49: return offset + 1; 50: } 51: } finally { 52: this.lockTreeMap.writeLock().unlock(); 53: } 54: } catch (InterruptedException e) { 55: log.error(&quot;commit exception&quot;, e); 56: } 57: 58: return -1; 59: } 60: 61: /** 62: * 指定消息重新消费 63: * 逻辑类似于{@link #rollback()} 64: * 65: * @param msgs 消息 66: */ 67: public void makeMessageToCosumeAgain(List&lt;MessageExt&gt; msgs) { 68: try { 69: this.lockTreeMap.writeLock().lockInterruptibly(); 70: try { 71: for (MessageExt msg : msgs) { 72: this.msgTreeMapTemp.remove(msg.getQueueOffset()); 73: this.msgTreeMap.put(msg.getQueueOffset(), msg); 74: } 75: } finally { 76: this.lockTreeMap.writeLock().unlock(); 77: } 78: } catch (InterruptedException e) { 79: log.error(&quot;makeMessageToCosumeAgain exception&quot;, e); 80: } 81: } 82: 83: /** 84: * 获得持有消息前N条 85: * 86: * @param batchSize 条数 87: * @return 消息 88: */ 89: public List&lt;MessageExt&gt; takeMessags(final int batchSize) { 90: List&lt;MessageExt&gt; result = new ArrayList&lt;&gt;(batchSize); 91: final long now = System.currentTimeMillis(); 92: try { 93: this.lockTreeMap.writeLock().lockInterruptibly(); 94: this.lastConsumeTimestamp = now; 95: try { 96: if (!this.msgTreeMap.isEmpty()) { 97: for (int i = 0; i &lt; batchSize; i++) { 98: Map.Entry&lt;Long, MessageExt&gt; entry = this.msgTreeMap.pollFirstEntry(); 99: if (entry != null) { 100: result.add(entry.getValue()); 101: msgTreeMapTemp.put(entry.getKey(), entry.getValue()); 102: } else { 103: break; 104: } 105: } 106: } 107: 108: if (result.isEmpty()) { 109: consuming = false; 110: } 111: } finally { 112: this.lockTreeMap.writeLock().unlock(); 113: } 114: } catch (InterruptedException e) { 115: log.error(&quot;take Messages exception&quot;, e); 116: } 117: 118: return result; 119: }","@type":"BlogPosting","url":"http://www.jfox.info/2017/%E9%98%BF%E9%87%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6rocketmq%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90message%E9%A1%BA%E5%BA%8F%E5%8F%91%E9%80%81%E4%B8%8E%E6%B6%88%E8%B4%B9.html","headline":"阿里消息队列中间件 RocketMQ源码解析：Message顺序发送与消费","dateModified":"2017-01-01T15:59:07+00:00","datePublished":"2017-01-01T15:59:07+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/%E9%98%BF%E9%87%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6rocketmq%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90message%E9%A1%BA%E5%BA%8F%E5%8F%91%E9%80%81%E4%B8%8E%E6%B6%88%E8%B4%B9.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">阿里消息队列中间件 RocketMQ源码解析：Message顺序发送与消费</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T15:59:07+00:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<h1 id="阿里消息队列中间件-rocketmq源码解析message顺序发送与消费">阿里消息队列中间件 RocketMQ源码解析：Message顺序发送与消费</h1>

<ol>
  <li>RocketMQ / MyCAT / Sharding-JDBC <strong>所有</strong>源码分析文章列表</li>
  <li>RocketMQ / MyCAT / Sharding-JDBC <strong>中文注释源码 GitHub 地址</strong></li>
  <li>您对于源码的疑问每条留言<strong>都</strong>将得到<strong>认真</strong>回复。<strong>甚至不知道如何读源码也可以请教噢</strong>。</li>
  <li><strong>新的</strong>源码解析文章<strong>实时</strong>收到通知。<strong>每周更新一篇左右</strong>。</li>
  <li><strong>认真的</strong>源码交流微信群。</li>
</ol>

<ul>
  <li><a href="1. 概述">1. 概述</a></li>
  <li><a href="2. Producer 顺序发送">2. Producer 顺序发送</a></li>
  <li>
    <p><a href="3. Consumer 顺序消费">3. Consumer 顺序消费</a></p>
  </li>
  <li><a href="3.1 获得(锁定)消息队列">3.1 获得(锁定)消息队列</a></li>
  <li><a href="3.2 移除消息队列">3.2 移除消息队列</a></li>
  <li>
    <p><a href="3.3 消费消息队列">3.3 消费消息队列</a></p>
  </li>
  <li><a href="3.1.1 消费消息">3.1.1 消费消息</a></li>
  <li><a href="3.1.2 处理消费结果">3.1.2 处理消费结果</a></li>
  <li><a href="3.13 消息处理队列核心方法">3.13 消息处理队列核心方法</a></li>
</ul>

<h1 id="1-概述">1. 概述</h1>

<p><strong>建议</strong>前置阅读内容：</p>

<p>当然对 <code class="highlighter-rouge">Message</code> 发送与消费已经有一定了解的同学，可以选择跳过。</p>

<p><code class="highlighter-rouge">RocketMQ</code> 提供了两种顺序级别：</p>

<ul>
  <li>普通顺序消息 ：<code class="highlighter-rouge">Producer</code> 将相关联的消息发送到相同的消息队列。</li>
  <li>完全严格顺序 ：在 <code class="highlighter-rouge">普通顺序消息</code> 的基础上，<code class="highlighter-rouge">Consumer</code> 严格顺序消费。</li>
</ul>

<p>绝大部分场景下只需要用到<strong>普通顺序消息</strong>。 
例如说：给用户发送短信消息 + 发送推送消息，将两条消息发送到不同的消息队列，若其中一条消息队列消费较慢造成堵塞，用户可能会收到两条消息会存在一定的时间差，带来的体验会相对较差。当然类似这种场景，即使有一定的时间差，<strong>不会产生系统逻辑上BUG</strong>。另外，<code class="highlighter-rouge">普通顺序消息</code>性能能更加好。 
那么什么时候使用使用<strong>完全严格顺序</strong>？如下是来自官方文档的说明：</p>

<p>目前已知的应用只有数据库 <code class="highlighter-rouge">binlog</code> 同步强依赖严格顺序消息，其他应用绝大部分都可以容忍短暂乱序，推荐使用普通的顺序消息</p>

<p>😈上代码！！！</p>

<h1 id="2-producer-顺序发送">2. <code class="highlighter-rouge">Producer</code> 顺序发送</h1>

<p>官方发送顺序消息的<strong>例子</strong>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1: package org.apache.rocketmq.example.ordermessage;
  2: 
  3: import java.io.UnsupportedEncodingException;
  4: import java.util.List;
  5: import org.apache.rocketmq.client.exception.MQBrokerException;
  6: import org.apache.rocketmq.client.exception.MQClientException;
  7: import org.apache.rocketmq.client.producer.DefaultMQProducer;
  8: import org.apache.rocketmq.client.producer.MQProducer;
  9: import org.apache.rocketmq.client.producer.MessageQueueSelector;
 10: import org.apache.rocketmq.client.producer.SendResult;
 11: import org.apache.rocketmq.common.message.Message;
 12: import org.apache.rocketmq.common.message.MessageQueue;
 13: import org.apache.rocketmq.remoting.common.RemotingHelper;
 14: import org.apache.rocketmq.remoting.exception.RemotingException;
 15: 
 16: public class Producer {
 17:     public static void main(String[] args) throws UnsupportedEncodingException {
 18:         try {
 19:             MQProducer producer = new DefaultMQProducer("please_rename_unique_group_name");
 20:             producer.start();
 21: 
 22:             String[] tags = new String[] {"TagA", "TagB", "TagC", "TagD", "TagE"};
 23:             for (int i = 0; i &lt; 100; i++) {
 24:                 int orderId = i % 10;
 25:                 Message msg =
 26:                     new Message("TopicTestjjj", tags[i % tags.length], "KEY" + i,
 27:                         ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
 28:                 SendResult sendResult = producer.send(msg, new MessageQueueSelector() {
 29:                     @Override
 30:                     public MessageQueue select(List&lt;MessageQueue&gt; mqs, Message msg, Object arg) {
 31:                         Integer id = (Integer) arg;
 32:                         int index = id % mqs.size();
 33:                         return mqs.get(index);
 34:                     }
 35:                 }, orderId);
 36: 
 37:                 System.out.printf("%s%n", sendResult);
 38:             }
 39: 
 40:             producer.shutdown();
 41:         } catch (MQClientException | RemotingException | MQBrokerException | InterruptedException e) {
 42:             e.printStackTrace();
 43:         }
 44:     }
 45: }
</code></pre></div></div>

<ul>
  <li>第 28 至 35 行 ：实现了根据 <code class="highlighter-rouge">id % mqs.size()</code> 来进行消息队列的选择。当前例子，<strong>我们传递 <code class="highlighter-rouge">orderId</code> 作为参数，那么相同的 <code class="highlighter-rouge">orderId</code> 能够进入相同的消息队列</strong>。</li>
</ul>

<p><code class="highlighter-rouge">MessageQueueSelector</code> 接口的<strong>源码</strong>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1: public interface MessageQueueSelector {
  2: 
  3:     /**
  4:      * 选择消息队列
  5:      *
  6:      * @param mqs 消息队列
  7:      * @param msg 消息
  8:      * @param arg 参数
  9:      * @return 消息队列
 10:      */
 11:     MessageQueue select(final List&lt;MessageQueue&gt; mqs, final Message msg, final Object arg);
 12: }
</code></pre></div></div>

<p><code class="highlighter-rouge">Producer</code> 选择队列发送消息方法的<strong>源码</strong>：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 16: private SendResult sendSelectImpl(//
 17:     Message msg, //
 18:     MessageQueueSelector selector, //
 19:     Object arg, //
 20:     final CommunicationMode communicationMode, //
 21:     final SendCallback sendCallback, final long timeout//
 22: ) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
 23:     this.makeSureStateOK();
 24:     Validators.checkMessage(msg, this.defaultMQProducer);
 25: 
 26:     TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());
 27:     if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) {
 28:         MessageQueue mq = null;
 29:         try {
 30:             mq = selector.select(topicPublishInfo.getMessageQueueList(), msg, arg);
 31:         } catch (Throwable e) {
 32:             throw new MQClientException("select message queue throwed exception.", e);
 33:         }
 34: 
 35:         if (mq != null) {
 36:             return this.sendKernelImpl(msg, mq, communicationMode, sendCallback, null, timeout);
 37:         } else {
 38:             throw new MQClientException("select message queue return null.", null);
 39:         }
 40:     }
 41: 
 42:     throw new MQClientException("No route info for this topic, " + msg.getTopic(), null);
 43: }
</code></pre></div></div>

<ul>
  <li>第 30 行 ：选择消息队列。</li>
  <li>第 36 行 ：发送消息。</li>
</ul>

<h1 id="3-consumer-严格顺序消费">3. <code class="highlighter-rouge">Consumer</code> 严格顺序消费</h1>

<p><code class="highlighter-rouge">Consumer</code> 在严格顺序消费时，通过 <strong>三</strong> 把锁保证严格顺序消费。</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">Broker</code> 消息队列锁（<strong>分布式锁</strong>） ：</p>
  </li>
  <li>集群模式下，<code class="highlighter-rouge">Consumer</code> 从 <code class="highlighter-rouge">Broker</code> 获得该锁后，才能进行消息拉取、消费。</li>
  <li>
    <p>广播模式下，<code class="highlighter-rouge">Consumer</code> 无需该锁。</p>
  </li>
  <li><code class="highlighter-rouge">Consumer</code> 消息队列锁（<strong>本地锁</strong>） ：<code class="highlighter-rouge">Consumer</code> 获得该锁才能操作消息队列。</li>
  <li><code class="highlighter-rouge">Consumer</code> 消息处理队列消费锁（<strong>本地锁</strong>） ：<code class="highlighter-rouge">Consumer</code> 获得该锁才能消费消息队列。</li>
</ul>

<p><strong>可能同学有疑问，为什么有 <code class="highlighter-rouge">Consumer</code> 消息队列锁还需要有 <code class="highlighter-rouge">Consumer</code> 消息队列消费锁呢</strong>？😈让我们带着疑问继续往下看。</p>

<h2 id="31-获得锁定消息队列">3.1 获得(锁定)消息队列</h2>

<p><strong>集群模式</strong>下，<code class="highlighter-rouge">Consumer</code> 更新属于自己的消息队列时，会向 <code class="highlighter-rouge">Broker</code> 锁定该消息队列（<em>广播模式下不需要</em>）。如果锁定失败，则更新失败，即该消息队列不属于自己，不能进行消费。核心代码如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1: // ⬇️⬇️⬇️【RebalanceImpl.java】
  2: private boolean updateProcessQueueTableInRebalance(final String topic, final Set&lt;MessageQueue&gt; mqSet, final boolean isOrder) {
  3: // ..... 此处省略部分代码 
  4:     // 增加 不在processQueueTable &amp;&amp; 存在于mqSet 里的消息队列。
  5:     List&lt;PullRequest&gt; pullRequestList = new ArrayList&lt;&gt;(); // 拉消息请求数组
  6:     for (MessageQueue mq : mqSet) {
  7:         if (!this.processQueueTable.containsKey(mq)) {
  8:             if (isOrder &amp;&amp; !this.lock(mq)) { // 顺序消息锁定消息队列
  9:                 log.warn("doRebalance, {}, add a new mq failed, {}, because lock failed", consumerGroup, mq);
 10:                 continue;
 11:             }
 12: 
 13:             this.removeDirtyOffset(mq);
 14:             ProcessQueue pq = new ProcessQueue();
 15:             long nextOffset = this.computePullFromWhere(mq);
 16:             if (nextOffset &gt;= 0) {
 17:                 ProcessQueue pre = this.processQueueTable.putIfAbsent(mq, pq);
 18:                 if (pre != null) {
 19:                     log.info("doRebalance, {}, mq already exists, {}", consumerGroup, mq);
 20:                 } else {
 21:                     log.info("doRebalance, {}, add a new mq, {}", consumerGroup, mq);
 22:                     PullRequest pullRequest = new PullRequest();
 23:                     pullRequest.setConsumerGroup(consumerGroup);
 24:                     pullRequest.setNextOffset(nextOffset);
 25:                     pullRequest.setMessageQueue(mq);
 26:                     pullRequest.setProcessQueue(pq);
 27:                     pullRequestList.add(pullRequest);
 28:                     changed = true;
 29:                 }
 30:             } else {
 31:                 log.warn("doRebalance, {}, add new mq failed, {}", consumerGroup, mq);
 32:             }
 33:         }
 34:     }
 35: 
 36: // ..... 此处省略部分代码 
 37: }
 38: 
 39: // ⬇️⬇️⬇️【RebalanceImpl.java】
 40: /**
 41:  * 请求Broker获得指定消息队列的分布式锁
 42:  *
 43:  * @param mq 队列
 44:  * @return 是否成功
 45:  */
 46: public boolean lock(final MessageQueue mq) {
 47:     FindBrokerResult findBrokerResult = this.mQClientFactory.findBrokerAddressInSubscribe(mq.getBrokerName(), MixAll.MASTER_ID, true);
 48:     if (findBrokerResult != null) {
 49:         LockBatchRequestBody requestBody = new LockBatchRequestBody();
 50:         requestBody.setConsumerGroup(this.consumerGroup);
 51:         requestBody.setClientId(this.mQClientFactory.getClientId());
 52:         requestBody.getMqSet().add(mq);
 53: 
 54:         try {
 55:             // 请求Broker获得指定消息队列的分布式锁
 56:             Set&lt;MessageQueue&gt; lockedMq =
 57:                 this.mQClientFactory.getMQClientAPIImpl().lockBatchMQ(findBrokerResult.getBrokerAddr(), requestBody, 1000);
 58: 
 59:             // 设置消息处理队列锁定成功。锁定消息队列成功，可能本地没有消息处理队列，设置锁定成功会在lockAll()方法。
 60:             for (MessageQueue mmqq : lockedMq) {
 61:                 ProcessQueue processQueue = this.processQueueTable.get(mmqq);
 62:                 if (processQueue != null) {
 63:                     processQueue.setLocked(true);
 64:                     processQueue.setLastLockTimestamp(System.currentTimeMillis());
 65:                 }
 66:             }
 67: 
 68:             boolean lockOK = lockedMq.contains(mq);
 69:             log.info("the message queue lock {}, {} {}",
 70:                 lockOK ? "OK" : "Failed",
 71:                 this.consumerGroup,
 72:                 mq);
 73:             return lockOK;
 74:         } catch (Exception e) {
 75:             log.error("lockBatchMQ exception, " + mq, e);
 76:         }
 77:     }
 78: 
 79:     return false;
 80: }
</code></pre></div></div>

<ul>
  <li>⬆️⬆️⬆️</li>
  <li>第 8 至 11 行 ：顺序消费时，锁定消息队列。如果锁定失败，新增消息处理队列失败。</li>
</ul>

<p><code class="highlighter-rouge">Broker</code> 消息队列锁会过期，默认配置 30s。因此，<code class="highlighter-rouge">Consumer</code> 需要不断向 <code class="highlighter-rouge">Broker</code> 刷新该锁过期时间，默认配置 20s 刷新一次。核心代码如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】
  2: public void start() {
  3:     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())) {
  4:         this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
  5:             @Override
  6:             public void run() {
  7:                 ConsumeMessageOrderlyService.this.lockMQPeriodically();
  8:             }
  9:         }, 1000 * 1, ProcessQueue.REBALANCE_LOCK_INTERVAL, TimeUnit.MILLISECONDS);
 10:     }
 11: }
</code></pre></div></div>

<h2 id="32-移除消息队列">3.2 移除消息队列</h2>

<p>集群模式下，<code class="highlighter-rouge">Consumer</code> 移除自己的消息队列时，会向 <code class="highlighter-rouge">Broker</code> 解锁该消息队列（广播模式下不需要）。核心代码如下：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1: // ⬇️⬇️⬇️【RebalancePushImpl.java】
  2: /**
  3:  * 移除不需要的队列相关的信息
  4:  * 1. 持久化消费进度，并移除之
  5:  * 2. 顺序消费&amp;集群模式，解锁对该队列的锁定
  6:  *
  7:  * @param mq 消息队列
  8:  * @param pq 消息处理队列
  9:  * @return 是否移除成功
 10:  */
 11: @Override
 12: public boolean removeUnnecessaryMessageQueue(MessageQueue mq, ProcessQueue pq) {
 13:     // 同步队列的消费进度，并移除之。
 14:     this.defaultMQPushConsumerImpl.getOffsetStore().persist(mq);
 15:     this.defaultMQPushConsumerImpl.getOffsetStore().removeOffset(mq);
 16:     // 集群模式下，顺序消费移除时，解锁对队列的锁定
 17:     if (this.defaultMQPushConsumerImpl.isConsumeOrderly()
 18:         &amp;&amp; MessageModel.CLUSTERING.equals(this.defaultMQPushConsumerImpl.messageModel())) {
 19:         try {
 20:             if (pq.getLockConsume().tryLock(1000, TimeUnit.MILLISECONDS)) {
 21:                 try {
 22:                     return this.unlockDelay(mq, pq);
 23:                 } finally {
 24:                     pq.getLockConsume().unlock();
 25:                 }
 26:             } else {
 27:                 log.warn("[WRONG]mq is consuming, so can not unlock it, {}. maybe hanged for a while, {}", //
 28:                     mq, //
 29:                     pq.getTryUnlockTimes());
 30: 
 31:                 pq.incTryUnlockTimes();
 32:             }
 33:         } catch (Exception e) {
 34:             log.error("removeUnnecessaryMessageQueue Exception", e);
 35:         }
 36: 
 37:         return false;
 38:     }
 39:     return true;
 40: }
 41: 
 42: // ⬇️⬇️⬇️【RebalancePushImpl.java】
 43: /**
 44:  * 延迟解锁 Broker 消息队列锁
 45:  * 当消息处理队列不存在消息，则直接解锁
 46:  *
 47:  * @param mq 消息队列
 48:  * @param pq 消息处理队列
 49:  * @return 是否解锁成功
 50:  */
 51: private boolean unlockDelay(final MessageQueue mq, final ProcessQueue pq) {
 52:     if (pq.hasTempMessage()) { // TODO 疑问：为什么要延迟移除
 53:         log.info("[{}]unlockDelay, begin {} ", mq.hashCode(), mq);
 54:         this.defaultMQPushConsumerImpl.getmQClientFactory().getScheduledExecutorService().schedule(new Runnable() {
 55:             @Override
 56:             public void run() {
 57:                 log.info("[{}]unlockDelay, execute at once {}", mq.hashCode(), mq);
 58:                 RebalancePushImpl.this.unlock(mq, true);
 59:             }
 60:         }, UNLOCK_DELAY_TIME_MILLS, TimeUnit.MILLISECONDS);
 61:     } else {
 62:         this.unlock(mq, true);
 63:     }
 64:     return true;
 65: }
</code></pre></div></div>

<ul>
  <li>⬆️⬆️⬆️</li>
  <li>第 20 至 32 行 ：获取<strong>消息队列消费锁</strong>，避免和消息队列消费冲突。如果获取锁失败，则移除消息队列失败，等待下次重新分配消费队列时，再进行移除。如果未获得锁而进行移除，则可能出现另外的 <code class="highlighter-rouge">Consumer</code> 和当前 <code class="highlighter-rouge">Consumer</code> 同时消费该消息队列，导致消息无法严格顺序消费。</li>
  <li>第 51 至 64 行 ：解锁 <code class="highlighter-rouge">Broker</code> 消息队列锁。如果消息处理队列存在剩余消息，则延迟解锁 <code class="highlighter-rouge">Broker</code> 消息队列锁。❓为什么消息处理队列存在剩余消息不能直接解锁呢？😈我也不知道，百思不得其解。如果有知道的同学麻烦教育下俺。</li>
</ul>

<h2 id="33-消费消息队列">3.3 消费消息队列</h2>

<p>😏本节会类比<strong>并发消费消费队列</strong>，建议对照 <a href="https://www.jfox.info/go.php?url=http://www.yunai.me/RocketMQ/message-pull-and-consume-second/#6">PushConsumer并发消费消息</a> 一起理解。</p>

<h3 id="311-消费消息">3.1.1 消费消息</h3>

<p><img src="6629d18.png" alt="" /></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】
  2: class ConsumeRequest implements Runnable {
  3: 
  4:     /**
  5:      * 消息处理队列
  6:      */
  7:     private final ProcessQueue processQueue;
  8:     /**
  9:      * 消息队列
 10:      */
 11:     private final MessageQueue messageQueue;
 12: 
 13:     @Override
 14:     public void run() {
 15:         if (this.processQueue.isDropped()) {
 16:             log.warn("run, the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
 17:             return;
 18:         }
 19: 
 20:         // 获得 Consumer 消息队列锁
 21:         final Object objLock = messageQueueLock.fetchLockObject(this.messageQueue);
 22:         synchronized (objLock) {
 23:             // (广播模式) 或者 (集群模式 &amp;&amp; Broker消息队列锁有效)
 24:             if (MessageModel.BROADCASTING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
 25:                 || (this.processQueue.isLocked() &amp;&amp; !this.processQueue.isLockExpired())) {
 26:                 final long beginTime = System.currentTimeMillis();
 27:                 // 循环
 28:                 for (boolean continueConsume = true; continueConsume; ) {
 29:                     if (this.processQueue.isDropped()) {
 30:                         log.warn("the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
 31:                         break;
 32:                     }
 33: 
 34:                     // 消息队列分布式锁未锁定，提交延迟获得锁并消费请求
 35:                     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
 36:                         &amp;&amp; !this.processQueue.isLocked()) {
 37:                         log.warn("the message queue not locked, so consume later, {}", this.messageQueue);
 38:                         ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
 39:                         break;
 40:                     }
 41:                     // 消息队列分布式锁已经过期，提交延迟获得锁并消费请求
 42:                     if (MessageModel.CLUSTERING.equals(ConsumeMessageOrderlyService.this.defaultMQPushConsumerImpl.messageModel())
 43:                         &amp;&amp; this.processQueue.isLockExpired()) {
 44:                         log.warn("the message queue lock expired, so consume later, {}", this.messageQueue);
 45:                         ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 10);
 46:                         break;
 47:                     }
 48: 
 49:                     // 当前周期消费时间超过连续时长，默认：60s，提交延迟消费请求。默认情况下，每消费1分钟休息10ms。
 50:                     long interval = System.currentTimeMillis() - beginTime;
 51:                     if (interval &gt; MAX_TIME_CONSUME_CONTINUOUSLY) {
 52:                         ConsumeMessageOrderlyService.this.submitConsumeRequestLater(processQueue, messageQueue, 10);
 53:                         break;
 54:                     }
 55: 
 56:                     // 获取消费消息。此处和并发消息请求不同，并发消息请求已经带了消费哪些消息。
 57:                     final int consumeBatchSize = ConsumeMessageOrderlyService.this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize();
 58:                     List&lt;MessageExt&gt; msgs = this.processQueue.takeMessags(consumeBatchSize);
 59:                     if (!msgs.isEmpty()) {
 60:                         final ConsumeOrderlyContext context = new ConsumeOrderlyContext(this.messageQueue);
 61: 
 62:                         ConsumeOrderlyStatus status = null;
 63: 
 64:                         // ....省略代码：Hook：before
 65: 
 66:                         // 执行消费
 67:                         long beginTimestamp = System.currentTimeMillis();
 68:                         ConsumeReturnType returnType = ConsumeReturnType.SUCCESS;
 69:                         boolean hasException = false;
 70:                         try {
 71:                             this.processQueue.getLockConsume().lock(); // 锁定队列消费锁
 72: 
 73:                             if (this.processQueue.isDropped()) {
 74:                                 log.warn("consumeMessage, the message queue not be able to consume, because it's dropped. {}",
 75:                                     this.messageQueue);
 76:                                 break;
 77:                             }
 78: 
 79:                             status = messageListener.consumeMessage(Collections.unmodifiableList(msgs), context);
 80:                         } catch (Throwable e) {
 81:                             log.warn("consumeMessage exception: {} Group: {} Msgs: {} MQ: {}", //
 82:                                 RemotingHelper.exceptionSimpleDesc(e), //
 83:                                 ConsumeMessageOrderlyService.this.consumerGroup, //
 84:                                 msgs, //
 85:                                 messageQueue);
 86:                             hasException = true;
 87:                         } finally {
 88:                             this.processQueue.getLockConsume().unlock(); // 锁定队列消费锁
 89:                         }
 90: 
 91:                         // ....省略代码：解析消费结果状态
 92: 
 93:                         // ....省略代码：Hook：after
 94: 
 95:                         ConsumeMessageOrderlyService.this.getConsumerStatsManager()
 96:                             .incConsumeRT(ConsumeMessageOrderlyService.this.consumerGroup, messageQueue.getTopic(), consumeRT);
 97: 
 98:                         // 处理消费结果
 99:                         continueConsume = ConsumeMessageOrderlyService.this.processConsumeResult(msgs, status, context, this);
100:                     } else {
101:                         continueConsume = false;
102:                     }
103:                 }
104:             } else {
105:                 if (this.processQueue.isDropped()) {
106:                     log.warn("the message queue not be able to consume, because it's dropped. {}", this.messageQueue);
107:                     return;
108:                 }
109: 
110:                 ConsumeMessageOrderlyService.this.tryLockLaterAndReconsume(this.messageQueue, this.processQueue, 100);
111:             }
112:         }
113:     }
114: 
115: }
</code></pre></div></div>

<ul>
  <li>⬆️⬆️⬆️</li>
  <li>第 20 行 ：获得 <code class="highlighter-rouge">Consumer</code> 消息队列锁。</li>
  <li>第 58 行 ：从消息处理队列顺序获得消息。<strong>和并发消费获得消息不同。并发消费请求在请求创建时，已经设置好消费哪些消息。</strong></li>
  <li>第 71 行 ：获得 <code class="highlighter-rouge">Consumer</code> 消息处理队列消费锁。相比【<code class="highlighter-rouge">Consumer</code>消息队列锁】，其粒度较小。这就是上文提到的❓<strong>为什么有<code class="highlighter-rouge">Consumer</code>消息队列锁还需要有 Consumer 消息队列消费锁呢</strong>的原因。</li>
  <li>第 79 行 ：<strong>执行消费</strong>。</li>
  <li>第 99 行 ：处理消费结果。</li>
</ul>

<h3 id="312-处理消费结果">3.1.2 处理消费结果</h3>

<p>顺序消费消息结果 (<code class="highlighter-rouge">ConsumeOrderlyStatus</code>) 有四种情况：</p>

<ul>
  <li><code class="highlighter-rouge">SUCCESS</code> ：消费成功<strong>但不提交</strong>。</li>
  <li><code class="highlighter-rouge">ROLLBACK</code> ：消费失败，消费回滚。</li>
  <li><code class="highlighter-rouge">COMMIT</code> ：消费成功提交并且提交。</li>
  <li><code class="highlighter-rouge">SUSPEND_CURRENT_QUEUE_A_MOMENT</code> ：消费失败，挂起消费队列一会会，稍后继续消费。</li>
</ul>

<p>考虑到 <code class="highlighter-rouge">ROLLBACK</code> 、<code class="highlighter-rouge">COMMIT</code> 暂时只使用在 <code class="highlighter-rouge">MySQL binlog</code> 场景，官方将这两状态标记为 <code class="highlighter-rouge">@Deprecated</code>。当然，相应的实现逻辑依然保留。</p>

<p>在<strong>并发消费</strong>场景时，如果消费失败，<code class="highlighter-rouge">Consumer</code> 会将消费失败消息发回到 <code class="highlighter-rouge">Broker</code> 重试队列，跳过当前消息，等待下次拉取该消息再进行消费。</p>

<p>但是在<strong>完全严格顺序消费</strong>消费时，这样做显然不行。也因此，消费失败的消息，会挂起队列一会会，稍后继续消费。</p>

<p>不过消费失败的消息一直失败，也不可能一直消费。当超过消费重试上限时，<code class="highlighter-rouge">Consumer</code> 会将消费失败超过上限的消息发回到 <code class="highlighter-rouge">Broker</code> 死信队列。</p>

<p>让我们来看看代码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1: // ⬇️⬇️⬇️【ConsumeMessageOrderlyService.java】
  2: /**
  3:  * 处理消费结果，并返回是否继续消费
  4:  *
  5:  * @param msgs 消息
  6:  * @param status 消费结果状态
  7:  * @param context 消费Context
  8:  * @param consumeRequest 消费请求
  9:  * @return 是否继续消费
 10:  */
 11: public boolean processConsumeResult(//
 12:     final List&lt;MessageExt&gt; msgs, //
 13:     final ConsumeOrderlyStatus status, //
 14:     final ConsumeOrderlyContext context, //
 15:     final ConsumeRequest consumeRequest//
 16: ) {
 17:     boolean continueConsume = true;
 18:     long commitOffset = -1L;
 19:     if (context.isAutoCommit()) {
 20:         switch (status) {
 21:             case COMMIT:
 22:             case ROLLBACK:
 23:                 log.warn("the message queue consume result is illegal, we think you want to ack these message {}", consumeRequest.getMessageQueue());
 24:             case SUCCESS:
 25:                 // 提交消息已消费成功到消息处理队列
 26:                 commitOffset = consumeRequest.getProcessQueue().commit();
 27:                 // 统计
 28:                 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
 29:                 break;
 30:             case SUSPEND_CURRENT_QUEUE_A_MOMENT:
 31:                 // 统计
 32:                 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
 33:                 if (checkReconsumeTimes(msgs)) { // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms
 34:                     // 设置消息重新消费
 35:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);
 36:                     // 提交延迟消费请求
 37:                     this.submitConsumeRequestLater(//
 38:                         consumeRequest.getProcessQueue(), //
 39:                         consumeRequest.getMessageQueue(), //
 40:                         context.getSuspendCurrentQueueTimeMillis());
 41:                     continueConsume = false;
 42:                 } else {
 43:                     commitOffset = consumeRequest.getProcessQueue().commit();
 44:                 }
 45:                 break;
 46:             default:
 47:                 break;
 48:         }
 49:     } else {
 50:         switch (status) {
 51:             case SUCCESS:
 52:                 this.getConsumerStatsManager().incConsumeOKTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
 53:                 break;
 54:             case COMMIT:
 55:                 // 提交消息已消费成功到消息处理队列
 56:                 commitOffset = consumeRequest.getProcessQueue().commit();
 57:                 break;
 58:             case ROLLBACK:
 59:                 // 设置消息重新消费
 60:                 consumeRequest.getProcessQueue().rollback();
 61:                 this.submitConsumeRequestLater(//
 62:                     consumeRequest.getProcessQueue(), //
 63:                     consumeRequest.getMessageQueue(), //
 64:                     context.getSuspendCurrentQueueTimeMillis());
 65:                 continueConsume = false;
 66:                 break;
 67:             case SUSPEND_CURRENT_QUEUE_A_MOMENT: // 计算是否暂时挂起（暂停）消费N毫秒，默认：10ms
 68:                 this.getConsumerStatsManager().incConsumeFailedTPS(consumerGroup, consumeRequest.getMessageQueue().getTopic(), msgs.size());
 69:                 if (checkReconsumeTimes(msgs)) {
 70:                     // 设置消息重新消费
 71:                     consumeRequest.getProcessQueue().makeMessageToCosumeAgain(msgs);
 72:                     // 提交延迟消费请求
 73:                     this.submitConsumeRequestLater(//
 74:                         consumeRequest.getProcessQueue(), //
 75:                         consumeRequest.getMessageQueue(), //
 76:                         context.getSuspendCurrentQueueTimeMillis());
 77:                     continueConsume = false;
 78:                 }
 79:                 break;
 80:             default:
 81:                 break;
 82:         }
 83:     }
 84: 
 85:     // 消息处理队列未dropped，提交有效消费进度
 86:     if (commitOffset &gt;= 0 &amp;&amp; !consumeRequest.getProcessQueue().isDropped()) {
 87:         this.defaultMQPushConsumerImpl.getOffsetStore().updateOffset(consumeRequest.getMessageQueue(), commitOffset, false);
 88:     }
 89: 
 90:     return continueConsume;
 91: }
 92: 
 93: private int getMaxReconsumeTimes() {
 94:     // default reconsume times: Integer.MAX_VALUE
 95:     if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {
 96:         return Integer.MAX_VALUE;
 97:     } else {
 98:         return this.defaultMQPushConsumer.getMaxReconsumeTimes();
 99:     }
100: }
101: 
102: /**
103:  * 计算是否要暂停消费
104:  * 不暂停条件：存在消息都超过最大消费次数并且都发回broker成功
105:  *
106:  * @param msgs 消息
107:  * @return 是否要暂停
108:  */
109: private boolean checkReconsumeTimes(List&lt;MessageExt&gt; msgs) {
110:     boolean suspend = false;
111:     if (msgs != null &amp;&amp; !msgs.isEmpty()) {
112:         for (MessageExt msg : msgs) {
113:             if (msg.getReconsumeTimes() &gt;= getMaxReconsumeTimes()) {
114:                 MessageAccessor.setReconsumeTime(msg, String.valueOf(msg.getReconsumeTimes()));
115:                 if (!sendMessageBack(msg)) { // 发回失败，中断
116:                     suspend = true;
117:                     msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
118:                 }
119:             } else {
120:                 suspend = true;
121:                 msg.setReconsumeTimes(msg.getReconsumeTimes() + 1);
122:             }
123:         }
124:     }
125:     return suspend;
126: }
127: 
128: /**
129:  * 发回消息。
130:  * 消息发回broker后，对应的消息队列是死信队列。
131:  *
132:  * @param msg 消息
133:  * @return 是否发送成功
134:  */
135: public boolean sendMessageBack(final MessageExt msg) {
136:     try {
137:         // max reconsume times exceeded then send to dead letter queue.
138:         Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());
139:         String originMsgId = MessageAccessor.getOriginMessageId(msg);
140:         MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);
141:         newMsg.setFlag(msg.getFlag());
142:         MessageAccessor.setProperties(newMsg, msg.getProperties());
143:         MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());
144:         MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes()));
145:         MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));
146:         newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());
147: 
148:         this.defaultMQPushConsumer.getDefaultMQPushConsumerImpl().getmQClientFactory().getDefaultMQProducer().send(newMsg);
149:         return true;
150:     } catch (Exception e) {
151:         log.error("sendMessageBack exception, group: " + this.consumerGroup + " msg: " + msg.toString(), e);
152:     }
153: 
154:     return false;
155: }
</code></pre></div></div>

<ul>
  <li>⬆️⬆️⬆️</li>
  <li>第 21 至 29 行 ：消费成功。在自动提交进度( <code class="highlighter-rouge">AutoCommit</code> )的情况下，<code class="highlighter-rouge">COMMIT</code>、<code class="highlighter-rouge">ROLLBACK</code>、<code class="highlighter-rouge">SUCCESS</code> 逻辑<strong>已经统一</strong>。</li>
  <li>第 30 至 45 行 ：消费失败。当消息重试次数超过上限（默认 ：16次）时，将消息发送到 <code class="highlighter-rouge">Broker</code> 死信队列，跳过这些消息。此时，消息队列无需挂起，继续消费后面的消息。</li>
  <li>第 85 至 88 行 ：提交消费进度。</li>
</ul>

<h3 id="313-消息处理队列核心方法">3.13 消息处理队列核心方法</h3>

<p>😈涉及到的四个核心方法的源码：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  1: // ⬇️⬇️⬇️【ProcessQueue.java】
  2: /**
  3:  * 消息映射
  4:  * key：消息队列位置
  5:  */
  6: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMap = new TreeMap&lt;&gt;();    /**
  7:  * 消息映射临时存储（消费中的消息）
  8:  */
  9: private final TreeMap&lt;Long, MessageExt&gt; msgTreeMapTemp = new TreeMap&lt;&gt;();
 10: 
 11: /**
 12:  * 回滚消费中的消息
 13:  * 逻辑类似于{@link #makeMessageToCosumeAgain(List)}
 14:  */
 15: public void rollback() {
 16:     try {
 17:         this.lockTreeMap.writeLock().lockInterruptibly();
 18:         try {
 19:             this.msgTreeMap.putAll(this.msgTreeMapTemp);
 20:             this.msgTreeMapTemp.clear();
 21:         } finally {
 22:             this.lockTreeMap.writeLock().unlock();
 23:         }
 24:     } catch (InterruptedException e) {
 25:         log.error("rollback exception", e);
 26:     }
 27: }
 28: 
 29: /**
 30:  * 提交消费中的消息已消费成功，返回消费进度
 31:  *
 32:  * @return 消费进度
 33:  */
 34: public long commit() {
 35:     try {
 36:         this.lockTreeMap.writeLock().lockInterruptibly();
 37:         try {
 38:             // 消费进度
 39:             Long offset = this.msgTreeMapTemp.lastKey();
 40: 
 41:             //
 42:             msgCount.addAndGet(this.msgTreeMapTemp.size() * (-1));
 43: 
 44:             //
 45:             this.msgTreeMapTemp.clear();
 46: 
 47:             // 返回消费进度
 48:             if (offset != null) {
 49:                 return offset + 1;
 50:             }
 51:         } finally {
 52:             this.lockTreeMap.writeLock().unlock();
 53:         }
 54:     } catch (InterruptedException e) {
 55:         log.error("commit exception", e);
 56:     }
 57: 
 58:     return -1;
 59: }
 60: 
 61: /**
 62:  * 指定消息重新消费
 63:  * 逻辑类似于{@link #rollback()}
 64:  *
 65:  * @param msgs 消息
 66:  */
 67: public void makeMessageToCosumeAgain(List&lt;MessageExt&gt; msgs) {
 68:     try {
 69:         this.lockTreeMap.writeLock().lockInterruptibly();
 70:         try {
 71:             for (MessageExt msg : msgs) {
 72:                 this.msgTreeMapTemp.remove(msg.getQueueOffset());
 73:                 this.msgTreeMap.put(msg.getQueueOffset(), msg);
 74:             }
 75:         } finally {
 76:             this.lockTreeMap.writeLock().unlock();
 77:         }
 78:     } catch (InterruptedException e) {
 79:         log.error("makeMessageToCosumeAgain exception", e);
 80:     }
 81: }
 82: 
 83: /**
 84:  * 获得持有消息前N条
 85:  *
 86:  * @param batchSize 条数
 87:  * @return 消息
 88:  */
 89: public List&lt;MessageExt&gt; takeMessags(final int batchSize) {
 90:     List&lt;MessageExt&gt; result = new ArrayList&lt;&gt;(batchSize);
 91:     final long now = System.currentTimeMillis();
 92:     try {
 93:         this.lockTreeMap.writeLock().lockInterruptibly();
 94:         this.lastConsumeTimestamp = now;
 95:         try {
 96:             if (!this.msgTreeMap.isEmpty()) {
 97:                 for (int i = 0; i &lt; batchSize; i++) {
 98:                     Map.Entry&lt;Long, MessageExt&gt; entry = this.msgTreeMap.pollFirstEntry();
 99:                     if (entry != null) {
100:                         result.add(entry.getValue());
101:                         msgTreeMapTemp.put(entry.getKey(), entry.getValue());
102:                     } else {
103:                         break;
104:                     }
105:                 }
106:             }
107: 
108:             if (result.isEmpty()) {
109:                 consuming = false;
110:             }
111:         } finally {
112:             this.lockTreeMap.writeLock().unlock();
113:         }
114:     } catch (InterruptedException e) {
115:         log.error("take Messages exception", e);
116:     }
117: 
118:     return result;
119: }
</code></pre></div></div>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/%E9%98%BF%E9%87%8C%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%B8%AD%E9%97%B4%E4%BB%B6rocketmq%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90message%E9%A1%BA%E5%BA%8F%E5%8F%91%E9%80%81%E4%B8%8E%E6%B6%88%E8%B4%B9.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/springmvcmybatis%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E4%B8%80.html">&laquo; SpringMVC+MyBatis 事务管理一</a>
  
  
  <a class="next" href="/2017/%E9%80%8F%E5%BD%BB%E7%90%86%E8%A7%A3spring%E4%BA%8B%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%E4%B9%8B%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0.html">透彻理解Spring事务设计思想之手写实现 &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
