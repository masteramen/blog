<!-- build time:Sat Oct 27 2018 21:00:20 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="1/2/3 Statement 和 Preparedstatement 的区别4 读取properties配置文件5 数据库连接池6 利用数据库连接池连接数据库1 使用Statement执行含有动态信息的SQL语句时有几个不足:　　1.1 由于需要将动态数据拼接到SQL语句中,这导致程序复杂度高,容易出错1.2 拼接的数据若含有SQL语法内容就会导致拼接后的SQL语法含义改变而出现SQL注入攻击1"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="JDBC02 利用JDBC连接数据库【使用数据库连接池】"><meta property="og:url" content="http://www.jfox.info/2017/jdbc02利用jdbc连接数据库使用数据库连接池.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="1/2/3 Statement 和 Preparedstatement 的区别4 读取properties配置文件5 数据库连接池6 利用数据库连接池连接数据库1 使用Statement执行含有动态信息的SQL语句时有几个不足:　　1.1 由于需要将动态数据拼接到SQL语句中,这导致程序复杂度高,容易出错1.2 拼接的数据若含有SQL语法内容就会导致拼接后的SQL语法含义改变而出现SQL注入攻击1"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2017/1151/fa7695b.gif"><meta property="og:image" content="http://www.jfox.info/wp-content/uploads/2017/07/14994283631.gif"><meta property="og:image" content="http://www.jfox.info/2017/1151/fa7695b.gif"><meta property="og:image" content="http://www.jfox.info/wp-content/uploads/2017/07/14994283631.gif"><meta property="og:image" content="http://www.jfox.info/2017/1151/e074467.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/9b5af48.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/fa7695b.gif"><meta property="og:image" content="http://www.jfox.info/wp-content/uploads/2017/07/14994283631.gif"><meta property="og:image" content="http://www.jfox.info/2017/1151/04efb20.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/e5563f4.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/d7c1f3b.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/50cb78f.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/de847d3.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/68badca.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/db6cb45.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/fa88dfe.png"><meta property="og:image" content="http://www.jfox.info/2017/1151/fa7695b.gif"><meta property="og:image" content="http://www.jfox.info/wp-content/uploads/2017/07/14994283631.gif"><meta property="og:image" content="http://www.jfox.info/2017/1151/fa7695b.gif"><meta property="og:image" content="http://www.jfox.info/wp-content/uploads/2017/07/14994283631.gif"><meta property="og:image" content="http://www.jfox.info/2017/1151/fa7695b.gif"><meta property="og:image" content="http://www.jfox.info/wp-content/uploads/2017/07/14994283631.gif"><meta property="og:image" content="http://www.jfox.info/2017/1151/fa7695b.gif"><meta property="og:image" content="http://www.jfox.info/wp-content/uploads/2017/07/14994283631.gif"><meta property="og:updated_time" content="2018-10-27T12:29:39.341Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="JDBC02 利用JDBC连接数据库【使用数据库连接池】"><meta name="twitter:description" content="1/2/3 Statement 和 Preparedstatement 的区别4 读取properties配置文件5 数据库连接池6 利用数据库连接池连接数据库1 使用Statement执行含有动态信息的SQL语句时有几个不足:　　1.1 由于需要将动态数据拼接到SQL语句中,这导致程序复杂度高,容易出错1.2 拼接的数据若含有SQL语法内容就会导致拼接后的SQL语法含义改变而出现SQL注入攻击1"><meta name="twitter:image" content="http://www.jfox.info/2017/1151/fa7695b.gif"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/jdbc02利用jdbc连接数据库使用数据库连接池.html"><title>JDBC02 利用JDBC连接数据库【使用数据库连接池】 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/jdbc02利用jdbc连接数据库使用数据库连接池.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">JDBC02 利用JDBC连接数据库【使用数据库连接池】</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:54:11+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>1/2/3 Statement 和 Preparedstatement 的区别</p><p>4 读取properties配置文件</p><p>5 数据库连接池</p><p>6 利用数据库连接池连接数据库</p><h2 id="1-使用Statement执行含有动态信息的SQL语句时有几个不足"><a href="#1-使用Statement执行含有动态信息的SQL语句时有几个不足" class="headerlink" title="1 使用Statement执行含有动态信息的SQL语句时有几个不足:"></a>1 使用Statement执行含有动态信息的SQL语句时有几个不足:</h2><h3 id="1-1-由于需要将动态数据拼接到SQL语句中-这导致程序复杂度高-容易出错"><a href="#1-1-由于需要将动态数据拼接到SQL语句中-这导致程序复杂度高-容易出错" class="headerlink" title="　　1.1 由于需要将动态数据拼接到SQL语句中,这导致程序复杂度高,容易出错"></a>　　1.1 由于需要将动态数据拼接到SQL语句中,这导致程序复杂度高,容易出错</h3><p>1.2 拼接的数据若含有SQL语法内容就会导致拼接后的SQL语法含义改变而出现SQL注入攻击<br>1.3 当大批量执行语义相同,但是含有动态数据的SQL时效率很差</p><h2 id="2-使用Statement执行SQL语句不好的原因"><a href="#2-使用Statement执行SQL语句不好的原因" class="headerlink" title="2 使用Statement执行SQL语句不好的原因"></a>2 使用Statement执行SQL语句不好的原因</h2><h3 id="2-1-当执行一条SQL语句发送到数据库时-数据库先将该SQL解析并生成一个执行计划-这个过程会消耗资源和性能-，如果多次执行一样的SQL语句-数据库会重用执行计划-但是若多次执行语义相同但是含有动态数据的SQL时-数据库会生成不同的执行计划-严重影响数据库的开销"><a href="#2-1-当执行一条SQL语句发送到数据库时-数据库先将该SQL解析并生成一个执行计划-这个过程会消耗资源和性能-，如果多次执行一样的SQL语句-数据库会重用执行计划-但是若多次执行语义相同但是含有动态数据的SQL时-数据库会生成不同的执行计划-严重影响数据库的开销" class="headerlink" title="　　2.1 当执行一条SQL语句发送到数据库时,数据库先将该SQL解析并生成一个执行计划(这个过程会消耗资源和性能)，如果多次执行一样的SQL语句,数据库会重用执行计划,但是若多次执行语义相同但是含有动态数据的SQL时,数据库会生成不同的执行计划,严重影响数据库的开销"></a>　　2.1 当执行一条SQL语句发送到数据库时,数据库先将该SQL解析并生成一个执行计划(这个过程会消耗资源和性能)，如果多次执行一样的SQL语句,数据库会重用执行计划,但是若多次执行语义相同但是含有动态数据的SQL时,数据库会生成不同的执行计划,严重影响数据库的开销</h3><p>2.2 例如</p><p>执行 SELECT <em>FROM userifo_fury 生成一个执行计划再次执行SELECT </em>FROM userifo_fury 就会重用上面的执行计划(因为这是静态的SQL语句</p><p>但是，执行INSERT INTO userifo VALUES(1, ‘JACK’,’122314′,’<a href="mailto:141234@QQ.COM" target="_blank" rel="noopener">141234@QQ.COM</a>’,’FURY’,15600) ) 生成一个执行计划，再执行执行INSERT INTO userifo VALUES(2, ‘rose’,’122314′,’<a href="mailto:141234@QQ.COM" target="_blank" rel="noopener">141234@QQ.COM</a>’,’FURY’,15600)由于内容不同,会再次生成另外一个执行计划，若执行1000次上述情况的INSERT,数据库会产生1000个执行计划，这样就严重影响了数据库的效率<br>因此，Statement只适合执行静态的SQL语句，不适合执行动态的SQL语句</p><h2 id="3-利用PreparedStatement代替Statement"><a href="#3-利用PreparedStatement代替Statement" class="headerlink" title="3 利用PreparedStatement代替Statement"></a>3 利用PreparedStatement代替Statement</h2><h3 id="编写简单"><a href="#编写简单" class="headerlink" title="编写简单"></a>编写简单</h3><h3 id="没有SQL注入问题"><a href="#没有SQL注入问题" class="headerlink" title="没有SQL注入问题"></a>没有SQL注入问题</h3><h3 id="批量执行语义相同的SQL语句会重用执行计划"><a href="#批量执行语义相同的SQL语句会重用执行计划" class="headerlink" title="　　批量执行语义相同的SQL语句会重用执行计划"></a>　　批量执行语义相同的SQL语句会重用执行计划</h3><p><img src="/2017/1151/fa7695b.gif" alt=""><img src="/wp-content/uploads/2017/07/14994283631.gif" alt=""><br>1package cn.xiangxu.entity;<br>2 3import java.io.Serializable;<br>4 5publicclass User implements Serializable {<br>6 7privatestaticfinallong serialVersionUID = -5109978284633713580L;<br>8 9private Integer id;<br>10private String name;<br>11private String pwd;<br>12public User() {<br>13super();<br>14// TODO Auto-generated constructor stub15 }<br>16public User(Integer id, String name, String pwd) {<br>17super();<br>18this.id = id;<br>19this.name = name;<br>20this.pwd = pwd;<br>21 }<br>22 @Override<br>23publicint hashCode() {<br>24finalint prime = 31;<br>25int result = 1;<br>26 result = prime * result + ((id == null) ? 0 : id.hashCode());<br>27return result;<br>28 }<br>29 @Override<br>30publicboolean equals(Object obj) {<br>31if (this == obj)<br>32returntrue;<br>33if (obj == null)<br>34returnfalse;<br>35if (getClass() != obj.getClass())<br>36returnfalse;<br>37 User other = (User) obj;<br>38if (id == null) {<br>39if (other.id != null)<br>40returnfalse;<br>41 } elseif (!id.equals(other.id))<br>42returnfalse;<br>43returntrue;<br>44 }<br>45public Integer getId() {<br>46return id;<br>47 }<br>48publicvoid setId(Integer id) {<br>49this.id = id;<br>50 }<br>51public String getName() {<br>52return name;<br>53 }<br>54publicvoid setName(String name) {<br>55this.name = name;<br>56 }<br>57public String getPwd() {<br>58return pwd;<br>59 }<br>60publicvoid setPwd(String pwd) {<br>61this.pwd = pwd;<br>62 }<br>63 @Override<br>64public String toString() {<br>65return “User [id=” + id + “, name=” + name + “, pwd=” + pwd + “]”;<br>66 }<br>67686970 }</p><p>user表对应的实体类<img src="/2017/1151/fa7695b.gif" alt=""><img src="/wp-content/uploads/2017/07/14994283631.gif" alt=""><br>1package testJDBC;<br>2 3import java.sql.Connection;<br>4import java.sql.DriverManager;<br>5import java.sql.PreparedStatement;<br>6import java.sql.ResultSet;<br>7import java.sql.SQLException;<br>8import java.util.ArrayList;<br>9import java.util.List;<br>1011import org.junit.Test;<br>1213import cn.xiangxu.entity.User;<br>1415publicclass TestCase {<br>16 @Test<br>17publicvoid test01() {<br>18 Connection conn = null;<br>19 PreparedStatement ps = null;<br>20 ResultSet rs = null;<br>21try {<br>22 Class.forName(“com.mysql.jdbc.Driver”); // 加载数据库驱动2324 conn = DriverManager.getConnection( // 初始化连接对象25 “jdbc:mysql://localhost:3306/test”, “root”, “182838”);<br>262728 String sql = “SELECT * FROM user WHERE pwd = ? “; // 拼接SQL语句，位置参数用？代替2930 ps = conn.prepareStatement(sql); // 初始化预编译执行对象3132 ps.setString(1, “182838”); // 设置SQL语句中的位置位置参数（注意：是从1开始数不是从0开始数）3334 rs = ps.executeQuery(); // 执行SQL语句3536 List<user>users = new ArrayList<user>(); // 创建一个集合来存放记录对象37while(rs.next()) { // 遍历结果集<br>38// System.out.println(“====================”);<br>39// System.out.println(rs.getInt(“id”));<br>40// System.out.println(rs.getString(“name”));<br>41// System.out.println(rs.getString(“pwd”));42 User user = new User();<br>43 user.setId(rs.getInt(“id”));<br>44 user.setName(rs.getString(“name”));<br>45 user.setPwd(rs.getString(“pwd”));<br>46 users.add(user); // 向集合中添加元素47 }<br>4849 System.out.println(users); // 打印输出集合50for(User user : users) {<br>51 System.out.println(user);<br>52 }<br>5354// 释放资源55 rs.close();<br>56 ps.close();<br>57 conn.close();<br>5859 } catch (Exception e) {<br>60// TODO Auto-generated catch block61 e.printStackTrace();<br>62 } finally {<br>63if(rs != null) {<br>64try {<br>65 rs.close();<br>66 } catch (SQLException e) {<br>67// TODO Auto-generated catch block68 e.printStackTrace();<br>69 }<br>70 }<br>71if(ps != null) {<br>72try {<br>73 ps.close();<br>74 } catch (SQLException e) {<br>75// TODO Auto-generated catch block76 e.printStackTrace();<br>77 }<br>78 }<br>79if(conn != null) {<br>80try {<br>81 conn.close();<br>82 } catch (SQLException e) {<br>83// TODO Auto-generated catch block84 e.printStackTrace();<br>85 }<br>86 }<br>87 }<br>8889 }<br>9091 }</user></user></p><p>使用预编译Statement的实例</p><h2 id="4-利用Properties对象读取properties配置文件中的信息"><a href="#4-利用Properties对象读取properties配置文件中的信息" class="headerlink" title="4 利用Properties对象读取properties配置文件中的信息"></a>4 利用Properties对象读取properties配置文件中的信息</h2><h3 id="4-1-Properties继承了Hashtable类，Properties对象也是使用键值对的方式来保存数据，但是Properties对象的键和值都是字符串类型"><a href="#4-1-Properties继承了Hashtable类，Properties对象也是使用键值对的方式来保存数据，但是Properties对象的键和值都是字符串类型" class="headerlink" title="　　4.1 Properties继承了Hashtable类，Properties对象也是使用键值对的方式来保存数据，但是Properties对象的键和值都是字符串类型"></a>　　4.1 Properties继承了Hashtable类，Properties对象也是使用键值对的方式来保存数据，但是Properties对象的键和值都是字符串类型</h3><p>class Properties extends Hashtable&lt;Object,Object&gt;</p><h3 id="4-2-Properties-类中的主要方法"><a href="#4-2-Properties-类中的主要方法" class="headerlink" title="　　4.2 Properties 类中的主要方法"></a>　　4.2 Properties 类中的主要方法</h3><h4 id="4-2-1-public-synchronized-void-load-InputStream-inStream-throws-IOException"><a href="#4-2-1-public-synchronized-void-load-InputStream-inStream-throws-IOException" class="headerlink" title="　　　　4.2.1 public synchronized void load(InputStream inStream) throws IOException"></a>　　　　4.2.1 public synchronized void load(InputStream inStream) throws IOException</h4><p>将properties属性文件的文件输入流加载到Properties对象</p><p><strong><img src="/2017/1151/e074467.png" alt=""></strong></p><h4 id="4-2-2-public-void-store-OutputStream-out-String-comments-throws-IOException"><a href="#4-2-2-public-void-store-OutputStream-out-String-comments-throws-IOException" class="headerlink" title="　　　　4.2.2 public void store(OutputStream out, String comments) throws IOException"></a>　　　　4.2.2 public void store(OutputStream out, String comments) <em>throws IOException</em></h4><p>将Properties对象中的属性列表保存到输出流文件中</p><p><img src="/2017/1151/9b5af48.png" alt=""></p><p>注意：第二个参数表示注释信息（注意：properties文件中不能用中文），在注释信息后面会自动添加一个时间信息</p><p>注意：新创建的文件在项目的根目录下面（问题：为什么在eclipse中没有，但是到文件夹中却能找到？？？）</p><h4 id="4-2-3-public-String-getProperty-String-key"><a href="#4-2-3-public-String-getProperty-String-key" class="headerlink" title="　　　　4.2.3 public String getProperty(String key)"></a>　　　　4.2.3 public String getProperty(String key)</h4><p>获取属性值，参数是属性的键</p><h4 id="4-2-4-public-synchronized-Object-setProperty-String-key-String-value"><a href="#4-2-4-public-synchronized-Object-setProperty-String-key-String-value" class="headerlink" title="　　　　4.2.4 public synchronized Object setProperty(String key, String value)"></a>　　　　4.2.4 public synchronized Object setProperty(String key, String value)</h4><p>修改属性值，参数1是属性的键，参数2是属性的新值</p><h3 id="4-3-案例"><a href="#4-3-案例" class="headerlink" title="　　4.3 案例"></a>　　4.3 案例</h3><p>要求：读取properties配置文件总的属性值，将读取到的属性值进行修改后保存到另外一个properties配置文件中<br><img src="/2017/1151/fa7695b.gif" alt=""><img src="/wp-content/uploads/2017/07/14994283631.gif" alt=""><br>1package cn.xiangxu.entity;<br>2 3import java.io.FileInputStream;<br>4import java.io.FileOutputStream;<br>5import java.io.InputStream;<br>6import java.util.Iterator;<br>7import java.util.Properties;<br>8 9publicclass Test {<br>10publicstaticvoid main(String[] args) {<br>11try {<br>12 Properties prop = new Properties(); // 创建Properties对象<br>1314// prop.load(new FileInputStream(“config.properties”)); // 使用这种方式时，配置文件必须放在项目的根目录下15 InputStream is = Test.class.getClassLoader().getResourceAsStream(“config/config.properties”); // 读取属性文件1617 prop.load(is); // 加载属性列表1819 Iterator<string>it=prop.stringPropertyNames().iterator(); // 将配置文件中的所有key放到一个可迭代对象中20while(it.hasNext()){ // 利用迭代器模式进行迭代21 String key=it.next(); // 读取下一个迭代对象的下一个元素22 System.out.println(key+”:”+prop.getProperty(key)); // 根据key值获取value值（获取属性信息）23 }<br>2425 is.close(); // 关闭输入流，释放资源2627 FileOutputStream oFile = new FileOutputStream(“b.properties”, true);//创建一个输出流文件，true表示追加打开28 prop.setProperty(“maxactive”, “33”); // 修改属性信息29 prop.store(oFile, “zhe shi yi ge xin de shu xing pei zhi wen jian.”); // 将Properties对象中的内容放到刚刚创建的文件中去30 oFile.close(); // 关闭输出流，释放资源3132 } catch (Exception e) {<br>33// TODO Auto-generated catch block34 e.printStackTrace();<br>35 }<br>36 }<br>37 }</string></p><p>读取属性配置文件信息<br>等待读取的properties配置文件的位置如下图所示</p><p><img src="/2017/1151/04efb20.png" alt=""></p><h2 id="5-数据库连接池"><a href="#5-数据库连接池" class="headerlink" title="5 数据库连接池"></a>5 数据库连接池</h2><h3 id="5-1-什么是数据库连接池"><a href="#5-1-什么是数据库连接池" class="headerlink" title="　　5.1 什么是数据库连接池"></a>　　5.1 什么是数据库连接池</h3><p>程序启动时就创建足够多的数据库连接，并将这些连接组成一个连接池，由程序自动地对池中的连接进行申请、使用、释放</p><h3 id="5-2-数据库连接池的运行机制"><a href="#5-2-数据库连接池的运行机制" class="headerlink" title="　　5.2 数据库连接池的运行机制"></a>　　5.2 数据库连接池的运行机制</h3><p>》程序初始化时创建连接池</p><p>》需要操作数据库时向数据库连接池申请一个可用的数据库连接</p><p>》使用完毕后就将数据库连接还给数据库连接池（注意：不是关闭连接，而是交给连接池）</p><p>》整个程序退出时，断开所有连接，释放资源（即：管理数据库连接池的那个线程被杀死后才关闭所有的连接）</p><p><img src="/2017/1151/e5563f4.png" alt=""></p><h3 id="5-3-数据库连接池的编程步骤"><a href="#5-3-数据库连接池的编程步骤" class="headerlink" title="　　5.3 数据库连接池的编程步骤"></a>　　5.3 数据库连接池的编程步骤</h3><h4 id="5-3-1-导包"><a href="#5-3-1-导包" class="headerlink" title="　　　　5.3.1 导包"></a>　　　　5.3.1 导包</h4><p><img src="/2017/1151/d7c1f3b.png" alt=""></p><h4 id="5-3-2-声明ThreadLocal、BasicDataSource成员变量（注意：这两个成员变量是静态的）"><a href="#5-3-2-声明ThreadLocal、BasicDataSource成员变量（注意：这两个成员变量是静态的）" class="headerlink" title="　　　　5.3.2 声明ThreadLocal、BasicDataSource成员变量（注意：这两个成员变量是静态的）"></a>　　　　5.3.2 声明ThreadLocal、BasicDataSource成员变量（注意：这两个成员变量是静态的）</h4><p><img src="/2017/1151/50cb78f.png" alt=""></p><h4 id="5-3-3-在静态代码块中实例化那两个成员变量，并通过Properties对象读取配置文件信息，利用这些配置文件信息给BasicDataSource对象进行初始化处理"><a href="#5-3-3-在静态代码块中实例化那两个成员变量，并通过Properties对象读取配置文件信息，利用这些配置文件信息给BasicDataSource对象进行初始化处理" class="headerlink" title="　　　　5.3.3 在静态代码块中实例化那两个成员变量，并通过Properties对象读取配置文件信息，利用这些配置文件信息给BasicDataSource对象进行初始化处理"></a>　　　　5.3.3 在静态代码块中实例化那两个成员变量，并通过Properties对象读取配置文件信息，利用这些配置文件信息给BasicDataSource对象进行初始化处理</h4><p><img src="/2017/1151/de847d3.png" alt=""></p><h4 id="5-3-4-编写创建连接静态方法"><a href="#5-3-4-编写创建连接静态方法" class="headerlink" title="　　　　5.3.4 编写创建连接静态方法"></a>　　　　5.3.4 编写创建连接静态方法</h4><p>利用BasicDataSource对象实例化一个连接对象</p><p>将这个连接对象放到ThreadLocal对象中</p><p><img src="/2017/1151/68badca.png" alt=""></p><h4 id="5-3-5-编写释放连接静态方法"><a href="#5-3-5-编写释放连接静态方法" class="headerlink" title="　　　　5.3.5 编写释放连接静态方法"></a>　　　　5.3.5 编写释放连接静态方法</h4><p>从ThreadLocal对象中获取连接对象</p><p>清空ThreadLocal对象</p><p>判断连接对象是否释放</p><p><img src="/2017/1151/db6cb45.png" alt=""></p><h2 id="6-利用数据库连接池操作数据库"><a href="#6-利用数据库连接池操作数据库" class="headerlink" title="6 利用数据库连接池操作数据库"></a>6 利用数据库连接池操作数据库</h2><p>项目结构图</p><p><img src="/2017/1151/fa88dfe.png" alt=""><br><img src="/2017/1151/fa7695b.gif" alt=""><img src="/wp-content/uploads/2017/07/14994283631.gif" alt=""><br>1# zhe shi zhu shi , yi ban bu yong zhong wen<br>2# deng hao liang bian mei you kong ge, mo wei mei you fen hao<br>3# hou mian bu neng you kong ge<br>4driverClassName=com.mysql.jdbc.Driver<br>5url=jdbc:mysql://localhost:3306/test<br>6username=root<br>7password=182838<br>8maxActive=100<br>9 maxWait=3000</p><p>properties配置文件<img src="/2017/1151/fa7695b.gif" alt=""><img src="/wp-content/uploads/2017/07/14994283631.gif" alt=""><br>1<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">2<modelversion>4.0.0</modelversion>3<groupid>cn.xiangxu</groupid>4<artifactid>testJDBC</artifactid>5<version>0.0.1-SNAPSHOT</version>6<dependencies>7<dependency>8<groupid>mysql</groupid>9<artifactid>mysql-connector-java</artifactid>10<version>5.1.37</version>11</dependency>12<dependency>13<groupid>junit</groupid>14<artifactid>junit</artifactid>15<version>4.12</version>16</dependency>17<dependency>18<groupid>commons-dbcp</groupid>19<artifactid>commons-dbcp</artifactid>20<version>1.4</version>21</dependency>22</dependencies>23</project></p><p>maven依赖文件<img src="/2017/1151/fa7695b.gif" alt=""><img src="/wp-content/uploads/2017/07/14994283631.gif" alt=""><br>1package cn.xiangxu.tools;<br>2 3import java.io.IOException;<br>4import java.io.InputStream;<br>5import java.sql.Connection;<br>6import java.sql.SQLException;<br>7import java.util.Properties;<br>8 9import org.apache.commons.dbcp.BasicDataSource;<br>1011publicclass DBUtil {<br>12/<em>13 </em>ThreadLocal用于线程跨方法共享数据使用<br>14 <em>ThreadLocal内部有一个Map, key为需要共享数据的线程本身,value就是其需要共享的数据<br>15</em>/16privatestatic ThreadLocal<connection>tl; // 声明一个类似于仓库的东西17privatestatic BasicDataSource dataSource; // 声明一个数据库连接池对象<br>1819// 静态代码块，在类加载的时候执行，而且只执行一次20static {<br>21 tl = new ThreadLocal<connection>(); // 实例化仓库对象22 dataSource = new BasicDataSource(); // 实例数据库连接池对象2324 Properties prop = new Properties(); // 创建一个Properties对象用（该对象可以用来加载配置文件中的属性列表）25 InputStream is = DBUtil.class.getClassLoader().getResourceAsStream(“config/mysql.properties”); // 读取配置文件信息26try {<br>27 prop.load(is); // 加载配置文件中的属性列表2829 String driverClassName = prop.getProperty(“driverClassName”); // 获取属性信息30 String url = prop.getProperty(“url”);<br>31 String username = prop.getProperty(“username”);<br>32 String password = prop.getProperty(“password”);<br>33 Integer maxActive = Integer.parseInt(prop.getProperty(“maxActive”));<br>34 Integer maxWait = Integer.parseInt(prop.getProperty(“maxWait”));<br>3536 dataSource.setDriverClassName(driverClassName); // 初始化数据库连接池（即：配置数据库连接池的先关参数）37 dataSource.setUrl(url);<br>38 dataSource.setUsername(username);<br>39 dataSource.setPassword(password);<br>40 dataSource.setMaxActive(maxActive);<br>41 dataSource.setMaxWait(maxWait);<br>4243 is.close(); // 关闭输入流，释放资源44 } catch (IOException e) {<br>45// TODO Auto-generated catch block46 e.printStackTrace();<br>47 }<br>4849 }<br>5051/<strong>52 <em>创建连接对象（注意：静态方法可以直接通过类名来调用）<br>53 </em>@return 连接对象<br>54 <em>@throws Exception<br>55</em>/56publicstatic Connection getConnection() throws Exception {<br>57try {<br>58 Connection conn = dataSource.getConnection(); // 创建连接对象（利用数据库连接池进行创建）59 tl.set(conn); // 将连接对象放到仓库中60return conn;<br>61 } catch (Exception e) {<br>62// TODO Auto-generated catch block63 e.printStackTrace();<br>64throw e;<br>65 }<br>66 }<br>6768/</strong>69 <em>关闭连接对象（注意：静态方法可以通过类名直接调用）<br>70 </em>@throws Exception<br>71*/72publicstaticvoid closeConnection() throws Exception {<br>73 Connection conn = tl.get(); // 从仓库中取出连接对象74 tl.remove(); // 清空仓库75if(conn != null) { // 判断连接对象是否释放资源76try {<br>77 conn.close();<br>78 } catch (Exception e) {<br>79// TODO Auto-generated catch block80 e.printStackTrace();<br>81throw e;<br>82 }<br>83 }<br>84 }<br>8586 }</connection></connection></p><p>数据库连接池类<img src="/2017/1151/fa7695b.gif" alt=""><img src="/wp-content/uploads/2017/07/14994283631.gif" alt=""><br>1package testJDBC;<br>2 3import java.sql.Connection;<br>4import java.sql.PreparedStatement;<br>5import java.sql.ResultSet;<br>6 7import org.junit.Test;<br>8 9import cn.xiangxu.tools.DBUtil;<br>1011publicclass TestDBUtil {<br>12 @Test<br>13publicvoid test01() {<br>14try {<br>15 Connection conn = DBUtil.getConnection(); // 创建连接对象16 String sql = “SELECT * FROM user “; // 拼接SQL语句17 PreparedStatement ps = conn.prepareStatement(sql); // 创建执行对象18 ResultSet rs = ps.executeQuery(sql); // 执行SQL语句19while(rs.next()) { // 遍历结果集20 System.out.println(rs.getString(“name”));<br>21 }<br>22 } catch (Exception e) {<br>23 e.printStackTrace();<br>24 } finally { // 关闭连接，释放资源25try {<br>26 DBUtil.closeConnection();<br>27 } catch (Exception e) {<br>28 e.printStackTrace();<br>29 }<br>30 }<br>31 }<br>32 }</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/自制字幕遮挡器未完成.html" rel="next" title="自制字幕遮挡器（未完成）"><i class="fa fa-chevron-left"></i> 自制字幕遮挡器（未完成）</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/动态代理案例1运用proxy动态代理来增强方法.html" rel="prev" title="动态代理案例1:运用Proxy动态代理来增强方法">动态代理案例1:运用Proxy动态代理来增强方法 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-使用Statement执行含有动态信息的SQL语句时有几个不足"><span class="nav-number">1.</span> <span class="nav-text">1 使用Statement执行含有动态信息的SQL语句时有几个不足:</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-由于需要将动态数据拼接到SQL语句中-这导致程序复杂度高-容易出错"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 由于需要将动态数据拼接到SQL语句中,这导致程序复杂度高,容易出错</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-使用Statement执行SQL语句不好的原因"><span class="nav-number">2.</span> <span class="nav-text">2 使用Statement执行SQL语句不好的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-当执行一条SQL语句发送到数据库时-数据库先将该SQL解析并生成一个执行计划-这个过程会消耗资源和性能-，如果多次执行一样的SQL语句-数据库会重用执行计划-但是若多次执行语义相同但是含有动态数据的SQL时-数据库会生成不同的执行计划-严重影响数据库的开销"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 当执行一条SQL语句发送到数据库时,数据库先将该SQL解析并生成一个执行计划(这个过程会消耗资源和性能)，如果多次执行一样的SQL语句,数据库会重用执行计划,但是若多次执行语义相同但是含有动态数据的SQL时,数据库会生成不同的执行计划,严重影响数据库的开销</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-利用PreparedStatement代替Statement"><span class="nav-number">3.</span> <span class="nav-text">3 利用PreparedStatement代替Statement</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编写简单"><span class="nav-number">3.1.</span> <span class="nav-text">编写简单</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#没有SQL注入问题"><span class="nav-number">3.2.</span> <span class="nav-text">没有SQL注入问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#批量执行语义相同的SQL语句会重用执行计划"><span class="nav-number">3.3.</span> <span class="nav-text">批量执行语义相同的SQL语句会重用执行计划</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-利用Properties对象读取properties配置文件中的信息"><span class="nav-number">4.</span> <span class="nav-text">4 利用Properties对象读取properties配置文件中的信息</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Properties继承了Hashtable类，Properties对象也是使用键值对的方式来保存数据，但是Properties对象的键和值都是字符串类型"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 Properties继承了Hashtable类，Properties对象也是使用键值对的方式来保存数据，但是Properties对象的键和值都是字符串类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Properties-类中的主要方法"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 Properties 类中的主要方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1-public-synchronized-void-load-InputStream-inStream-throws-IOException"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 public synchronized void load(InputStream inStream) throws IOException</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2-public-void-store-OutputStream-out-String-comments-throws-IOException"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 public void store(OutputStream out, String comments) throws IOException</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3-public-String-getProperty-String-key"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3 public String getProperty(String key)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-public-synchronized-Object-setProperty-String-key-String-value"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4 public synchronized Object setProperty(String key, String value)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-案例"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-数据库连接池"><span class="nav-number">5.</span> <span class="nav-text">5 数据库连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-什么是数据库连接池"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 什么是数据库连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-数据库连接池的运行机制"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 数据库连接池的运行机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-数据库连接池的编程步骤"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 数据库连接池的编程步骤</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-导包"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 导包</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-声明ThreadLocal、BasicDataSource成员变量（注意：这两个成员变量是静态的）"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 声明ThreadLocal、BasicDataSource成员变量（注意：这两个成员变量是静态的）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3-在静态代码块中实例化那两个成员变量，并通过Properties对象读取配置文件信息，利用这些配置文件信息给BasicDataSource对象进行初始化处理"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 在静态代码块中实例化那两个成员变量，并通过Properties对象读取配置文件信息，利用这些配置文件信息给BasicDataSource对象进行初始化处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4-编写创建连接静态方法"><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4 编写创建连接静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-5-编写释放连接静态方法"><span class="nav-number">5.3.5.</span> <span class="nav-text">5.3.5 编写释放连接静态方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-利用数据库连接池操作数据库"><span class="nav-number">6.</span> <span class="nav-text">6 利用数据库连接池操作数据库</span></a></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->