<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>netty 简单Inbound信道处理器（SimpleChannelInboundHandler） | Java面试</title>
<meta name="generator" content="Jekyll v3.8.4" />
<meta property="og:title" content="netty 简单Inbound信道处理器（SimpleChannelInboundHandler）" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="Netty 通道处理器ChannelHandler和适配器定义ChannelHandlerAdapter： http://donald-draper.iteye.com/blog/2386891Netty Inbound/Outbound通道处理器定义： http://donald-draper.iteye.com/blog/2387019引言： 前面一篇文章我们看了Inbound/Outbound通道处理器定义先来回顾一下先： 通道Inbound处理器，主要是处理从peer发送过来的字节流；通道处理器上下文关联的通道注册到事件循环EventLoop时，触发channelRegistered方法；通道处理器上下文关联的通道激活时，触发channelActive方法；通道从peer读取消息时，触发channelRead方法；当上一消息通过#channelRead方法，并被当先读操作消费时，触发channelReadComplete方法，如果通道配置项 #AUTO_READ为关闭状态，没有进一步尝试从当前通道读取inbound数据时，直到ChannelHandlerContext#read调用，触发；当用户事件发生时，触发userEventTriggered方法；异常抛出时，触发exceptionCaught方法；当通道可写状态改变时，触发channelWritabilityChanged方法；通道处理器上下文关联的通道注册到事件循环EventLoop，但处于非激活状态，达到生命周期的末端时，触发channelInactive方法；通道处理器上下文关联的通道从事件循环EventLoop移除时，触发channelUnregistered方法。 Inbound通道handler适配器ChannelInboundHandlerAdapter，提供的Inbound通道处理器的所有方法的实现，但实现仅仅是，转发操作给Channel管道线的下一个通道处理器，子类必须重写方法。需要注意的是，在#channelRead方法自动返回后，消息并没有释放。如果你寻找ChannelInboundHandler的实现，可以自动释放接受的到消息可以使用SimpleChannelInboundHandler。 Outbound通道处理器ChannelOutboundHandler主要处理outbound IO操作。当绑定操作发生时，调用bind方法；当连接操作发生时，调用connect方法；read方法拦截通道处理器上下文读操作；当写操发生时，调用write方法，写操作通过Channel管道线写消息，当通道调用#flush方法时，消息将会被刷新，发送出去；当一个刷新操作发生时，调用flush方法，刷新操作将会刷新所有先前已经写，待发送的消息。 Outbound通道Handler适配器ChannelOutboundHandlerAdapter为Outbound通道处理器的基本实现，这个实现仅仅通过通道处理器上下文转发方法的调用。 子类必须重写Outbound通道Handler适配器的相关方法。 在Mina中，通道读写全部在一个通道Handler，Mina提供的通道Handler适配器，我们在使用通道处理器时继承它，实现我们需要关注的读写事件。而Netty使用InBound和OutBound将通道的读写分离，同时提供了InBound和OutBound通道Handler的适配器。 今天来看一下SimpleChannelInboundHandler： package io.netty.channel; import io.netty.util.ReferenceCountUtil; import io.netty.util.internal.TypeParameterMatcher; /** * {@link ChannelInboundHandlerAdapter} which allows to explicit only handle a specific type of messages. *简单Inbound通道处理器SimpleChannelInboundHandler，允许明确处理一种特殊类型的消息。 * For example here is an implementation which only handle {@link String} messages. *下面是一个处理String类型数据Inbound通道处理器实现 * &lt;pre&gt; * public class StringHandler extends * {@link SimpleChannelInboundHandler}&lt;{@link String}&gt; { * * {@code @Override} * protected void channelRead0({@link ChannelHandlerContext} ctx, {@link String} message) * throws {@link Exception} { * System.out.println(message); * } * } * &lt;/pre&gt; * * Be aware that depending of the constructor parameters it will release all handled messages by passing them to * {@link ReferenceCountUtil#release(Object)}. In this case you may need to use * {@link ReferenceCountUtil#retain(Object)} if you pass the object to the next handler in the {@link ChannelPipeline}. *需要注意的是，是否通过转递消息给ReferenceCountUtil#release方法，释放处理过的消息，依赖于构造参数autoRelease（boolean）。 如果你需要将消息传递给Channle管道线的下一个通道处理器，你需要调用ReferenceCountUtil#retain(Object)方法； * &lt;h3&gt;Forward compatibility notice&lt;/h3&gt; * 转发兼容性提醒 * Please keep in mind that {@link #channelRead0(ChannelHandlerContext, I)} will be renamed to * {@code messageReceived(ChannelHandlerContext, I)} in 5.0. * 请注意：#channelRead0方法在Netty5，中将被命名为消息messageReceived。 */ public abstract class SimpleChannelInboundHandler&lt;I&gt; extends ChannelInboundHandlerAdapter { private final TypeParameterMatcher matcher;//类型参数匹配器 private final boolean autoRelease;//是否自动释放 /** * see {@link #SimpleChannelInboundHandler(boolean)} with {@code true} as boolean parameter. 默认自动释放处理过的消息 */ protected SimpleChannelInboundHandler() { this(true); } /** * Create a new instance which will try to detect the types to match out of the type parameter of the class. *创建一个实例，尝试探测接受消息类型与SimpleChannelInboundHandler的I的类型是否相同。 * @param autoRelease {@code true} if handled messages should be released automatically by passing them to * {@link ReferenceCountUtil#release(Object)}. 是否通过ReferenceCountUtil#release方法释放消息 */ protected SimpleChannelInboundHandler(boolean autoRelease) { matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, &quot;I&quot;); this.autoRelease = autoRelease; } /** * see {@link #SimpleChannelInboundHandler(Class, boolean)} with {@code true} as boolean value. */ protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType) { this(inboundMessageType, true); } /** * Create a new instance * * @param inboundMessageType The type of messages to match * @param autoRelease {@code true} if handled messages should be released automatically by passing them to * {@link ReferenceCountUtil#release(Object)}. */ protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType, boolean autoRelease) { matcher = TypeParameterMatcher.get(inboundMessageType); this.autoRelease = autoRelease; } /** * Returns {@code true} if the given message should be handled. If {@code false} it will be passed to the next * {@link ChannelInboundHandler} in the {@link ChannelPipeline}. 判断跟定的消息类型是否可以被处理，如果返回false，则将消息转递给Channel管道线的下一个通道处理器 */ public boolean acceptInboundMessage(Object msg) throws Exception { return matcher.match(msg); } //读取消息对象 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { boolean release = true; try { if (acceptInboundMessage(msg)) { @SuppressWarnings(&quot;unchecked&quot;) I imsg = (I) msg; //如果消息属于本Handler可以处理的消息类型，则委托给channelRead0 channelRead0(ctx, imsg); } else { release = false; //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); } } finally { if (autoRelease &amp;&amp; release) { //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); } } } /** * [b]Please keep in mind that this method will be renamed to * {@code messageReceived(ChannelHandlerContext, I)} in 5.0.[/b] *注意此方法在5.0以后将命名为messageReceived * Is called for each message of type {@link I}. * * @param ctx the {@link ChannelHandlerContext} which this {@link SimpleChannelInboundHandler} * belongs to * @param msg the message to handle * @throws Exception is thrown if an error occurred */ protected abstract void channelRead0(ChannelHandlerContext ctx, I msg) throws Exception; } 来看读取消息对象方法： //读取消息对象 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { boolean release = true; try { if (acceptInboundMessage(msg)) { @SuppressWarnings(&quot;unchecked&quot;) I imsg = (I) msg; //如果消息属于本Handler可以处理的消息类型，则委托给channelRead0 channelRead0(ctx, imsg); } else { release = false; //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); } } finally { if (autoRelease &amp;&amp; release) { //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); } } } 其中有两点需要关注： //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); //ChannelHandlerContext public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker { @Override ChannelHandlerContext fireChannelRead(Object msg); } //ChannelInboundInvoker /** * A {@link Channel} received a message. *通道接收一个消息 * This will result in having the {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)} * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the * {@link Channel}. ChannelInboundHandler#channelRead方法调用将会通知，通道所在的Channel管道线中的下一个通道处理器，接受一个消息 */ ChannelInboundInvoker fireChannelRead(Object msg); //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); //ReferenceCountUtil /** * Try to call {@link ReferenceCounted#release()} if the specified message implements {@link ReferenceCounted}. * If the specified message doesn’t implement {@link ReferenceCounted}, this method does nothing. 如果消息实现了ReferenceCounted，则调用ReferenceCounted#release()，如果不是什么都不做 */ public static boolean release(Object msg) { if (msg instanceof ReferenceCounted) { return ((ReferenceCounted) msg).release(); } return false; } //ReferenceCounted /** * Decreases the reference count by {@code 1} and deallocates this object if the reference count reaches at * {@code 0}. *自减引用计数器，如果计数器为0，则回收对象。 * @return {@code true} if and only if the reference count became {@code 0} and this object has been deallocated */ boolean release(); 从上面来看，读操作，首先判断跟定的消息类型是否可以被处理，如果是，则委托给channelRead0，如果返回false，则将消息转递给Channel管道线的下一个通道处理器；最后，如果autoRelease为自动释放消息，且消息已处理则释放消息。 在简单Inbound通道处理器的构造方法： protected SimpleChannelInboundHandler(boolean autoRelease) { matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, &quot;I&quot;); this.autoRelease = autoRelease; } protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType, boolean autoRelease) { matcher = TypeParameterMatcher.get(inboundMessageType); this.autoRelease = autoRelease; } 和acceptInboundMessage方法中 //判断跟定的消息类型是否可以被处理，如果返回false，则将消息转递给Channel管道线的下一个通道处理器 public boolean acceptInboundMessage(Object msg) throws Exception { return matcher.match(msg); } 涉及到一个参数类型匹配器TypeParameterMatcher，为了理解TypeParameterMatcher花了几天时间， 学习了一下java Type体系结构，在往下看之前，需要了解java Type体系结构，具体可以参考一下连接: Type —— Java类型: http://blog.csdn.net/a327369238/article/details/52621043详解Java泛型type体系整理: http://developer.51cto.com/art/201103/250028.htm 黑马程序员–Java基础加强–13.利用反射操作泛型II【TypeVariable】【GenericArrayType】【WildcardType】【Type及其子接口的来历】【个人总结】 http://blog.csdn.net/benjaminzhang666/article/details/9839007泛型通配符extends与super的区别: http://www.cnblogs.com/yepei/p/6591289.html另外附上java Type体系结构的示例地址： https://github.com/Donaldhan/java-base-demo 本身这篇文章应该上个星期就出来呢？由于对java Type体系结构不熟，难以理解参数类型匹配器TypeParameterMatcher，所以推迟到现在，本身同时想写一篇java Type体系结构相关的文章，后来一想算了，网上很多资料，再加上自己写Demo里面有相关的说明，就不写了，一个字懒…… 言归正传，下面我们来看TypeParameterMatcher package io.netty.util.internal; import java.lang.reflect.Array; import java.lang.reflect.GenericArrayType; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; import java.util.HashMap; import java.util.Map; public abstract class TypeParameterMatcher { //默认空参数类型匹配器，匹配方法永远返回true private static final TypeParameterMatcher NOOP = new TypeParameterMatcher() { @Override public boolean match(Object msg) { return true; } }; //判断消息对象类型是否匹配当前类型匹配器 public abstract boolean match(Object msg); //反射匹配器 private static final class ReflectiveMatcher extends TypeParameterMatcher { private final Class&lt;?&gt; type; ReflectiveMatcher(Class&lt;?&gt; type) { this.type = type; } //根据对象是为类型Type的实例，来判断是否消息是否匹配 @Override public boolean match(Object msg) { return type.isInstance(msg); } } TypeParameterMatcher() { } //根据Class类型获取类型参数匹配器 public static TypeParameterMatcher get(final Class&lt;?&gt; parameterType) { //从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存 final Map&lt;Class&lt;?&gt;, TypeParameterMatcher&gt; getCache = InternalThreadLocalMap.get().typeParameterMatcherGetCache(); //从类型参数匹配器缓存，获取类型parameterType对应的类型参数匹配器 TypeParameterMatcher matcher = getCache.get(parameterType); if (matcher == null) {//如果匹配器为空 if (parameterType == Object.class) {匹配参数为Object，匹配器为NOOP matcher = NOOP; } else { matcher = new ReflectiveMatcher(parameterType); } getCache.put(parameterType, matcher); } return matcher; } //跟实例object，类型父类parametrizedSuperclass，类型参数名typeParamName，获取类型参数名object对应的类型参数匹配器 public static TypeParameterMatcher find( final Object object, final Class&lt;?&gt; parametrizedSuperclass, final String typeParamName) { //从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存 final Map&lt;Class&lt;?&gt;, Map&lt;String, TypeParameterMatcher&gt;&gt; findCache = InternalThreadLocalMap.get().typeParameterMatcherFindCache(); //获取object类型 final Class&lt;?&gt; thisClass = object.getClass(); //从类型参数匹配器缓存，获取类型thisClass对应的类型参数匹配器映射关系 Map&lt;String, TypeParameterMatcher&gt; map = findCache.get(thisClass); if (map == null) { //如果不存在object类型对应的类型参数匹配器映射关系，则创建，并添加到缓存中 map = new HashMap&lt;String, TypeParameterMatcher&gt;(); findCache.put(thisClass, map); } //从object类型对应的类型参数匹配器Map中获取，对应的类型参数匹配器 TypeParameterMatcher matcher = map.get(typeParamName); if (matcher == null) { //如果object对应的类型参数匹配器为空，则从父类中获取类型参数名对应的类型的参数匹配器 matcher = get(find0(object, parametrizedSuperclass, typeParamName)); //类型参数名和类型参数匹配器，添加到对应的映射Map中 map.put(typeParamName, matcher); } return matcher; } //获取obejct实际类型父类parametrizedSuperclass泛型参数中，类型参数名为typeParamName对应的原始类型 private static Class&lt;?&gt; find0( final Object object, Class&lt;?&gt; parametrizedSuperclass, String typeParamName) { //获取object的类型 final Class&lt;?&gt; thisClass = object.getClass(); Class&lt;?&gt; currentClass = thisClass; for (;;) { if (currentClass.getSuperclass() == parametrizedSuperclass) {//如果当前类型父类为parametrizedSuperclass int typeParamIndex = -1; //获取当前类父类的泛型类型变量 TypeVariable&lt;?&gt;[] typeParams = currentClass.getSuperclass().getTypeParameters(); for (int i = 0; i &lt; typeParams.length; i ++) { //寻找类型参数名对应的类型变量，如果找到，则记录类型变量索引位置 if (typeParamName.equals(typeParams[i].getName())) { typeParamIndex = i; break; } } //如果索引为位置小于0，即，在object类型父类的类型变量中没有找到typeParamName对应的类型变量 if (typeParamIndex &lt; 0) { throw new IllegalStateException( &quot;unknown type parameter &#39;&quot; + typeParamName + &quot;&#39;: &quot; + parametrizedSuperclass); } //获取当前类的父类泛型类型 Type genericSuperType = currentClass.getGenericSuperclass(); if (!(genericSuperType instanceof ParameterizedType)) { //如果父类的泛型类型非参数化类型，则返回Object类型 return Object.class; } //获取父类的实际类型参数 Type[] actualTypeParams = ((ParameterizedType) genericSuperType).getActualTypeArguments(); Type actualTypeParam = actualTypeParams[typeParamIndex]; if (actualTypeParam instanceof ParameterizedType) { //如果实际类型参数为参数化类型，则获取实际类型参数的原始类型RawType（不包括泛型部分） actualTypeParam = ((ParameterizedType) actualTypeParam).getRawType(); } if (actualTypeParam instanceof Class) { //如果实际类型为Class，则直接返回Class return (Class&lt;?&gt;) actualTypeParam; } if (actualTypeParam instanceof GenericArrayType) { //如果实际类型参数为泛型数组类型，获取泛型数组类型的泛型组件类型GenericComponentType Type componentType = ((GenericArrayType) actualTypeParam).getGenericComponentType(); if (componentType instanceof ParameterizedType) { 如果组件类型为参数化类型，则组件类型为原始类型RawType componentType = ((ParameterizedType) componentType).getRawType(); } if (componentType instanceof Class) { //如果组件类型为Class，则创建对应的数组实例，并获取实例的类型 return Array.newInstance((Class&lt;?&gt;) componentType, 0).getClass(); } } if (actualTypeParam instanceof TypeVariable) { //如果实际类型参数为类型变量，转化实际类型参数为类型变量 // Resolved type parameter points to another type parameter. TypeVariable&lt;?&gt; v = (TypeVariable&lt;?&gt;) actualTypeParam; currentClass = thisClass; if (!(v.getGenericDeclaration() instanceof Class)) { //如果类型变量的声明类不是Class，则返回Object类型 return Object.class; } //参数化父类的类型为，类型变量v的声明类 parametrizedSuperclass = (Class&lt;?&gt;) v.getGenericDeclaration(); //获取类型变量名称 typeParamName = v.getName(); if (parametrizedSuperclass.isAssignableFrom(thisClass)) { //如果参数类型父类为thisClass类型，则跳出当前循环 continue; } else { //否则返回Object类型 return Object.class; } } return fail(thisClass, typeParamName); } //否则获取当前类型的父类 currentClass = currentClass.getSuperclass(); if (currentClass == null) { return fail(thisClass, typeParamName); } } } //找不到类型参数名对应的类型，则抛出非法状态异常 private static Class&lt;?&gt; fail(Class&lt;?&gt; type, String typeParamName) { throw new IllegalStateException( &quot;cannot determine the type of the type parameter &#39;&quot; + typeParamName + &quot;&#39;: &quot; + type); } } 这个类型参数匹配器就不说了，各种变量的叫法，容易搞混，要结合代码注释看。 简单小节一下： 类型参数匹配器，作用主要主要是判断实例的类型是否为类型参数匹配器对应类型的实例，是则返回ture，否返回false。主要是用于，当通道读取消息对象时，判断通道是不可以处理此消息对象。 get方法：根据Class类型获取类型参数匹配器，首先从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存，从类型参数匹配器缓存，获取参数类型parameterType对应的类型参数匹配器，如果匹配器为空且匹配参数为Object，则匹配器为NOOP，否则，根据参数类型创建ReflectiveMatcher添加到缓存中。 find方法：跟实例object，类型父类parametrizedSuperclass，类型参数名typeParamName， 获取类型参数名object对应的类型参数匹配器，首先从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存，从类型参数匹配器缓存，获取objec类型thisClass对应的类型参数匹配器映射关系，如果不存在object类型对应的类型参数匹配器映射关系，则创建，并添加到缓存中，否则，从object类型对应的类型参数匹配器Map中获取，对应的类型参数匹配器，如果object对应的类型参数匹配器为空，则从父类中获取类型参数名对应的类型的参数匹配器（find0方法获取类型参数名对应的原始类），并将类型与从父类中获取匹配器映射关系，添加到缓存中，否则直接返回匹配器。 find0方法：获取obejct实际类型父类parametrizedSuperclass泛型参数中，类型参数名为typeParamName对应的原始类型过程为，首先获取object的类型currentClass，如果当前类型currentClass的父类为parametrizedSuperclass，获取当前类父类的泛型类型变量，寻找类型参数名对应的类型变量，如果找到，则记录类型变量索引位置，如果索引为位置小于0，即，在object类型父类的类型变量中没有找到typeParamName对应的类型变量，否则，获取当前类的父类泛型类型，如果父类的泛型类型非参数化类型，则返回Object类型，否则，获取父类的实际类型参数，如果实际类型参数为参数化类型，则获取索引对应实际类型参数的原始类型RawType， 如果实际类型为Class，则直接返回Class，如果实际类型参数为泛型数组类型，获取泛型数组类型的泛型组件类型GenericComponentType，如果组件类型为参数化类型，则组件类型为原始类型RawType，如果组件类型为Class，则创建对应的数组实例，并获取实例的类型，如果实际类型参数为类型变量，转化实际类型参数为类型变量v，如果类型变量的声明类不是Class，则返回Object类型，否则设置参数化父类的类型为类型变量v的声明类，如果参数类型父类为thisClass类型，则跳出当前循环，否则返回Object类型，这时，当前类型currentClass的父类为parametrizedSuperclas的情况结束；如果父类不为parametrizedSuperclas，则获取currentClass父类，并设置为当前类继续自旋。自旋的目的是，找到与parametrizedSuperclas类型相等的object类型或父类型。 ** 总结：**简单Inbound通道处理器SimpleChannelInboundHandler，内部有连个变量一个为参数类型匹配器，用来判断通道是否可以处理消息，另一个变量autoRelease，用于控制是否在通道处理消息完毕时，释放消息。读取方法channelRead，首先判断跟定的消息类型是否可以被处理，如果是，则委托给channelRead0，channelRead0待子类实现；如果返回false，则将消息转递给Channel管道线的下一个通道处理器；最后，如果autoRelease为自动释放消息，且消息已处理则释放消息。" />
<meta property="og:description" content="Netty 通道处理器ChannelHandler和适配器定义ChannelHandlerAdapter： http://donald-draper.iteye.com/blog/2386891Netty Inbound/Outbound通道处理器定义： http://donald-draper.iteye.com/blog/2387019引言： 前面一篇文章我们看了Inbound/Outbound通道处理器定义先来回顾一下先： 通道Inbound处理器，主要是处理从peer发送过来的字节流；通道处理器上下文关联的通道注册到事件循环EventLoop时，触发channelRegistered方法；通道处理器上下文关联的通道激活时，触发channelActive方法；通道从peer读取消息时，触发channelRead方法；当上一消息通过#channelRead方法，并被当先读操作消费时，触发channelReadComplete方法，如果通道配置项 #AUTO_READ为关闭状态，没有进一步尝试从当前通道读取inbound数据时，直到ChannelHandlerContext#read调用，触发；当用户事件发生时，触发userEventTriggered方法；异常抛出时，触发exceptionCaught方法；当通道可写状态改变时，触发channelWritabilityChanged方法；通道处理器上下文关联的通道注册到事件循环EventLoop，但处于非激活状态，达到生命周期的末端时，触发channelInactive方法；通道处理器上下文关联的通道从事件循环EventLoop移除时，触发channelUnregistered方法。 Inbound通道handler适配器ChannelInboundHandlerAdapter，提供的Inbound通道处理器的所有方法的实现，但实现仅仅是，转发操作给Channel管道线的下一个通道处理器，子类必须重写方法。需要注意的是，在#channelRead方法自动返回后，消息并没有释放。如果你寻找ChannelInboundHandler的实现，可以自动释放接受的到消息可以使用SimpleChannelInboundHandler。 Outbound通道处理器ChannelOutboundHandler主要处理outbound IO操作。当绑定操作发生时，调用bind方法；当连接操作发生时，调用connect方法；read方法拦截通道处理器上下文读操作；当写操发生时，调用write方法，写操作通过Channel管道线写消息，当通道调用#flush方法时，消息将会被刷新，发送出去；当一个刷新操作发生时，调用flush方法，刷新操作将会刷新所有先前已经写，待发送的消息。 Outbound通道Handler适配器ChannelOutboundHandlerAdapter为Outbound通道处理器的基本实现，这个实现仅仅通过通道处理器上下文转发方法的调用。 子类必须重写Outbound通道Handler适配器的相关方法。 在Mina中，通道读写全部在一个通道Handler，Mina提供的通道Handler适配器，我们在使用通道处理器时继承它，实现我们需要关注的读写事件。而Netty使用InBound和OutBound将通道的读写分离，同时提供了InBound和OutBound通道Handler的适配器。 今天来看一下SimpleChannelInboundHandler： package io.netty.channel; import io.netty.util.ReferenceCountUtil; import io.netty.util.internal.TypeParameterMatcher; /** * {@link ChannelInboundHandlerAdapter} which allows to explicit only handle a specific type of messages. *简单Inbound通道处理器SimpleChannelInboundHandler，允许明确处理一种特殊类型的消息。 * For example here is an implementation which only handle {@link String} messages. *下面是一个处理String类型数据Inbound通道处理器实现 * &lt;pre&gt; * public class StringHandler extends * {@link SimpleChannelInboundHandler}&lt;{@link String}&gt; { * * {@code @Override} * protected void channelRead0({@link ChannelHandlerContext} ctx, {@link String} message) * throws {@link Exception} { * System.out.println(message); * } * } * &lt;/pre&gt; * * Be aware that depending of the constructor parameters it will release all handled messages by passing them to * {@link ReferenceCountUtil#release(Object)}. In this case you may need to use * {@link ReferenceCountUtil#retain(Object)} if you pass the object to the next handler in the {@link ChannelPipeline}. *需要注意的是，是否通过转递消息给ReferenceCountUtil#release方法，释放处理过的消息，依赖于构造参数autoRelease（boolean）。 如果你需要将消息传递给Channle管道线的下一个通道处理器，你需要调用ReferenceCountUtil#retain(Object)方法； * &lt;h3&gt;Forward compatibility notice&lt;/h3&gt; * 转发兼容性提醒 * Please keep in mind that {@link #channelRead0(ChannelHandlerContext, I)} will be renamed to * {@code messageReceived(ChannelHandlerContext, I)} in 5.0. * 请注意：#channelRead0方法在Netty5，中将被命名为消息messageReceived。 */ public abstract class SimpleChannelInboundHandler&lt;I&gt; extends ChannelInboundHandlerAdapter { private final TypeParameterMatcher matcher;//类型参数匹配器 private final boolean autoRelease;//是否自动释放 /** * see {@link #SimpleChannelInboundHandler(boolean)} with {@code true} as boolean parameter. 默认自动释放处理过的消息 */ protected SimpleChannelInboundHandler() { this(true); } /** * Create a new instance which will try to detect the types to match out of the type parameter of the class. *创建一个实例，尝试探测接受消息类型与SimpleChannelInboundHandler的I的类型是否相同。 * @param autoRelease {@code true} if handled messages should be released automatically by passing them to * {@link ReferenceCountUtil#release(Object)}. 是否通过ReferenceCountUtil#release方法释放消息 */ protected SimpleChannelInboundHandler(boolean autoRelease) { matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, &quot;I&quot;); this.autoRelease = autoRelease; } /** * see {@link #SimpleChannelInboundHandler(Class, boolean)} with {@code true} as boolean value. */ protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType) { this(inboundMessageType, true); } /** * Create a new instance * * @param inboundMessageType The type of messages to match * @param autoRelease {@code true} if handled messages should be released automatically by passing them to * {@link ReferenceCountUtil#release(Object)}. */ protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType, boolean autoRelease) { matcher = TypeParameterMatcher.get(inboundMessageType); this.autoRelease = autoRelease; } /** * Returns {@code true} if the given message should be handled. If {@code false} it will be passed to the next * {@link ChannelInboundHandler} in the {@link ChannelPipeline}. 判断跟定的消息类型是否可以被处理，如果返回false，则将消息转递给Channel管道线的下一个通道处理器 */ public boolean acceptInboundMessage(Object msg) throws Exception { return matcher.match(msg); } //读取消息对象 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { boolean release = true; try { if (acceptInboundMessage(msg)) { @SuppressWarnings(&quot;unchecked&quot;) I imsg = (I) msg; //如果消息属于本Handler可以处理的消息类型，则委托给channelRead0 channelRead0(ctx, imsg); } else { release = false; //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); } } finally { if (autoRelease &amp;&amp; release) { //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); } } } /** * [b]Please keep in mind that this method will be renamed to * {@code messageReceived(ChannelHandlerContext, I)} in 5.0.[/b] *注意此方法在5.0以后将命名为messageReceived * Is called for each message of type {@link I}. * * @param ctx the {@link ChannelHandlerContext} which this {@link SimpleChannelInboundHandler} * belongs to * @param msg the message to handle * @throws Exception is thrown if an error occurred */ protected abstract void channelRead0(ChannelHandlerContext ctx, I msg) throws Exception; } 来看读取消息对象方法： //读取消息对象 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { boolean release = true; try { if (acceptInboundMessage(msg)) { @SuppressWarnings(&quot;unchecked&quot;) I imsg = (I) msg; //如果消息属于本Handler可以处理的消息类型，则委托给channelRead0 channelRead0(ctx, imsg); } else { release = false; //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); } } finally { if (autoRelease &amp;&amp; release) { //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); } } } 其中有两点需要关注： //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); //ChannelHandlerContext public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker { @Override ChannelHandlerContext fireChannelRead(Object msg); } //ChannelInboundInvoker /** * A {@link Channel} received a message. *通道接收一个消息 * This will result in having the {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)} * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the * {@link Channel}. ChannelInboundHandler#channelRead方法调用将会通知，通道所在的Channel管道线中的下一个通道处理器，接受一个消息 */ ChannelInboundInvoker fireChannelRead(Object msg); //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); //ReferenceCountUtil /** * Try to call {@link ReferenceCounted#release()} if the specified message implements {@link ReferenceCounted}. * If the specified message doesn’t implement {@link ReferenceCounted}, this method does nothing. 如果消息实现了ReferenceCounted，则调用ReferenceCounted#release()，如果不是什么都不做 */ public static boolean release(Object msg) { if (msg instanceof ReferenceCounted) { return ((ReferenceCounted) msg).release(); } return false; } //ReferenceCounted /** * Decreases the reference count by {@code 1} and deallocates this object if the reference count reaches at * {@code 0}. *自减引用计数器，如果计数器为0，则回收对象。 * @return {@code true} if and only if the reference count became {@code 0} and this object has been deallocated */ boolean release(); 从上面来看，读操作，首先判断跟定的消息类型是否可以被处理，如果是，则委托给channelRead0，如果返回false，则将消息转递给Channel管道线的下一个通道处理器；最后，如果autoRelease为自动释放消息，且消息已处理则释放消息。 在简单Inbound通道处理器的构造方法： protected SimpleChannelInboundHandler(boolean autoRelease) { matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, &quot;I&quot;); this.autoRelease = autoRelease; } protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType, boolean autoRelease) { matcher = TypeParameterMatcher.get(inboundMessageType); this.autoRelease = autoRelease; } 和acceptInboundMessage方法中 //判断跟定的消息类型是否可以被处理，如果返回false，则将消息转递给Channel管道线的下一个通道处理器 public boolean acceptInboundMessage(Object msg) throws Exception { return matcher.match(msg); } 涉及到一个参数类型匹配器TypeParameterMatcher，为了理解TypeParameterMatcher花了几天时间， 学习了一下java Type体系结构，在往下看之前，需要了解java Type体系结构，具体可以参考一下连接: Type —— Java类型: http://blog.csdn.net/a327369238/article/details/52621043详解Java泛型type体系整理: http://developer.51cto.com/art/201103/250028.htm 黑马程序员–Java基础加强–13.利用反射操作泛型II【TypeVariable】【GenericArrayType】【WildcardType】【Type及其子接口的来历】【个人总结】 http://blog.csdn.net/benjaminzhang666/article/details/9839007泛型通配符extends与super的区别: http://www.cnblogs.com/yepei/p/6591289.html另外附上java Type体系结构的示例地址： https://github.com/Donaldhan/java-base-demo 本身这篇文章应该上个星期就出来呢？由于对java Type体系结构不熟，难以理解参数类型匹配器TypeParameterMatcher，所以推迟到现在，本身同时想写一篇java Type体系结构相关的文章，后来一想算了，网上很多资料，再加上自己写Demo里面有相关的说明，就不写了，一个字懒…… 言归正传，下面我们来看TypeParameterMatcher package io.netty.util.internal; import java.lang.reflect.Array; import java.lang.reflect.GenericArrayType; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; import java.util.HashMap; import java.util.Map; public abstract class TypeParameterMatcher { //默认空参数类型匹配器，匹配方法永远返回true private static final TypeParameterMatcher NOOP = new TypeParameterMatcher() { @Override public boolean match(Object msg) { return true; } }; //判断消息对象类型是否匹配当前类型匹配器 public abstract boolean match(Object msg); //反射匹配器 private static final class ReflectiveMatcher extends TypeParameterMatcher { private final Class&lt;?&gt; type; ReflectiveMatcher(Class&lt;?&gt; type) { this.type = type; } //根据对象是为类型Type的实例，来判断是否消息是否匹配 @Override public boolean match(Object msg) { return type.isInstance(msg); } } TypeParameterMatcher() { } //根据Class类型获取类型参数匹配器 public static TypeParameterMatcher get(final Class&lt;?&gt; parameterType) { //从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存 final Map&lt;Class&lt;?&gt;, TypeParameterMatcher&gt; getCache = InternalThreadLocalMap.get().typeParameterMatcherGetCache(); //从类型参数匹配器缓存，获取类型parameterType对应的类型参数匹配器 TypeParameterMatcher matcher = getCache.get(parameterType); if (matcher == null) {//如果匹配器为空 if (parameterType == Object.class) {匹配参数为Object，匹配器为NOOP matcher = NOOP; } else { matcher = new ReflectiveMatcher(parameterType); } getCache.put(parameterType, matcher); } return matcher; } //跟实例object，类型父类parametrizedSuperclass，类型参数名typeParamName，获取类型参数名object对应的类型参数匹配器 public static TypeParameterMatcher find( final Object object, final Class&lt;?&gt; parametrizedSuperclass, final String typeParamName) { //从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存 final Map&lt;Class&lt;?&gt;, Map&lt;String, TypeParameterMatcher&gt;&gt; findCache = InternalThreadLocalMap.get().typeParameterMatcherFindCache(); //获取object类型 final Class&lt;?&gt; thisClass = object.getClass(); //从类型参数匹配器缓存，获取类型thisClass对应的类型参数匹配器映射关系 Map&lt;String, TypeParameterMatcher&gt; map = findCache.get(thisClass); if (map == null) { //如果不存在object类型对应的类型参数匹配器映射关系，则创建，并添加到缓存中 map = new HashMap&lt;String, TypeParameterMatcher&gt;(); findCache.put(thisClass, map); } //从object类型对应的类型参数匹配器Map中获取，对应的类型参数匹配器 TypeParameterMatcher matcher = map.get(typeParamName); if (matcher == null) { //如果object对应的类型参数匹配器为空，则从父类中获取类型参数名对应的类型的参数匹配器 matcher = get(find0(object, parametrizedSuperclass, typeParamName)); //类型参数名和类型参数匹配器，添加到对应的映射Map中 map.put(typeParamName, matcher); } return matcher; } //获取obejct实际类型父类parametrizedSuperclass泛型参数中，类型参数名为typeParamName对应的原始类型 private static Class&lt;?&gt; find0( final Object object, Class&lt;?&gt; parametrizedSuperclass, String typeParamName) { //获取object的类型 final Class&lt;?&gt; thisClass = object.getClass(); Class&lt;?&gt; currentClass = thisClass; for (;;) { if (currentClass.getSuperclass() == parametrizedSuperclass) {//如果当前类型父类为parametrizedSuperclass int typeParamIndex = -1; //获取当前类父类的泛型类型变量 TypeVariable&lt;?&gt;[] typeParams = currentClass.getSuperclass().getTypeParameters(); for (int i = 0; i &lt; typeParams.length; i ++) { //寻找类型参数名对应的类型变量，如果找到，则记录类型变量索引位置 if (typeParamName.equals(typeParams[i].getName())) { typeParamIndex = i; break; } } //如果索引为位置小于0，即，在object类型父类的类型变量中没有找到typeParamName对应的类型变量 if (typeParamIndex &lt; 0) { throw new IllegalStateException( &quot;unknown type parameter &#39;&quot; + typeParamName + &quot;&#39;: &quot; + parametrizedSuperclass); } //获取当前类的父类泛型类型 Type genericSuperType = currentClass.getGenericSuperclass(); if (!(genericSuperType instanceof ParameterizedType)) { //如果父类的泛型类型非参数化类型，则返回Object类型 return Object.class; } //获取父类的实际类型参数 Type[] actualTypeParams = ((ParameterizedType) genericSuperType).getActualTypeArguments(); Type actualTypeParam = actualTypeParams[typeParamIndex]; if (actualTypeParam instanceof ParameterizedType) { //如果实际类型参数为参数化类型，则获取实际类型参数的原始类型RawType（不包括泛型部分） actualTypeParam = ((ParameterizedType) actualTypeParam).getRawType(); } if (actualTypeParam instanceof Class) { //如果实际类型为Class，则直接返回Class return (Class&lt;?&gt;) actualTypeParam; } if (actualTypeParam instanceof GenericArrayType) { //如果实际类型参数为泛型数组类型，获取泛型数组类型的泛型组件类型GenericComponentType Type componentType = ((GenericArrayType) actualTypeParam).getGenericComponentType(); if (componentType instanceof ParameterizedType) { 如果组件类型为参数化类型，则组件类型为原始类型RawType componentType = ((ParameterizedType) componentType).getRawType(); } if (componentType instanceof Class) { //如果组件类型为Class，则创建对应的数组实例，并获取实例的类型 return Array.newInstance((Class&lt;?&gt;) componentType, 0).getClass(); } } if (actualTypeParam instanceof TypeVariable) { //如果实际类型参数为类型变量，转化实际类型参数为类型变量 // Resolved type parameter points to another type parameter. TypeVariable&lt;?&gt; v = (TypeVariable&lt;?&gt;) actualTypeParam; currentClass = thisClass; if (!(v.getGenericDeclaration() instanceof Class)) { //如果类型变量的声明类不是Class，则返回Object类型 return Object.class; } //参数化父类的类型为，类型变量v的声明类 parametrizedSuperclass = (Class&lt;?&gt;) v.getGenericDeclaration(); //获取类型变量名称 typeParamName = v.getName(); if (parametrizedSuperclass.isAssignableFrom(thisClass)) { //如果参数类型父类为thisClass类型，则跳出当前循环 continue; } else { //否则返回Object类型 return Object.class; } } return fail(thisClass, typeParamName); } //否则获取当前类型的父类 currentClass = currentClass.getSuperclass(); if (currentClass == null) { return fail(thisClass, typeParamName); } } } //找不到类型参数名对应的类型，则抛出非法状态异常 private static Class&lt;?&gt; fail(Class&lt;?&gt; type, String typeParamName) { throw new IllegalStateException( &quot;cannot determine the type of the type parameter &#39;&quot; + typeParamName + &quot;&#39;: &quot; + type); } } 这个类型参数匹配器就不说了，各种变量的叫法，容易搞混，要结合代码注释看。 简单小节一下： 类型参数匹配器，作用主要主要是判断实例的类型是否为类型参数匹配器对应类型的实例，是则返回ture，否返回false。主要是用于，当通道读取消息对象时，判断通道是不可以处理此消息对象。 get方法：根据Class类型获取类型参数匹配器，首先从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存，从类型参数匹配器缓存，获取参数类型parameterType对应的类型参数匹配器，如果匹配器为空且匹配参数为Object，则匹配器为NOOP，否则，根据参数类型创建ReflectiveMatcher添加到缓存中。 find方法：跟实例object，类型父类parametrizedSuperclass，类型参数名typeParamName， 获取类型参数名object对应的类型参数匹配器，首先从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存，从类型参数匹配器缓存，获取objec类型thisClass对应的类型参数匹配器映射关系，如果不存在object类型对应的类型参数匹配器映射关系，则创建，并添加到缓存中，否则，从object类型对应的类型参数匹配器Map中获取，对应的类型参数匹配器，如果object对应的类型参数匹配器为空，则从父类中获取类型参数名对应的类型的参数匹配器（find0方法获取类型参数名对应的原始类），并将类型与从父类中获取匹配器映射关系，添加到缓存中，否则直接返回匹配器。 find0方法：获取obejct实际类型父类parametrizedSuperclass泛型参数中，类型参数名为typeParamName对应的原始类型过程为，首先获取object的类型currentClass，如果当前类型currentClass的父类为parametrizedSuperclass，获取当前类父类的泛型类型变量，寻找类型参数名对应的类型变量，如果找到，则记录类型变量索引位置，如果索引为位置小于0，即，在object类型父类的类型变量中没有找到typeParamName对应的类型变量，否则，获取当前类的父类泛型类型，如果父类的泛型类型非参数化类型，则返回Object类型，否则，获取父类的实际类型参数，如果实际类型参数为参数化类型，则获取索引对应实际类型参数的原始类型RawType， 如果实际类型为Class，则直接返回Class，如果实际类型参数为泛型数组类型，获取泛型数组类型的泛型组件类型GenericComponentType，如果组件类型为参数化类型，则组件类型为原始类型RawType，如果组件类型为Class，则创建对应的数组实例，并获取实例的类型，如果实际类型参数为类型变量，转化实际类型参数为类型变量v，如果类型变量的声明类不是Class，则返回Object类型，否则设置参数化父类的类型为类型变量v的声明类，如果参数类型父类为thisClass类型，则跳出当前循环，否则返回Object类型，这时，当前类型currentClass的父类为parametrizedSuperclas的情况结束；如果父类不为parametrizedSuperclas，则获取currentClass父类，并设置为当前类继续自旋。自旋的目的是，找到与parametrizedSuperclas类型相等的object类型或父类型。 ** 总结：**简单Inbound通道处理器SimpleChannelInboundHandler，内部有连个变量一个为参数类型匹配器，用来判断通道是否可以处理消息，另一个变量autoRelease，用于控制是否在通道处理消息完毕时，释放消息。读取方法channelRead，首先判断跟定的消息类型是否可以被处理，如果是，则委托给channelRead0，channelRead0待子类实现；如果返回false，则将消息转递给Channel管道线的下一个通道处理器；最后，如果autoRelease为自动释放消息，且消息已处理则释放消息。" />
<link rel="canonical" href="http://www.jfox.info/2017/netty%E7%AE%80%E5%8D%95inbound%E4%BF%A1%E9%81%93%E5%A4%84%E7%90%86%E5%99%A8simplechannelinboundhandler.html" />
<meta property="og:url" content="http://www.jfox.info/2017/netty%E7%AE%80%E5%8D%95inbound%E4%BF%A1%E9%81%93%E5%A4%84%E7%90%86%E5%99%A8simplechannelinboundhandler.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T15:58:49+00:00" />
<script type="application/ld+json">
{"description":"Netty 通道处理器ChannelHandler和适配器定义ChannelHandlerAdapter： http://donald-draper.iteye.com/blog/2386891Netty Inbound/Outbound通道处理器定义： http://donald-draper.iteye.com/blog/2387019引言： 前面一篇文章我们看了Inbound/Outbound通道处理器定义先来回顾一下先： 通道Inbound处理器，主要是处理从peer发送过来的字节流；通道处理器上下文关联的通道注册到事件循环EventLoop时，触发channelRegistered方法；通道处理器上下文关联的通道激活时，触发channelActive方法；通道从peer读取消息时，触发channelRead方法；当上一消息通过#channelRead方法，并被当先读操作消费时，触发channelReadComplete方法，如果通道配置项 #AUTO_READ为关闭状态，没有进一步尝试从当前通道读取inbound数据时，直到ChannelHandlerContext#read调用，触发；当用户事件发生时，触发userEventTriggered方法；异常抛出时，触发exceptionCaught方法；当通道可写状态改变时，触发channelWritabilityChanged方法；通道处理器上下文关联的通道注册到事件循环EventLoop，但处于非激活状态，达到生命周期的末端时，触发channelInactive方法；通道处理器上下文关联的通道从事件循环EventLoop移除时，触发channelUnregistered方法。 Inbound通道handler适配器ChannelInboundHandlerAdapter，提供的Inbound通道处理器的所有方法的实现，但实现仅仅是，转发操作给Channel管道线的下一个通道处理器，子类必须重写方法。需要注意的是，在#channelRead方法自动返回后，消息并没有释放。如果你寻找ChannelInboundHandler的实现，可以自动释放接受的到消息可以使用SimpleChannelInboundHandler。 Outbound通道处理器ChannelOutboundHandler主要处理outbound IO操作。当绑定操作发生时，调用bind方法；当连接操作发生时，调用connect方法；read方法拦截通道处理器上下文读操作；当写操发生时，调用write方法，写操作通过Channel管道线写消息，当通道调用#flush方法时，消息将会被刷新，发送出去；当一个刷新操作发生时，调用flush方法，刷新操作将会刷新所有先前已经写，待发送的消息。 Outbound通道Handler适配器ChannelOutboundHandlerAdapter为Outbound通道处理器的基本实现，这个实现仅仅通过通道处理器上下文转发方法的调用。 子类必须重写Outbound通道Handler适配器的相关方法。 在Mina中，通道读写全部在一个通道Handler，Mina提供的通道Handler适配器，我们在使用通道处理器时继承它，实现我们需要关注的读写事件。而Netty使用InBound和OutBound将通道的读写分离，同时提供了InBound和OutBound通道Handler的适配器。 今天来看一下SimpleChannelInboundHandler： package io.netty.channel; import io.netty.util.ReferenceCountUtil; import io.netty.util.internal.TypeParameterMatcher; /** * {@link ChannelInboundHandlerAdapter} which allows to explicit only handle a specific type of messages. *简单Inbound通道处理器SimpleChannelInboundHandler，允许明确处理一种特殊类型的消息。 * For example here is an implementation which only handle {@link String} messages. *下面是一个处理String类型数据Inbound通道处理器实现 * &lt;pre&gt; * public class StringHandler extends * {@link SimpleChannelInboundHandler}&lt;{@link String}&gt; { * * {@code @Override} * protected void channelRead0({@link ChannelHandlerContext} ctx, {@link String} message) * throws {@link Exception} { * System.out.println(message); * } * } * &lt;/pre&gt; * * Be aware that depending of the constructor parameters it will release all handled messages by passing them to * {@link ReferenceCountUtil#release(Object)}. In this case you may need to use * {@link ReferenceCountUtil#retain(Object)} if you pass the object to the next handler in the {@link ChannelPipeline}. *需要注意的是，是否通过转递消息给ReferenceCountUtil#release方法，释放处理过的消息，依赖于构造参数autoRelease（boolean）。 如果你需要将消息传递给Channle管道线的下一个通道处理器，你需要调用ReferenceCountUtil#retain(Object)方法； * &lt;h3&gt;Forward compatibility notice&lt;/h3&gt; * 转发兼容性提醒 * Please keep in mind that {@link #channelRead0(ChannelHandlerContext, I)} will be renamed to * {@code messageReceived(ChannelHandlerContext, I)} in 5.0. * 请注意：#channelRead0方法在Netty5，中将被命名为消息messageReceived。 */ public abstract class SimpleChannelInboundHandler&lt;I&gt; extends ChannelInboundHandlerAdapter { private final TypeParameterMatcher matcher;//类型参数匹配器 private final boolean autoRelease;//是否自动释放 /** * see {@link #SimpleChannelInboundHandler(boolean)} with {@code true} as boolean parameter. 默认自动释放处理过的消息 */ protected SimpleChannelInboundHandler() { this(true); } /** * Create a new instance which will try to detect the types to match out of the type parameter of the class. *创建一个实例，尝试探测接受消息类型与SimpleChannelInboundHandler的I的类型是否相同。 * @param autoRelease {@code true} if handled messages should be released automatically by passing them to * {@link ReferenceCountUtil#release(Object)}. 是否通过ReferenceCountUtil#release方法释放消息 */ protected SimpleChannelInboundHandler(boolean autoRelease) { matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, &quot;I&quot;); this.autoRelease = autoRelease; } /** * see {@link #SimpleChannelInboundHandler(Class, boolean)} with {@code true} as boolean value. */ protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType) { this(inboundMessageType, true); } /** * Create a new instance * * @param inboundMessageType The type of messages to match * @param autoRelease {@code true} if handled messages should be released automatically by passing them to * {@link ReferenceCountUtil#release(Object)}. */ protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType, boolean autoRelease) { matcher = TypeParameterMatcher.get(inboundMessageType); this.autoRelease = autoRelease; } /** * Returns {@code true} if the given message should be handled. If {@code false} it will be passed to the next * {@link ChannelInboundHandler} in the {@link ChannelPipeline}. 判断跟定的消息类型是否可以被处理，如果返回false，则将消息转递给Channel管道线的下一个通道处理器 */ public boolean acceptInboundMessage(Object msg) throws Exception { return matcher.match(msg); } //读取消息对象 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { boolean release = true; try { if (acceptInboundMessage(msg)) { @SuppressWarnings(&quot;unchecked&quot;) I imsg = (I) msg; //如果消息属于本Handler可以处理的消息类型，则委托给channelRead0 channelRead0(ctx, imsg); } else { release = false; //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); } } finally { if (autoRelease &amp;&amp; release) { //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); } } } /** * [b]Please keep in mind that this method will be renamed to * {@code messageReceived(ChannelHandlerContext, I)} in 5.0.[/b] *注意此方法在5.0以后将命名为messageReceived * Is called for each message of type {@link I}. * * @param ctx the {@link ChannelHandlerContext} which this {@link SimpleChannelInboundHandler} * belongs to * @param msg the message to handle * @throws Exception is thrown if an error occurred */ protected abstract void channelRead0(ChannelHandlerContext ctx, I msg) throws Exception; } 来看读取消息对象方法： //读取消息对象 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { boolean release = true; try { if (acceptInboundMessage(msg)) { @SuppressWarnings(&quot;unchecked&quot;) I imsg = (I) msg; //如果消息属于本Handler可以处理的消息类型，则委托给channelRead0 channelRead0(ctx, imsg); } else { release = false; //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); } } finally { if (autoRelease &amp;&amp; release) { //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); } } } 其中有两点需要关注： //当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息 ctx.fireChannelRead(msg); //ChannelHandlerContext public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker { @Override ChannelHandlerContext fireChannelRead(Object msg); } //ChannelInboundInvoker /** * A {@link Channel} received a message. *通道接收一个消息 * This will result in having the {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)} * method called of the next {@link ChannelInboundHandler} contained in the {@link ChannelPipeline} of the * {@link Channel}. ChannelInboundHandler#channelRead方法调用将会通知，通道所在的Channel管道线中的下一个通道处理器，接受一个消息 */ ChannelInboundInvoker fireChannelRead(Object msg); //如果autoRelease为自动释放消息，且消息已处理则释放消息 ReferenceCountUtil.release(msg); //ReferenceCountUtil /** * Try to call {@link ReferenceCounted#release()} if the specified message implements {@link ReferenceCounted}. * If the specified message doesn’t implement {@link ReferenceCounted}, this method does nothing. 如果消息实现了ReferenceCounted，则调用ReferenceCounted#release()，如果不是什么都不做 */ public static boolean release(Object msg) { if (msg instanceof ReferenceCounted) { return ((ReferenceCounted) msg).release(); } return false; } //ReferenceCounted /** * Decreases the reference count by {@code 1} and deallocates this object if the reference count reaches at * {@code 0}. *自减引用计数器，如果计数器为0，则回收对象。 * @return {@code true} if and only if the reference count became {@code 0} and this object has been deallocated */ boolean release(); 从上面来看，读操作，首先判断跟定的消息类型是否可以被处理，如果是，则委托给channelRead0，如果返回false，则将消息转递给Channel管道线的下一个通道处理器；最后，如果autoRelease为自动释放消息，且消息已处理则释放消息。 在简单Inbound通道处理器的构造方法： protected SimpleChannelInboundHandler(boolean autoRelease) { matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, &quot;I&quot;); this.autoRelease = autoRelease; } protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType, boolean autoRelease) { matcher = TypeParameterMatcher.get(inboundMessageType); this.autoRelease = autoRelease; } 和acceptInboundMessage方法中 //判断跟定的消息类型是否可以被处理，如果返回false，则将消息转递给Channel管道线的下一个通道处理器 public boolean acceptInboundMessage(Object msg) throws Exception { return matcher.match(msg); } 涉及到一个参数类型匹配器TypeParameterMatcher，为了理解TypeParameterMatcher花了几天时间， 学习了一下java Type体系结构，在往下看之前，需要了解java Type体系结构，具体可以参考一下连接: Type —— Java类型: http://blog.csdn.net/a327369238/article/details/52621043详解Java泛型type体系整理: http://developer.51cto.com/art/201103/250028.htm 黑马程序员–Java基础加强–13.利用反射操作泛型II【TypeVariable】【GenericArrayType】【WildcardType】【Type及其子接口的来历】【个人总结】 http://blog.csdn.net/benjaminzhang666/article/details/9839007泛型通配符extends与super的区别: http://www.cnblogs.com/yepei/p/6591289.html另外附上java Type体系结构的示例地址： https://github.com/Donaldhan/java-base-demo 本身这篇文章应该上个星期就出来呢？由于对java Type体系结构不熟，难以理解参数类型匹配器TypeParameterMatcher，所以推迟到现在，本身同时想写一篇java Type体系结构相关的文章，后来一想算了，网上很多资料，再加上自己写Demo里面有相关的说明，就不写了，一个字懒…… 言归正传，下面我们来看TypeParameterMatcher package io.netty.util.internal; import java.lang.reflect.Array; import java.lang.reflect.GenericArrayType; import java.lang.reflect.ParameterizedType; import java.lang.reflect.Type; import java.lang.reflect.TypeVariable; import java.util.HashMap; import java.util.Map; public abstract class TypeParameterMatcher { //默认空参数类型匹配器，匹配方法永远返回true private static final TypeParameterMatcher NOOP = new TypeParameterMatcher() { @Override public boolean match(Object msg) { return true; } }; //判断消息对象类型是否匹配当前类型匹配器 public abstract boolean match(Object msg); //反射匹配器 private static final class ReflectiveMatcher extends TypeParameterMatcher { private final Class&lt;?&gt; type; ReflectiveMatcher(Class&lt;?&gt; type) { this.type = type; } //根据对象是为类型Type的实例，来判断是否消息是否匹配 @Override public boolean match(Object msg) { return type.isInstance(msg); } } TypeParameterMatcher() { } //根据Class类型获取类型参数匹配器 public static TypeParameterMatcher get(final Class&lt;?&gt; parameterType) { //从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存 final Map&lt;Class&lt;?&gt;, TypeParameterMatcher&gt; getCache = InternalThreadLocalMap.get().typeParameterMatcherGetCache(); //从类型参数匹配器缓存，获取类型parameterType对应的类型参数匹配器 TypeParameterMatcher matcher = getCache.get(parameterType); if (matcher == null) {//如果匹配器为空 if (parameterType == Object.class) {匹配参数为Object，匹配器为NOOP matcher = NOOP; } else { matcher = new ReflectiveMatcher(parameterType); } getCache.put(parameterType, matcher); } return matcher; } //跟实例object，类型父类parametrizedSuperclass，类型参数名typeParamName，获取类型参数名object对应的类型参数匹配器 public static TypeParameterMatcher find( final Object object, final Class&lt;?&gt; parametrizedSuperclass, final String typeParamName) { //从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存 final Map&lt;Class&lt;?&gt;, Map&lt;String, TypeParameterMatcher&gt;&gt; findCache = InternalThreadLocalMap.get().typeParameterMatcherFindCache(); //获取object类型 final Class&lt;?&gt; thisClass = object.getClass(); //从类型参数匹配器缓存，获取类型thisClass对应的类型参数匹配器映射关系 Map&lt;String, TypeParameterMatcher&gt; map = findCache.get(thisClass); if (map == null) { //如果不存在object类型对应的类型参数匹配器映射关系，则创建，并添加到缓存中 map = new HashMap&lt;String, TypeParameterMatcher&gt;(); findCache.put(thisClass, map); } //从object类型对应的类型参数匹配器Map中获取，对应的类型参数匹配器 TypeParameterMatcher matcher = map.get(typeParamName); if (matcher == null) { //如果object对应的类型参数匹配器为空，则从父类中获取类型参数名对应的类型的参数匹配器 matcher = get(find0(object, parametrizedSuperclass, typeParamName)); //类型参数名和类型参数匹配器，添加到对应的映射Map中 map.put(typeParamName, matcher); } return matcher; } //获取obejct实际类型父类parametrizedSuperclass泛型参数中，类型参数名为typeParamName对应的原始类型 private static Class&lt;?&gt; find0( final Object object, Class&lt;?&gt; parametrizedSuperclass, String typeParamName) { //获取object的类型 final Class&lt;?&gt; thisClass = object.getClass(); Class&lt;?&gt; currentClass = thisClass; for (;;) { if (currentClass.getSuperclass() == parametrizedSuperclass) {//如果当前类型父类为parametrizedSuperclass int typeParamIndex = -1; //获取当前类父类的泛型类型变量 TypeVariable&lt;?&gt;[] typeParams = currentClass.getSuperclass().getTypeParameters(); for (int i = 0; i &lt; typeParams.length; i ++) { //寻找类型参数名对应的类型变量，如果找到，则记录类型变量索引位置 if (typeParamName.equals(typeParams[i].getName())) { typeParamIndex = i; break; } } //如果索引为位置小于0，即，在object类型父类的类型变量中没有找到typeParamName对应的类型变量 if (typeParamIndex &lt; 0) { throw new IllegalStateException( &quot;unknown type parameter &#39;&quot; + typeParamName + &quot;&#39;: &quot; + parametrizedSuperclass); } //获取当前类的父类泛型类型 Type genericSuperType = currentClass.getGenericSuperclass(); if (!(genericSuperType instanceof ParameterizedType)) { //如果父类的泛型类型非参数化类型，则返回Object类型 return Object.class; } //获取父类的实际类型参数 Type[] actualTypeParams = ((ParameterizedType) genericSuperType).getActualTypeArguments(); Type actualTypeParam = actualTypeParams[typeParamIndex]; if (actualTypeParam instanceof ParameterizedType) { //如果实际类型参数为参数化类型，则获取实际类型参数的原始类型RawType（不包括泛型部分） actualTypeParam = ((ParameterizedType) actualTypeParam).getRawType(); } if (actualTypeParam instanceof Class) { //如果实际类型为Class，则直接返回Class return (Class&lt;?&gt;) actualTypeParam; } if (actualTypeParam instanceof GenericArrayType) { //如果实际类型参数为泛型数组类型，获取泛型数组类型的泛型组件类型GenericComponentType Type componentType = ((GenericArrayType) actualTypeParam).getGenericComponentType(); if (componentType instanceof ParameterizedType) { 如果组件类型为参数化类型，则组件类型为原始类型RawType componentType = ((ParameterizedType) componentType).getRawType(); } if (componentType instanceof Class) { //如果组件类型为Class，则创建对应的数组实例，并获取实例的类型 return Array.newInstance((Class&lt;?&gt;) componentType, 0).getClass(); } } if (actualTypeParam instanceof TypeVariable) { //如果实际类型参数为类型变量，转化实际类型参数为类型变量 // Resolved type parameter points to another type parameter. TypeVariable&lt;?&gt; v = (TypeVariable&lt;?&gt;) actualTypeParam; currentClass = thisClass; if (!(v.getGenericDeclaration() instanceof Class)) { //如果类型变量的声明类不是Class，则返回Object类型 return Object.class; } //参数化父类的类型为，类型变量v的声明类 parametrizedSuperclass = (Class&lt;?&gt;) v.getGenericDeclaration(); //获取类型变量名称 typeParamName = v.getName(); if (parametrizedSuperclass.isAssignableFrom(thisClass)) { //如果参数类型父类为thisClass类型，则跳出当前循环 continue; } else { //否则返回Object类型 return Object.class; } } return fail(thisClass, typeParamName); } //否则获取当前类型的父类 currentClass = currentClass.getSuperclass(); if (currentClass == null) { return fail(thisClass, typeParamName); } } } //找不到类型参数名对应的类型，则抛出非法状态异常 private static Class&lt;?&gt; fail(Class&lt;?&gt; type, String typeParamName) { throw new IllegalStateException( &quot;cannot determine the type of the type parameter &#39;&quot; + typeParamName + &quot;&#39;: &quot; + type); } } 这个类型参数匹配器就不说了，各种变量的叫法，容易搞混，要结合代码注释看。 简单小节一下： 类型参数匹配器，作用主要主要是判断实例的类型是否为类型参数匹配器对应类型的实例，是则返回ture，否返回false。主要是用于，当通道读取消息对象时，判断通道是不可以处理此消息对象。 get方法：根据Class类型获取类型参数匹配器，首先从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存，从类型参数匹配器缓存，获取参数类型parameterType对应的类型参数匹配器，如果匹配器为空且匹配参数为Object，则匹配器为NOOP，否则，根据参数类型创建ReflectiveMatcher添加到缓存中。 find方法：跟实例object，类型父类parametrizedSuperclass，类型参数名typeParamName， 获取类型参数名object对应的类型参数匹配器，首先从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存，从类型参数匹配器缓存，获取objec类型thisClass对应的类型参数匹配器映射关系，如果不存在object类型对应的类型参数匹配器映射关系，则创建，并添加到缓存中，否则，从object类型对应的类型参数匹配器Map中获取，对应的类型参数匹配器，如果object对应的类型参数匹配器为空，则从父类中获取类型参数名对应的类型的参数匹配器（find0方法获取类型参数名对应的原始类），并将类型与从父类中获取匹配器映射关系，添加到缓存中，否则直接返回匹配器。 find0方法：获取obejct实际类型父类parametrizedSuperclass泛型参数中，类型参数名为typeParamName对应的原始类型过程为，首先获取object的类型currentClass，如果当前类型currentClass的父类为parametrizedSuperclass，获取当前类父类的泛型类型变量，寻找类型参数名对应的类型变量，如果找到，则记录类型变量索引位置，如果索引为位置小于0，即，在object类型父类的类型变量中没有找到typeParamName对应的类型变量，否则，获取当前类的父类泛型类型，如果父类的泛型类型非参数化类型，则返回Object类型，否则，获取父类的实际类型参数，如果实际类型参数为参数化类型，则获取索引对应实际类型参数的原始类型RawType， 如果实际类型为Class，则直接返回Class，如果实际类型参数为泛型数组类型，获取泛型数组类型的泛型组件类型GenericComponentType，如果组件类型为参数化类型，则组件类型为原始类型RawType，如果组件类型为Class，则创建对应的数组实例，并获取实例的类型，如果实际类型参数为类型变量，转化实际类型参数为类型变量v，如果类型变量的声明类不是Class，则返回Object类型，否则设置参数化父类的类型为类型变量v的声明类，如果参数类型父类为thisClass类型，则跳出当前循环，否则返回Object类型，这时，当前类型currentClass的父类为parametrizedSuperclas的情况结束；如果父类不为parametrizedSuperclas，则获取currentClass父类，并设置为当前类继续自旋。自旋的目的是，找到与parametrizedSuperclas类型相等的object类型或父类型。 ** 总结：**简单Inbound通道处理器SimpleChannelInboundHandler，内部有连个变量一个为参数类型匹配器，用来判断通道是否可以处理消息，另一个变量autoRelease，用于控制是否在通道处理消息完毕时，释放消息。读取方法channelRead，首先判断跟定的消息类型是否可以被处理，如果是，则委托给channelRead0，channelRead0待子类实现；如果返回false，则将消息转递给Channel管道线的下一个通道处理器；最后，如果autoRelease为自动释放消息，且消息已处理则释放消息。","@type":"BlogPosting","url":"http://www.jfox.info/2017/netty%E7%AE%80%E5%8D%95inbound%E4%BF%A1%E9%81%93%E5%A4%84%E7%90%86%E5%99%A8simplechannelinboundhandler.html","headline":"netty 简单Inbound信道处理器（SimpleChannelInboundHandler）","dateModified":"2017-01-01T15:58:49+00:00","datePublished":"2017-01-01T15:58:49+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/netty%E7%AE%80%E5%8D%95inbound%E4%BF%A1%E9%81%93%E5%A4%84%E7%90%86%E5%99%A8simplechannelinboundhandler.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">netty 简单Inbound信道处理器（SimpleChannelInboundHandler）</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T15:58:49+00:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>Netty 通道处理器ChannelHandler和适配器定义ChannelHandlerAdapter：</p>

<p><a href="https://www.jfox.info/go.php?url=http://donald-draper.iteye.com/blog/2386891">http://donald-draper.iteye.com/blog/2386891</a>Netty Inbound/Outbound通道处理器定义： 
<a href="https://www.jfox.info/go.php?url=http://donald-draper.iteye.com/blog/2387019">http://donald-draper.iteye.com/blog/2387019</a><strong>引言：</strong>
前面一篇文章我们看了Inbound/Outbound通道处理器定义先来回顾一下先：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   通道Inbound处理器，主要是处理从peer发送过来的字节流；通道处理器上下文关联的通道注册到事件循环EventLoop时，触发channelRegistered方法；通道处理器上下文关联的通道激活时，触发channelActive方法；通道从peer读取消息时，触发channelRead方法；当上一消息通过#channelRead方法，并被当先读操作消费时，触发channelReadComplete方法，如果通道配置项 
</code></pre></div></div>

<p>#AUTO_READ为关闭状态，没有进一步尝试从当前通道读取inbound数据时，直到ChannelHandlerContext#read调用，触发；当用户事件发生时，触发userEventTriggered方法；异常抛出时，触发exceptionCaught方法；当通道可写状态改变时，触发channelWritabilityChanged方法；通道处理器上下文关联的通道注册到事件循环EventLoop，但处于非激活状态，达到生命周期的末端时，触发channelInactive方法；通道处理器上下文关联的通道从事件循环EventLoop移除时，触发channelUnregistered方法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    Inbound通道handler适配器ChannelInboundHandlerAdapter，提供的Inbound通道处理器的所有方法的实现，但实现仅仅是，转发操作给Channel管道线的下一个通道处理器，子类必须重写方法。需要注意的是，在#channelRead方法自动返回后，消息并没有释放。如果你寻找ChannelInboundHandler的实现，可以自动释放接受的到消息可以使用SimpleChannelInboundHandler。 

    Outbound通道处理器ChannelOutboundHandler主要处理outbound IO操作。当绑定操作发生时，调用bind方法；当连接操作发生时，调用connect方法；read方法拦截通道处理器上下文读操作；当写操发生时，调用write方法，写操作通过Channel管道线写消息，当通道调用#flush方法时，消息将会被刷新，发送出去；当一个刷新操作发生时，调用flush方法，刷新操作将会刷新所有先前已经写，待发送的消息。 

    Outbound通道Handler适配器ChannelOutboundHandlerAdapter为Outbound通道处理器的基本实现，这个实现仅仅通过通道处理器上下文转发方法的调用。 
</code></pre></div></div>

<p>子类必须重写Outbound通道Handler适配器的相关方法。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    在Mina中，通道读写全部在一个通道Handler，Mina提供的通道Handler适配器，我们在使用通道处理器时继承它，实现我们需要关注的读写事件。而Netty使用InBound和OutBound将通道的读写分离，同时提供了InBound和OutBound通道Handler的适配器。 
</code></pre></div></div>

<p>今天来看一下SimpleChannelInboundHandler：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">channel</span><span class="p">;</span>

<span class="n">import</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">ReferenceCountUtil</span><span class="p">;</span>
<span class="n">import</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">internal</span><span class="p">.</span><span class="n">TypeParameterMatcher</span><span class="p">;</span>

<span class="p">/**</span>
 <span class="p">*</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelInboundHandlerAdapter</span><span class="p">}</span> <span class="n">which</span> <span class="n">allows</span> <span class="k">to</span> <span class="n">explicit</span> <span class="n">only</span> <span class="n">handle</span> <span class="n">a</span> <span class="n">specific</span> <span class="n">type</span> <span class="k">of</span> <span class="n">messages</span><span class="p">.</span>
 <span class="p">*</span><span class="err">简单</span><span class="n">Inbound</span><span class="err">通道处理器</span><span class="n">SimpleChannelInboundHandler</span><span class="err">，允许明确处理一种特殊类型的消息。</span>
 <span class="p">*</span> <span class="n">For</span> <span class="n">example</span> <span class="n">here</span> <span class="n">is</span> <span class="n">an</span> <span class="n">implementation</span> <span class="n">which</span> <span class="n">only</span> <span class="n">handle</span> <span class="p">{@</span><span class="n">link</span> <span class="k">String</span><span class="p">}</span> <span class="n">messages</span><span class="p">.</span>
 <span class="p">*</span><span class="err">下面是一个处理</span><span class="n">String</span><span class="err">类型数据</span><span class="n">Inbound</span><span class="err">通道处理器实现</span>
 <span class="p">*</span> <span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;</span>
 <span class="p">*</span>     <span class="k">public</span> <span class="n">class</span> <span class="n">StringHandler</span> <span class="n">extends</span>
 <span class="p">*</span>             <span class="p">{@</span><span class="n">link</span> <span class="n">SimpleChannelInboundHandler</span><span class="p">}&lt;{@</span><span class="n">link</span> <span class="k">String</span><span class="p">}&gt;</span> <span class="p">{</span>
 <span class="p">*</span>
 <span class="p">*</span>         <span class="p">{@</span><span class="n">code</span> <span class="p">@</span><span class="n">Override</span><span class="p">}</span>
 <span class="p">*</span>         <span class="n">protected</span> <span class="n">void</span> <span class="n">channelRead0</span><span class="p">({@</span><span class="n">link</span> <span class="n">ChannelHandlerContext</span><span class="p">}</span> <span class="n">ctx</span><span class="p">,</span> <span class="p">{@</span><span class="n">link</span> <span class="k">String</span><span class="p">}</span> <span class="n">message</span><span class="p">)</span>
 <span class="p">*</span>                 <span class="n">throws</span> <span class="p">{@</span><span class="n">link</span> <span class="n">Exception</span><span class="p">}</span> <span class="p">{</span>
 <span class="p">*</span>             <span class="nf">System</span><span class="p">.</span><span class="n">out</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
 <span class="p">*</span>         <span class="p">}</span>
 <span class="p">*</span>     <span class="p">}</span>
 <span class="p">*</span> <span class="p">&lt;/</span><span class="n">pre</span><span class="p">&gt;</span>
 <span class="p">*</span>
 <span class="p">*</span> <span class="n">Be</span> <span class="n">aware</span> <span class="n">that</span> <span class="n">depending</span> <span class="k">of</span> <span class="n">the</span> <span class="n">constructor</span> <span class="k">parameters</span> <span class="n">it</span> <span class="n">will</span> <span class="n">release</span> <span class="n">all</span> <span class="n">handled</span> <span class="n">messages</span> <span class="n">by</span> <span class="n">passing</span> <span class="n">them</span> <span class="k">to</span>
 <span class="p">*</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ReferenceCountUtil</span><span class="p">#</span><span class="n">release</span><span class="p">(</span><span class="n">Object</span><span class="p">)}.</span> <span class="k">In</span> <span class="n">this</span> <span class="k">case</span> <span class="n">you</span> <span class="n">may</span> <span class="n">need</span> <span class="k">to</span> <span class="n">use</span>
 <span class="p">*</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ReferenceCountUtil</span><span class="p">#</span><span class="n">retain</span><span class="p">(</span><span class="n">Object</span><span class="p">)}</span> <span class="k">if</span> <span class="n">you</span> <span class="n">pass</span> <span class="n">the</span> <span class="n">object</span> <span class="k">to</span> <span class="n">the</span> <span class="k">next</span> <span class="n">handler</span> <span class="k">in</span> <span class="n">the</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelPipeline</span><span class="p">}.</span>
 <span class="p">*</span><span class="err">需要注意的是，是否通过转递消息给</span><span class="n">ReferenceCountUtil</span><span class="p">#</span><span class="n">release</span><span class="err">方法，释放处理过的消息，依赖于构造参数</span><span class="n">autoRelease</span><span class="err">（</span><span class="k">boolean</span><span class="err">）。</span>
 <span class="err">如果你需要将消息传递给</span><span class="n">Channle</span><span class="err">管道线的下一个通道处理器，你需要调用</span><span class="n">ReferenceCountUtil</span><span class="p">#</span><span class="n">retain</span><span class="p">(</span><span class="n">Object</span><span class="p">)</span><span class="err">方法；</span>
 <span class="p">*</span> <span class="p">&lt;</span><span class="n">h3</span><span class="p">&gt;</span><span class="k">Forward</span> <span class="n">compatibility</span> <span class="n">notice</span><span class="p">&lt;/</span><span class="n">h3</span><span class="p">&gt;</span>
 <span class="p">*</span> <span class="err">转发兼容性提醒</span>
 <span class="p">*</span> <span class="n">Please</span> <span class="n">keep</span> <span class="k">in</span> <span class="n">mind</span> <span class="n">that</span> <span class="p">{@</span><span class="n">link</span> <span class="p">#</span><span class="n">channelRead0</span><span class="p">(</span><span class="n">ChannelHandlerContext</span><span class="p">,</span> <span class="n">I</span><span class="p">)}</span> <span class="n">will</span> <span class="n">be</span> <span class="n">renamed</span> <span class="k">to</span>
 <span class="p">*</span> <span class="p">{@</span><span class="n">code</span> <span class="n">messageReceived</span><span class="p">(</span><span class="n">ChannelHandlerContext</span><span class="p">,</span> <span class="n">I</span><span class="p">)}</span> <span class="k">in</span> <span class="m">5.0</span><span class="p">.</span>
 <span class="p">*</span> 

 <span class="err">请注意：</span><span class="p">#</span><span class="n">channelRead0</span><span class="err">方法在</span><span class="n">Netty5</span><span class="err">，中将被命名为消息</span><span class="n">messageReceived</span><span class="err">。</span>
 <span class="p">*/</span>
<span class="k">public</span> <span class="n">abstract</span> <span class="n">class</span> <span class="n">SimpleChannelInboundHandler</span><span class="p">&lt;</span><span class="n">I</span><span class="p">&gt;</span> <span class="n">extends</span> <span class="n">ChannelInboundHandlerAdapter</span> <span class="p">{</span>

    <span class="n">private</span> <span class="n">final</span> <span class="n">TypeParameterMatcher</span> <span class="n">matcher</span><span class="p">;//</span><span class="err">类型参数匹配器</span>
    <span class="n">private</span> <span class="n">final</span> <span class="k">boolean</span> <span class="n">autoRelease</span><span class="p">;//</span><span class="err">是否自动释放</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">see</span> <span class="p">{@</span><span class="n">link</span> <span class="p">#</span><span class="n">SimpleChannelInboundHandler</span><span class="p">(</span><span class="k">boolean</span><span class="p">)}</span> <span class="k">with</span> <span class="p">{@</span><span class="n">code</span> <span class="nb">true</span><span class="p">}</span> <span class="k">as</span> <span class="k">boolean</span> <span class="n">parameter</span><span class="p">.</span>
     <span class="err">默认自动释放处理过的消息</span>
     <span class="p">*/</span>
    <span class="n">protected</span> <span class="n">SimpleChannelInboundHandler</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">this</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">instance</span> <span class="n">which</span> <span class="n">will</span> <span class="n">try</span> <span class="k">to</span> <span class="n">detect</span> <span class="n">the</span> <span class="n">types</span> <span class="k">to</span> <span class="n">match</span> <span class="n">out</span> <span class="k">of</span> <span class="n">the</span> <span class="n">type</span> <span class="n">parameter</span> <span class="k">of</span> <span class="n">the</span> <span class="n">class</span><span class="p">.</span>
     <span class="p">*</span><span class="err">创建一个实例，尝试探测接受消息类型与</span><span class="n">SimpleChannelInboundHandler</span><span class="err">的</span><span class="n">I</span><span class="err">的类型是否相同。</span>
     <span class="p">*</span> <span class="p">@</span><span class="n">param</span> <span class="n">autoRelease</span>   <span class="p">{@</span><span class="n">code</span> <span class="nb">true</span><span class="p">}</span> <span class="k">if</span> <span class="n">handled</span> <span class="n">messages</span> <span class="n">should</span> <span class="n">be</span> <span class="n">released</span> <span class="n">automatically</span> <span class="n">by</span> <span class="n">passing</span> <span class="n">them</span> <span class="k">to</span>
     <span class="p">*</span>                      <span class="p">{@</span><span class="n">link</span> <span class="n">ReferenceCountUtil</span><span class="p">#</span><span class="n">release</span><span class="p">(</span><span class="n">Object</span><span class="p">)}.</span>
     <span class="err">是否通过</span><span class="n">ReferenceCountUtil</span><span class="p">#</span><span class="n">release</span><span class="err">方法释放消息</span>
     <span class="p">*/</span>
    <span class="n">protected</span> <span class="n">SimpleChannelInboundHandler</span><span class="p">(</span><span class="k">boolean</span> <span class="n">autoRelease</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">matcher</span> <span class="p">=</span> <span class="n">TypeParameterMatcher</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">SimpleChannelInboundHandler</span><span class="p">.</span><span class="n">class</span><span class="p">,</span> <span class="s2">"I"</span><span class="p">);</span>
        <span class="n">this</span><span class="p">.</span><span class="n">autoRelease</span> <span class="p">=</span> <span class="n">autoRelease</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">see</span> <span class="p">{@</span><span class="n">link</span> <span class="p">#</span><span class="n">SimpleChannelInboundHandler</span><span class="p">(</span><span class="n">Class</span><span class="p">,</span> <span class="k">boolean</span><span class="p">)}</span> <span class="k">with</span> <span class="p">{@</span><span class="n">code</span> <span class="nb">true</span><span class="p">}</span> <span class="k">as</span> <span class="k">boolean</span> <span class="n">value</span><span class="p">.</span>
     <span class="p">*/</span>
    <span class="n">protected</span> <span class="n">SimpleChannelInboundHandler</span><span class="p">(</span><span class="n">Class</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">I</span><span class="p">&gt;</span> <span class="n">inboundMessageType</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">this</span><span class="p">(</span><span class="n">inboundMessageType</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">Create</span> <span class="n">a</span> <span class="n">new</span> <span class="n">instance</span>
     <span class="p">*</span>
     <span class="p">*</span> <span class="p">@</span><span class="n">param</span> <span class="n">inboundMessageType</span>    <span class="n">The</span> <span class="n">type</span> <span class="k">of</span> <span class="n">messages</span> <span class="k">to</span> <span class="n">match</span>
     <span class="p">*</span> <span class="p">@</span><span class="n">param</span> <span class="n">autoRelease</span>           <span class="p">{@</span><span class="n">code</span> <span class="nb">true</span><span class="p">}</span> <span class="k">if</span> <span class="n">handled</span> <span class="n">messages</span> <span class="n">should</span> <span class="n">be</span> <span class="n">released</span> <span class="n">automatically</span> <span class="n">by</span> <span class="n">passing</span> <span class="n">them</span> <span class="k">to</span>
     <span class="p">*</span>                              <span class="p">{@</span><span class="n">link</span> <span class="n">ReferenceCountUtil</span><span class="p">#</span><span class="n">release</span><span class="p">(</span><span class="n">Object</span><span class="p">)}.</span>
     <span class="p">*/</span>
    <span class="n">protected</span> <span class="n">SimpleChannelInboundHandler</span><span class="p">(</span><span class="n">Class</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">I</span><span class="p">&gt;</span> <span class="n">inboundMessageType</span><span class="p">,</span> <span class="k">boolean</span> <span class="n">autoRelease</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">matcher</span> <span class="p">=</span> <span class="n">TypeParameterMatcher</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">inboundMessageType</span><span class="p">);</span>
        <span class="n">this</span><span class="p">.</span><span class="n">autoRelease</span> <span class="p">=</span> <span class="n">autoRelease</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">Returns</span> <span class="p">{@</span><span class="n">code</span> <span class="nb">true</span><span class="p">}</span> <span class="k">if</span> <span class="n">the</span> <span class="n">given</span> <span class="n">message</span> <span class="n">should</span> <span class="n">be</span> <span class="n">handled</span><span class="p">.</span> <span class="k">If</span> <span class="p">{@</span><span class="n">code</span> <span class="nb">false</span><span class="p">}</span> <span class="n">it</span> <span class="n">will</span> <span class="n">be</span> <span class="n">passed</span> <span class="k">to</span> <span class="n">the</span> <span class="k">next</span>
     <span class="p">*</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelInboundHandler</span><span class="p">}</span> <span class="k">in</span> <span class="n">the</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelPipeline</span><span class="p">}.</span>
     <span class="err">判断跟定的消息类型是否可以被处理，如果返回</span><span class="nb">false</span><span class="err">，则将消息转递给</span><span class="n">Channel</span><span class="err">管道线的下一个通道处理器</span>
     <span class="p">*/</span>
    <span class="k">public</span> <span class="k">boolean</span> <span class="n">acceptInboundMessage</span><span class="p">(</span><span class="n">Object</span> <span class="n">msg</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Exception</span> <span class="p">{</span>
        <span class="n">return</span> <span class="n">matcher</span><span class="p">.</span><span class="n">match</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">//</span><span class="err">读取消息对象</span>
    <span class="p">@</span><span class="n">Override</span>
    <span class="k">public</span> <span class="n">void</span> <span class="n">channelRead</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">Object</span> <span class="n">msg</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Exception</span> <span class="p">{</span>
        <span class="k">boolean</span> <span class="n">release</span> <span class="p">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">try</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">acceptInboundMessage</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span> <span class="p">{</span>
                <span class="p">@</span><span class="n">SuppressWarnings</span><span class="p">(</span><span class="s2">"unchecked"</span><span class="p">)</span>
                <span class="n">I</span> <span class="n">imsg</span> <span class="p">=</span> <span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="n">msg</span><span class="p">;</span>
		<span class="p">//</span><span class="err">如果消息属于本</span><span class="n">Handler</span><span class="err">可以处理的消息类型，则委托给</span><span class="n">channelRead0</span>
                <span class="n">channelRead0</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">imsg</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">release</span> <span class="p">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="p">//</span><span class="err">当前通道</span><span class="n">Handler</span><span class="err">，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息</span>
                <span class="n">ctx</span><span class="p">.</span><span class="n">fireChannelRead</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="n">finally</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">autoRelease</span> <span class="p">&amp;&amp;</span> <span class="n">release</span><span class="p">)</span> <span class="p">{</span>
	        <span class="p">//</span><span class="err">如果</span><span class="n">autoRelease</span><span class="err">为自动释放消息，且消息已处理则释放消息</span>
                <span class="n">ReferenceCountUtil</span><span class="p">.</span><span class="n">release</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="n">Please</span> <span class="n">keep</span> <span class="k">in</span> <span class="n">mind</span> <span class="n">that</span> <span class="n">this</span> <span class="n">method</span> <span class="n">will</span> <span class="n">be</span> <span class="n">renamed</span> <span class="k">to</span>
     <span class="p">*</span> <span class="p">{@</span><span class="n">code</span> <span class="n">messageReceived</span><span class="p">(</span><span class="n">ChannelHandlerContext</span><span class="p">,</span> <span class="n">I</span><span class="p">)}</span> <span class="k">in</span> <span class="m">5.0</span><span class="p">.[/</span><span class="n">b</span><span class="p">]</span>
     <span class="p">*</span><span class="err">注意此方法在</span><span class="m">5.0</span><span class="err">以后将命名为</span><span class="n">messageReceived</span>
     <span class="p">*</span> <span class="n">Is</span> <span class="n">called</span> <span class="n">for</span> <span class="n">each</span> <span class="n">message</span> <span class="k">of</span> <span class="n">type</span> <span class="p">{@</span><span class="n">link</span> <span class="n">I</span><span class="p">}.</span>
     <span class="p">*</span>
     <span class="p">*</span> <span class="p">@</span><span class="n">param</span> <span class="n">ctx</span>           <span class="n">the</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelHandlerContext</span><span class="p">}</span> <span class="n">which</span> <span class="n">this</span> <span class="p">{@</span><span class="n">link</span> <span class="n">SimpleChannelInboundHandler</span><span class="p">}</span>
     <span class="p">*</span>                      <span class="n">belongs</span> <span class="k">to</span>
     <span class="p">*</span> <span class="p">@</span><span class="n">param</span> <span class="n">msg</span>           <span class="n">the</span> <span class="n">message</span> <span class="k">to</span> <span class="n">handle</span>
     <span class="p">*</span> <span class="p">@</span><span class="n">throws</span> <span class="n">Exception</span>    <span class="n">is</span> <span class="n">thrown</span> <span class="k">if</span> <span class="n">an</span> <span class="n">error</span> <span class="n">occurred</span>
     <span class="p">*/</span>
    <span class="n">protected</span> <span class="n">abstract</span> <span class="n">void</span> <span class="n">channelRead0</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">I</span> <span class="n">msg</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Exception</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>来看读取消息对象方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//读取消息对象
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        boolean release = true;
        try {
            if (acceptInboundMessage(msg)) {
                @SuppressWarnings("unchecked")
                I imsg = (I) msg;
		//如果消息属于本Handler可以处理的消息类型，则委托给channelRead0
                channelRead0(ctx, imsg);
            } else {
                release = false;
		//当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息
                ctx.fireChannelRead(msg);
            }
        } finally {
            if (autoRelease &amp;&amp; release) {
	        //如果autoRelease为自动释放消息，且消息已处理则释放消息
                ReferenceCountUtil.release(msg);
            }
        }
    }
</code></pre></div></div>

<p>其中有两点需要关注：</p>

<ol>
  <li>

    <p>//当前通道Handler，不可处理消息，通过通道上下文，通知管道线中的下一个通道处理器，接受到一个消息
 ctx.fireChannelRead(msg);</p>
  </li>
</ol>

<p>//ChannelHandlerContext</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface ChannelHandlerContext extends AttributeMap, ChannelInboundInvoker, ChannelOutboundInvoker {
 @Override
    ChannelHandlerContext fireChannelRead(Object msg);
}
</code></pre></div></div>

<p>//ChannelInboundInvoker</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * A {@link Channel} received a message.
 *通道接收一个消息
 * This will result in having the {@link ChannelInboundHandler#channelRead(ChannelHandlerContext, Object)}
 * method  called of the next {@link ChannelInboundHandler} contained in the  {@link ChannelPipeline} of the
 * {@link Channel}.
 ChannelInboundHandler#channelRead方法调用将会通知，通道所在的Channel管道线中的下一个通道处理器，接受一个消息
 */
ChannelInboundInvoker fireChannelRead(Object msg);
</code></pre></div></div>

<ol>
  <li>

    <p>//如果autoRelease为自动释放消息，且消息已处理则释放消息
ReferenceCountUtil.release(msg);</p>

    <p>//ReferenceCountUtil
    /**
     * Try to call {@link ReferenceCounted#release()} if the specified message implements {@link ReferenceCounted}.
     * If the specified message doesn’t implement {@link ReferenceCounted}, this method does nothing.
     如果消息实现了ReferenceCounted，则调用ReferenceCounted#release()，如果不是什么都不做
     */
    public static boolean release(Object msg) {
        if (msg instanceof ReferenceCounted) {
            return ((ReferenceCounted) msg).release();
        }
        return false;
    }</p>
  </li>
</ol>

<p>//ReferenceCounted</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> /**
     * Decreases the reference count by {@code 1} and deallocates this object if the reference count reaches at
     * {@code 0}.
     *自减引用计数器，如果计数器为0，则回收对象。
     * @return {@code true} if and only if the reference count became {@code 0} and this object has been deallocated
     */
    boolean release();
</code></pre></div></div>

<p>从上面来看，读操作，首先判断跟定的消息类型是否可以被处理，如果是，则委托给channelRead0，如果返回false，则将消息转递给Channel管道线的下一个通道处理器；最后，如果autoRelease为自动释放消息，且消息已处理则释放消息。</p>

<p>在简单Inbound通道处理器的构造方法：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> protected SimpleChannelInboundHandler(boolean autoRelease) {
        matcher = TypeParameterMatcher.find(this, SimpleChannelInboundHandler.class, "I");
        this.autoRelease = autoRelease;
    }
 protected SimpleChannelInboundHandler(Class&lt;? extends I&gt; inboundMessageType, boolean autoRelease) {
        matcher = TypeParameterMatcher.get(inboundMessageType);
        this.autoRelease = autoRelease;
    }
</code></pre></div></div>

<p>和acceptInboundMessage方法中</p>

<p>//判断跟定的消息类型是否可以被处理，如果返回false，则将消息转递给Channel管道线的下一个通道处理器</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> public boolean acceptInboundMessage(Object msg) throws Exception {
        return matcher.match(msg);
    }
</code></pre></div></div>

<p>涉及到一个参数类型匹配器TypeParameterMatcher，为了理解TypeParameterMatcher花了几天时间，</p>

<p>学习了一下java Type体系结构，在往下看之前，需要了解java Type体系结构，具体可以参考一下连接:</p>

<dl>
  <dt>Type —— Java类型: </dt>
  <dt><a href="https://www.jfox.info/go.php?url=http://blog.csdn.net/a327369238/article/details/52621043">http://blog.csdn.net/a327369238/article/details/52621043</a>详解Java泛型type体系整理: </dt>
  <dt><a href="https://www.jfox.info/go.php?url=http://developer.51cto.com/art/201103/250028.htm">http://developer.51cto.com/art/201103/250028.htm</a></dt>
  <dt> 黑马程序员–Java基础加强–13.利用反射操作泛型II【TypeVariable】【GenericArrayType】【WildcardType】【Type及其子接口的来历】【个人总结】</dt>
  <dd>
    <p><a href="https://www.jfox.info/go.php?url=http://blog.csdn.net/benjaminzhang666/article/details/9839007">http://blog.csdn.net/benjaminzhang666/article/details/9839007</a>泛型通配符extends与super的区别: 
<a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/yepei/p/6591289.html">http://www.cnblogs.com/yepei/p/6591289.html</a>另外附上java Type体系结构的示例地址： 
<a href="https://www.jfox.info/go.php?url=https://github.com/Donaldhan/java-base-demo">https://github.com/Donaldhan/java-base-demo</a>
本身这篇文章应该上个星期就出来呢？由于对java Type体系结构不熟，难以理解参数类型匹配器TypeParameterMatcher，所以推迟到现在，本身同时想写一篇java Type体系结构相关的文章，后来一想算了，网上很多资料，再加上自己写Demo里面有相关的说明，就不写了，一个字懒……</p>
  </dd>
</dl>

<p>言归正传，下面我们来看TypeParameterMatcher</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">internal</span><span class="p">;</span>

<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="k">Array</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">GenericArrayType</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">ParameterizedType</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">Type</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">lang</span><span class="p">.</span><span class="n">reflect</span><span class="p">.</span><span class="n">TypeVariable</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">HashMap</span><span class="p">;</span>
<span class="n">import</span> <span class="n">java</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">Map</span><span class="p">;</span>

<span class="k">public</span> <span class="n">abstract</span> <span class="n">class</span> <span class="n">TypeParameterMatcher</span> <span class="p">{</span>
    <span class="p">//</span><span class="err">默认空参数类型匹配器，匹配方法永远返回</span><span class="nb">true</span>
    <span class="n">private</span> <span class="n">static</span> <span class="n">final</span> <span class="n">TypeParameterMatcher</span> <span class="n">NOOP</span> <span class="p">=</span> <span class="n">new</span> <span class="n">TypeParameterMatcher</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">@</span><span class="n">Override</span>
        <span class="k">public</span> <span class="k">boolean</span> <span class="n">match</span><span class="p">(</span><span class="n">Object</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>
    <span class="p">//</span><span class="err">判断消息对象类型是否匹配当前类型匹配器</span>
    <span class="k">public</span> <span class="n">abstract</span> <span class="k">boolean</span> <span class="n">match</span><span class="p">(</span><span class="n">Object</span> <span class="n">msg</span><span class="p">);</span>
    <span class="p">//</span><span class="err">反射匹配器</span>
    <span class="n">private</span> <span class="n">static</span> <span class="n">final</span> <span class="n">class</span> <span class="n">ReflectiveMatcher</span> <span class="n">extends</span> <span class="n">TypeParameterMatcher</span> <span class="p">{</span>
        <span class="n">private</span> <span class="n">final</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">type</span><span class="p">;</span>

        <span class="n">ReflectiveMatcher</span><span class="p">(</span><span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">this</span><span class="p">.</span><span class="n">type</span> <span class="p">=</span> <span class="n">type</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">//</span><span class="err">根据对象是为类型</span><span class="n">Type</span><span class="err">的实例，来判断是否消息是否匹配</span>
        <span class="p">@</span><span class="n">Override</span>
        <span class="k">public</span> <span class="k">boolean</span> <span class="n">match</span><span class="p">(</span><span class="n">Object</span> <span class="n">msg</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">return</span> <span class="n">type</span><span class="p">.</span><span class="n">isInstance</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">TypeParameterMatcher</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
    <span class="p">//</span><span class="err">根据</span><span class="n">Class</span><span class="err">类型获取类型参数匹配器</span>
    <span class="k">public</span> <span class="n">static</span> <span class="n">TypeParameterMatcher</span> <span class="n">get</span><span class="p">(</span><span class="n">final</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">parameterType</span><span class="p">)</span> <span class="p">{</span>
       <span class="p">//</span><span class="err">从</span><span class="n">Netty</span><span class="err">内部线程本地</span><span class="n">Map</span><span class="err">，获取当前线程类型参数匹配器缓存</span>
        <span class="n">final</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">Class</span><span class="p">&lt;?&gt;,</span> <span class="n">TypeParameterMatcher</span><span class="p">&gt;</span> <span class="n">getCache</span> <span class="p">=</span>
                <span class="n">InternalThreadLocalMap</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">typeParameterMatcherGetCache</span><span class="p">();</span>
        <span class="p">//</span><span class="err">从类型参数匹配器缓存，获取类型</span><span class="n">parameterType</span><span class="err">对应的类型参数匹配器</span>
        <span class="n">TypeParameterMatcher</span> <span class="n">matcher</span> <span class="p">=</span> <span class="n">getCache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">parameterType</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matcher</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{//</span><span class="err">如果匹配器为空</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parameterType</span> <span class="p">==</span> <span class="n">Object</span><span class="p">.</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span><span class="err">匹配参数为</span><span class="n">Object</span><span class="err">，匹配器为</span><span class="n">NOOP</span>
                <span class="n">matcher</span> <span class="p">=</span> <span class="n">NOOP</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">matcher</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ReflectiveMatcher</span><span class="p">(</span><span class="n">parameterType</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">getCache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">parameterType</span><span class="p">,</span> <span class="n">matcher</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">return</span> <span class="n">matcher</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">//</span><span class="err">跟实例</span><span class="n">object</span><span class="err">，类型父类</span><span class="n">parametrizedSuperclass</span><span class="err">，类型参数名</span><span class="n">typeParamName</span><span class="err">，获取类型参数名</span><span class="n">object</span><span class="err">对应的类型参数匹配器</span>
    <span class="k">public</span> <span class="n">static</span> <span class="n">TypeParameterMatcher</span> <span class="n">find</span><span class="p">(</span>
            <span class="n">final</span> <span class="n">Object</span> <span class="n">object</span><span class="p">,</span> <span class="n">final</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">parametrizedSuperclass</span><span class="p">,</span> <span class="n">final</span> <span class="k">String</span> <span class="n">typeParamName</span><span class="p">)</span> <span class="p">{</span>
	<span class="p">//</span><span class="err">从</span><span class="n">Netty</span><span class="err">内部线程本地</span><span class="n">Map</span><span class="err">，获取当前线程类型参数匹配器缓存</span>
        <span class="n">final</span> <span class="n">Map</span><span class="p">&lt;</span><span class="n">Class</span><span class="p">&lt;?&gt;,</span> <span class="n">Map</span><span class="p">&lt;</span><span class="k">String</span><span class="p">,</span> <span class="n">TypeParameterMatcher</span><span class="p">&gt;&gt;</span> <span class="n">findCache</span> <span class="p">=</span>
                <span class="n">InternalThreadLocalMap</span><span class="p">.</span><span class="n">get</span><span class="p">().</span><span class="n">typeParameterMatcherFindCache</span><span class="p">();</span>
	<span class="p">//</span><span class="err">获取</span><span class="n">object</span><span class="err">类型</span>
        <span class="n">final</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">thisClass</span> <span class="p">=</span> <span class="n">object</span><span class="p">.</span><span class="nf">getClass</span><span class="p">();</span>
        <span class="p">//</span><span class="err">从类型参数匹配器缓存，获取类型</span><span class="n">thisClass</span><span class="err">对应的类型参数匹配器映射关系</span>
        <span class="n">Map</span><span class="p">&lt;</span><span class="k">String</span><span class="p">,</span> <span class="n">TypeParameterMatcher</span><span class="p">&gt;</span> <span class="n">map</span> <span class="p">=</span> <span class="n">findCache</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">thisClass</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">map</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
	    <span class="p">//</span><span class="err">如果不存在</span><span class="n">object</span><span class="err">类型对应的类型参数匹配器映射关系，则创建，并添加到缓存中</span>
            <span class="n">map</span> <span class="p">=</span> <span class="n">new</span> <span class="n">HashMap</span><span class="p">&lt;</span><span class="k">String</span><span class="p">,</span> <span class="n">TypeParameterMatcher</span><span class="p">&gt;();</span>
            <span class="n">findCache</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">thisClass</span><span class="p">,</span> <span class="n">map</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="p">//</span><span class="err">从</span><span class="n">object</span><span class="err">类型对应的类型参数匹配器</span><span class="n">Map</span><span class="err">中获取，对应的类型参数匹配器</span>
        <span class="n">TypeParameterMatcher</span> <span class="n">matcher</span> <span class="p">=</span> <span class="n">map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">typeParamName</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">matcher</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">//</span><span class="err">如果</span><span class="n">object</span><span class="err">对应的类型参数匹配器为空，则从父类中获取类型参数名对应的类型的参数匹配器</span>
            <span class="n">matcher</span> <span class="p">=</span> <span class="n">get</span><span class="p">(</span><span class="n">find0</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">parametrizedSuperclass</span><span class="p">,</span> <span class="n">typeParamName</span><span class="p">));</span>
	    <span class="p">//</span><span class="err">类型参数名和类型参数匹配器，添加到对应的映射</span><span class="n">Map</span><span class="err">中</span>
            <span class="n">map</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">typeParamName</span><span class="p">,</span> <span class="n">matcher</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">return</span> <span class="n">matcher</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">//</span><span class="err">获取</span><span class="n">obejct</span><span class="err">实际类型父类</span><span class="n">parametrizedSuperclass</span><span class="err">泛型参数中，类型参数名为</span><span class="n">typeParamName</span><span class="err">对应的原始类型</span>
    <span class="n">private</span> <span class="n">static</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">find0</span><span class="p">(</span>
            <span class="n">final</span> <span class="n">Object</span> <span class="n">object</span><span class="p">,</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">parametrizedSuperclass</span><span class="p">,</span> <span class="k">String</span> <span class="n">typeParamName</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">//</span><span class="err">获取</span><span class="n">object</span><span class="err">的类型</span>
        <span class="n">final</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">thisClass</span> <span class="p">=</span> <span class="n">object</span><span class="p">.</span><span class="nf">getClass</span><span class="p">();</span>
        <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">currentClass</span> <span class="p">=</span> <span class="n">thisClass</span><span class="p">;</span>
        <span class="n">for</span> <span class="p">(;;)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">currentClass</span><span class="p">.</span><span class="n">getSuperclass</span><span class="p">()</span> <span class="p">==</span> <span class="n">parametrizedSuperclass</span><span class="p">)</span> <span class="p">{//</span><span class="err">如果当前类型父类为</span><span class="n">parametrizedSuperclass</span>
                <span class="n">int</span> <span class="n">typeParamIndex</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
		<span class="p">//</span><span class="err">获取当前类父类的泛型类型变量</span>
                <span class="n">TypeVariable</span><span class="p">&lt;?&gt;[]</span> <span class="n">typeParams</span> <span class="p">=</span> <span class="n">currentClass</span><span class="p">.</span><span class="n">getSuperclass</span><span class="p">().</span><span class="n">getTypeParameters</span><span class="p">();</span>
                <span class="n">for</span> <span class="p">(</span><span class="n">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">typeParams</span><span class="p">.</span><span class="n">length</span><span class="p">;</span> <span class="n">i</span> <span class="p">++)</span> <span class="p">{</span>
		     <span class="p">//</span><span class="err">寻找类型参数名对应的类型变量，如果找到，则记录类型变量索引位置</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">typeParamName</span><span class="p">.</span><span class="n">equals</span><span class="p">(</span><span class="n">typeParams</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getName</span><span class="p">()))</span> <span class="p">{</span>
                        <span class="n">typeParamIndex</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="p">//</span><span class="err">如果索引为位置小于</span><span class="m">0</span><span class="err">，即，在</span><span class="n">object</span><span class="err">类型父类的类型变量中没有找到</span><span class="n">typeParamName</span><span class="err">对应的类型变量</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">typeParamIndex</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">throw</span> <span class="n">new</span> <span class="n">IllegalStateException</span><span class="p">(</span>
                            <span class="s2">"unknown type parameter '"</span> <span class="p">+</span> <span class="n">typeParamName</span> <span class="p">+</span> <span class="s2">"': "</span> <span class="p">+</span> <span class="n">parametrizedSuperclass</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="p">//</span><span class="err">获取当前类的父类泛型类型</span>
                <span class="n">Type</span> <span class="n">genericSuperType</span> <span class="p">=</span> <span class="n">currentClass</span><span class="p">.</span><span class="n">getGenericSuperclass</span><span class="p">();</span>
                <span class="k">if</span> <span class="p">(</span><span class="c1">!(genericSuperType instanceof ParameterizedType)) {
</span>	            <span class="p">//</span><span class="err">如果父类的泛型类型非参数化类型，则返回</span><span class="n">Object</span><span class="err">类型</span>
                    <span class="n">return</span> <span class="n">Object</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="p">//</span><span class="err">获取父类的实际类型参数</span>
                <span class="n">Type</span><span class="p">[]</span> <span class="n">actualTypeParams</span> <span class="p">=</span> <span class="p">((</span><span class="n">ParameterizedType</span><span class="p">)</span> <span class="n">genericSuperType</span><span class="p">).</span><span class="n">getActualTypeArguments</span><span class="p">();</span>
                <span class="n">Type</span> <span class="n">actualTypeParam</span> <span class="p">=</span> <span class="n">actualTypeParams</span><span class="p">[</span><span class="n">typeParamIndex</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">actualTypeParam</span> <span class="n">instanceof</span> <span class="n">ParameterizedType</span><span class="p">)</span> <span class="p">{</span>
		    <span class="p">//</span><span class="err">如果实际类型参数为参数化类型，则获取实际类型参数的原始类型</span><span class="n">RawType</span><span class="err">（不包括泛型部分）</span>
                    <span class="n">actualTypeParam</span> <span class="p">=</span> <span class="p">((</span><span class="n">ParameterizedType</span><span class="p">)</span> <span class="n">actualTypeParam</span><span class="p">).</span><span class="n">getRawType</span><span class="p">();</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">actualTypeParam</span> <span class="n">instanceof</span> <span class="n">Class</span><span class="p">)</span> <span class="p">{</span>
		   <span class="p">//</span><span class="err">如果实际类型为</span><span class="n">Class</span><span class="err">，则直接返回</span><span class="n">Class</span>
                    <span class="n">return</span> <span class="p">(</span><span class="n">Class</span><span class="p">&lt;?&gt;)</span> <span class="n">actualTypeParam</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">actualTypeParam</span> <span class="n">instanceof</span> <span class="n">GenericArrayType</span><span class="p">)</span> <span class="p">{</span>
		    <span class="p">//</span><span class="err">如果实际类型参数为泛型数组类型，获取泛型数组类型的泛型组件类型</span><span class="n">GenericComponentType</span>
                    <span class="n">Type</span> <span class="n">componentType</span> <span class="p">=</span> <span class="p">((</span><span class="n">GenericArrayType</span><span class="p">)</span> <span class="n">actualTypeParam</span><span class="p">).</span><span class="n">getGenericComponentType</span><span class="p">();</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">componentType</span> <span class="n">instanceof</span> <span class="n">ParameterizedType</span><span class="p">)</span> <span class="p">{</span>
			<span class="err">如果组件类型为参数化类型，则组件类型为原始类型</span><span class="n">RawType</span>
                        <span class="n">componentType</span> <span class="p">=</span> <span class="p">((</span><span class="n">ParameterizedType</span><span class="p">)</span> <span class="n">componentType</span><span class="p">).</span><span class="n">getRawType</span><span class="p">();</span>
                    <span class="p">}</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">componentType</span> <span class="n">instanceof</span> <span class="n">Class</span><span class="p">)</span> <span class="p">{</span>
		        <span class="p">//</span><span class="err">如果组件类型为</span><span class="n">Class</span><span class="err">，则创建对应的数组实例，并获取实例的类型</span>
                        <span class="n">return</span> <span class="k">Array</span><span class="p">.</span><span class="n">newInstance</span><span class="p">((</span><span class="n">Class</span><span class="p">&lt;?&gt;)</span> <span class="n">componentType</span><span class="p">,</span> <span class="m">0</span><span class="p">).</span><span class="nf">getClass</span><span class="p">();</span>
                    <span class="p">}</span>
                <span class="p">}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">actualTypeParam</span> <span class="n">instanceof</span> <span class="n">TypeVariable</span><span class="p">)</span> <span class="p">{</span>
		   <span class="p">//</span><span class="err">如果实际类型参数为类型变量，转化实际类型参数为类型变量</span>
                    <span class="p">//</span> <span class="n">Resolved</span> <span class="n">type</span> <span class="n">parameter</span> <span class="n">points</span> <span class="k">to</span> <span class="n">another</span> <span class="n">type</span> <span class="n">parameter</span><span class="p">.</span>
                    <span class="n">TypeVariable</span><span class="p">&lt;?&gt;</span> <span class="n">v</span> <span class="p">=</span> <span class="p">(</span><span class="n">TypeVariable</span><span class="p">&lt;?&gt;)</span> <span class="n">actualTypeParam</span><span class="p">;</span>
                    <span class="n">currentClass</span> <span class="p">=</span> <span class="n">thisClass</span><span class="p">;</span>
                    <span class="k">if</span> <span class="p">(</span><span class="c1">!(v.getGenericDeclaration() instanceof Class)) {
</span>		        <span class="p">//</span><span class="err">如果类型变量的声明类不是</span><span class="n">Class</span><span class="err">，则返回</span><span class="n">Object</span><span class="err">类型</span>
                        <span class="n">return</span> <span class="n">Object</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
                    <span class="p">}</span>
                    <span class="p">//</span><span class="err">参数化父类的类型为，类型变量</span><span class="n">v</span><span class="err">的声明类</span>
                    <span class="n">parametrizedSuperclass</span> <span class="p">=</span> <span class="p">(</span><span class="n">Class</span><span class="p">&lt;?&gt;)</span> <span class="n">v</span><span class="p">.</span><span class="n">getGenericDeclaration</span><span class="p">();</span>
		    <span class="p">//</span><span class="err">获取类型变量名称</span>
                    <span class="n">typeParamName</span> <span class="p">=</span> <span class="n">v</span><span class="p">.</span><span class="n">getName</span><span class="p">();</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">parametrizedSuperclass</span><span class="p">.</span><span class="n">isAssignableFrom</span><span class="p">(</span><span class="n">thisClass</span><span class="p">))</span> <span class="p">{</span>
		        <span class="p">//</span><span class="err">如果参数类型父类为</span><span class="n">thisClass</span><span class="err">类型，则跳出当前循环</span>
                        <span class="n">continue</span><span class="p">;</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		        <span class="p">//</span><span class="err">否则返回</span><span class="n">Object</span><span class="err">类型</span>
                        <span class="n">return</span> <span class="n">Object</span><span class="p">.</span><span class="n">class</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>

                <span class="n">return</span> <span class="n">fail</span><span class="p">(</span><span class="n">thisClass</span><span class="p">,</span> <span class="n">typeParamName</span><span class="p">);</span>
            <span class="p">}</span>
	    <span class="p">//</span><span class="err">否则获取当前类型的父类</span>
            <span class="n">currentClass</span> <span class="p">=</span> <span class="n">currentClass</span><span class="p">.</span><span class="n">getSuperclass</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">currentClass</span> <span class="p">==</span> <span class="n">null</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">return</span> <span class="n">fail</span><span class="p">(</span><span class="n">thisClass</span><span class="p">,</span> <span class="n">typeParamName</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">//</span><span class="err">找不到类型参数名对应的类型，则抛出非法状态异常</span>
    <span class="n">private</span> <span class="n">static</span> <span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">fail</span><span class="p">(</span><span class="n">Class</span><span class="p">&lt;?&gt;</span> <span class="n">type</span><span class="p">,</span> <span class="k">String</span> <span class="n">typeParamName</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">throw</span> <span class="n">new</span> <span class="n">IllegalStateException</span><span class="p">(</span>
                <span class="s2">"cannot determine the type of the type parameter '"</span> <span class="p">+</span> <span class="n">typeParamName</span> <span class="p">+</span> <span class="s2">"': "</span> <span class="p">+</span> <span class="n">type</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>这个类型参数匹配器就不说了，各种变量的叫法，容易搞混，要结合代码注释看。</p>

<p>简单小节一下：</p>

<p>类型参数匹配器，作用主要主要是判断实例的类型是否为类型参数匹配器对应类型的实例，是则返回ture，否返回false。主要是用于，当通道读取消息对象时，判断通道是不可以处理此消息对象。</p>

<p>get方法：根据Class类型获取类型参数匹配器，首先从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存，从类型参数匹配器缓存，获取参数类型parameterType对应的类型参数匹配器，如果匹配器为空且匹配参数为Object，则匹配器为NOOP，否则，根据参数类型创建ReflectiveMatcher添加到缓存中。</p>

<p>find方法：跟实例object，类型父类parametrizedSuperclass，类型参数名typeParamName，</p>

<p>获取类型参数名object对应的类型参数匹配器，首先从Netty内部线程本地Map，获取当前线程类型参数匹配器缓存，从类型参数匹配器缓存，获取objec类型thisClass对应的类型参数匹配器映射关系，如果不存在object类型对应的类型参数匹配器映射关系，则创建，并添加到缓存中，否则，从object类型对应的类型参数匹配器Map中获取，对应的类型参数匹配器，如果object对应的类型参数匹配器为空，则从父类中获取类型参数名对应的类型的参数匹配器（find0方法获取类型参数名对应的原始类），并将类型与从父类中获取匹配器映射关系，添加到缓存中，否则直接返回匹配器。</p>

<p>find0方法：获取obejct实际类型父类parametrizedSuperclass泛型参数中，类型参数名为typeParamName对应的原始类型过程为，首先获取object的类型currentClass，如果当前类型currentClass的父类为parametrizedSuperclass，获取当前类父类的泛型类型变量，寻找类型参数名对应的类型变量，如果找到，则记录类型变量索引位置，如果索引为位置小于0，即，在object类型父类的类型变量中没有找到typeParamName对应的类型变量，否则，获取当前类的父类泛型类型，如果父类的泛型类型非参数化类型，则返回Object类型，否则，获取父类的实际类型参数，如果实际类型参数为参数化类型，则获取索引对应实际类型参数的原始类型RawType，</p>

<p>如果实际类型为Class，则直接返回Class，如果实际类型参数为泛型数组类型，获取泛型数组类型的泛型组件类型GenericComponentType，如果组件类型为参数化类型，则组件类型为原始类型RawType，如果组件类型为Class，则创建对应的数组实例，并获取实例的类型，如果实际类型参数为类型变量，转化实际类型参数为类型变量v，如果类型变量的声明类不是Class，则返回Object类型，否则设置参数化父类的类型为类型变量v的声明类，如果参数类型父类为thisClass类型，则跳出当前循环，否则返回Object类型，这时，当前类型currentClass的父类为parametrizedSuperclas的情况结束；如果父类不为parametrizedSuperclas，则获取currentClass父类，并设置为当前类继续自旋。自旋的目的是，找到与parametrizedSuperclas类型相等的object类型或父类型。</p>

<p>**
总结：**简单Inbound通道处理器SimpleChannelInboundHandler<i>，内部有连个变量一个为参数类型匹配器，用来判断通道是否可以处理消息，另一个变量autoRelease，用于控制是否在通道处理消息完毕时，释放消息。读取方法channelRead，首先判断跟定的消息类型是否可以被处理，如果是，则委托给channelRead0，channelRead0待子类实现；如果返回false，则将消息转递给Channel管道线的下一个通道处理器；最后，如果autoRelease为自动释放消息，且消息已处理则释放消息。</i></p>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/netty%E7%AE%80%E5%8D%95inbound%E4%BF%A1%E9%81%93%E5%A4%84%E7%90%86%E5%99%A8simplechannelinboundhandler.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/nodejs%E5%9F%BA%E9%87%91%E4%BC%9A2017%E7%94%A8%E6%88%B7%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A%E8%BF%91%E4%B8%80%E5%8D%8A%E7%94%A8%E6%88%B7%E6%98%AF%E8%8F%9C%E9%B8%9F.html">&laquo; Node.js基金会2017用户调查报告：近一半用户是菜鸟</a>
  
  
  <a class="next" href="/2017/spring1spring%E4%B8%AD%E7%9A%84%E7%9B%91%E5%90%AC%E5%99%A8listener.html">【Spring】1、Spring 中的监听器 Listener &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
