<!-- build time:Sat Oct 27 2018 21:00:20 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="版权声明：本文为博主原创文章，转载请注明出处，欢迎交流学习！   接着上一章节的内容，我们来分析当new一个FileSystemXmlApplicationContext对象的时候，spring到底做了那些事。FileSystemXmlApplicationContext类的内容主要是定义了若干重载的构造方法，核心构造方法如下：  /**      * Create a new FileSyste"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="Spring源码：IOC原理解析（二）"><meta property="og:url" content="http://www.jfox.info/2017/spring源码ioc原理解析二.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="版权声明：本文为博主原创文章，转载请注明出处，欢迎交流学习！   接着上一章节的内容，我们来分析当new一个FileSystemXmlApplicationContext对象的时候，spring到底做了那些事。FileSystemXmlApplicationContext类的内容主要是定义了若干重载的构造方法，核心构造方法如下：  /**      * Create a new FileSyste"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.406Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Spring源码：IOC原理解析（二）"><meta name="twitter:description" content="版权声明：本文为博主原创文章，转载请注明出处，欢迎交流学习！   接着上一章节的内容，我们来分析当new一个FileSystemXmlApplicationContext对象的时候，spring到底做了那些事。FileSystemXmlApplicationContext类的内容主要是定义了若干重载的构造方法，核心构造方法如下：  /**      * Create a new FileSyste"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/spring源码ioc原理解析二.html"><title>Spring源码：IOC原理解析（二） | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/spring源码ioc原理解析二.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Spring源码：IOC原理解析（二）</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:54:13+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>版权声明：本文为博主原创文章，转载请注明出处，欢迎交流学习！</p><pre><code>   接着上一章节的内容，我们来分析当new一个FileSystemXmlApplicationContext对象的时候，spring到底做了那些事。FileSystemXmlApplicationContext类的内容主要是定义了若干重载的构造方法，核心构造方法如下：

/**
     * Create a new FileSystemXmlApplicationContext with the given parent,
     * loading the definitions from the given XML files.
     * 
     * loading all bean definitions and creating all singletons.
     * Alternatively, call refresh manually after further configuring the context.
     * 
     */public FileSystemXmlApplicationContext(
            String[] configLocations, boolean refresh, @Nullable ApplicationContext parent)
            throws BeansException {

        super(parent);
        setConfigLocations(configLocations);
        if (refresh) {
            refresh();
        }
    }

   从方法说明可以看出，在这个构造方法里加载所有bean定义并创建bean单例实例。其中的refresh()方法就是IOC容器初始化的入口，refresh()方法位AbstractApplicationContext类中，这是一个抽象类，它实现了ApplicationContext的基础功能，这里使用了模版方法模式，给实现它的子类提供了统一的模板：

@Override
    publicvoid refresh() throws BeansException, IllegalStateException {
        synchronized (this.startupShutdownMonitor) {
            // Prepare this context for refreshing.            prepareRefresh();

            // Tell the subclass to refresh the internal bean factory.告诉子类刷新内部bean工厂
            ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

            // Prepare the bean factory for use in this context.            prepareBeanFactory(beanFactory);

            try {
                // Allows post-processing of the bean factory in context subclasses.                postProcessBeanFactory(beanFactory);

                // Invoke factory processors registered as beans in the context.                invokeBeanFactoryPostProcessors(beanFactory);

                // Register bean processors that intercept bean creation.                registerBeanPostProcessors(beanFactory);

                // Initialize message source for this context.                initMessageSource();

                // Initialize event multicaster for this context.                initApplicationEventMulticaster();

                // Initialize other special beans in specific context subclasses.                onRefresh();

                // Check for listener beans and register them.                registerListeners();

                // Instantiate all remaining (non-lazy-init) singletons.                finishBeanFactoryInitialization(beanFactory);

                // Last step: publish corresponding event.                finishRefresh();
            }

            catch (BeansException ex) {
                if (logger.isWarnEnabled()) {
                    logger.warn(&quot;Exception encountered during context initialization - &quot; +
                            &quot;cancelling refresh attempt: &quot; + ex);
                }

                // Destroy already created singletons to avoid dangling resources.                destroyBeans();

                // Reset &apos;active&apos; flag.                cancelRefresh(ex);

                // Propagate exception to caller.throw ex;
            }

            finally {
                // Reset common introspection caches in Spring&apos;s core, since we
                // might not ever need metadata for singleton beans anymore...                resetCommonCaches();
            }
        }
    }

   refresh()方法里列出了IOC容器初始化的步骤，第一个方法是初始化准备，这里只是设置启动日期和活动标识以及执行属性源的初始化。我们重点看第二个方法obtainFreshBeanFactory()，它告诉子类刷新内部bean工厂，返回了一个ConfigurableListableBeanFactory，跟踪这个方法：

/**
     * Tell the subclass to refresh the internal bean factory.
     * @return the fresh BeanFactory instance
     * @see #refreshBeanFactory()
     * @see #getBeanFactory()
     */protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
        refreshBeanFactory();
        ConfigurableListableBeanFactory beanFactory = getBeanFactory();
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Bean factory for &quot; + getDisplayName() + &quot;: &quot; + beanFactory);
        }
        return beanFactory;
    }

protectedabstractvoid refreshBeanFactory() throws BeansException, IllegalStateException;

/**
     * Return the internal bean factory of this application context.
     * Can be used to access specific functionality of the underlying factory.
     * 
     */
    ConfigurableListableBeanFactory getBeanFactory() throws IllegalStateException;

   obtainFreshBeanFactory()方法的第一行调用了refreshBeanFactory()方法，这是一个抽象方法，由它的子类来实现，方法的第二行调用了getBeanFactory()，这是在其父接口中定义的一个空方法。抽象方法refreshBeanFactory()在其子类子类AbstractRefreshableApplicationContext中实现：

   这个方法被final关键字修饰，也就是说不可以被重写，IOC容器的初始化就是在这个方法中完成的。第一步先判断有没有现有的工厂，有的话就销毁掉，然后创建一个默认的工厂，也就是DefaultListableBeanFactory ，接下来两行代码是设置bean工厂的一些属性，注意看loadBeanDefinitions(beanFactory)这行，当创建了一个默认的bean工厂后，加载bean定义，这跟我们上一章节使用原始方式初始化bean工厂类似。从这里不难看出，FileSystemXmlApplicationContext的构造方法中其实已经包含了我们上一章节中原始的初始化过程。接下来我们跟踪一下loadBeanDefinitions(beanFactory)的实现，这个方法是由AbstractXmlApplicationContext抽象类实现的：

/**
     * Loads the bean definitions via an XmlBeanDefinitionReader.装载bean定义通过XmlBeanDefinitionReader
     *
     */
    @Override
    protectedvoid loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
        // Create a new XmlBeanDefinitionReader for the given BeanFactory.
        XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

        // Configure the bean definition reader with this context&apos;s
        // resource loading environment.
        beanDefinitionReader.setEnvironment(this.getEnvironment());
        beanDefinitionReader.setResourceLoader(this);
        beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

        // Allow a subclass to provide custom initialization of the reader,
        // then proceed with actually loading the bean definitions.        initBeanDefinitionReader(beanDefinitionReader);
        loadBeanDefinitions(beanDefinitionReader);
    }

   方法的第一行首先定义了一个Reader，这个Reader就是用来读取xml配置文件的，最后一行就是真正载入bean定义的实现过程，代码如下：

/**
     * Load the bean definitions with the given XmlBeanDefinitionReader.
     * 
     */protectedvoid loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
        Resource[] configResources = getConfigResources();
        if (configResources != null) {
            reader.loadBeanDefinitions(configResources);
        }
        String[] configLocations = getConfigLocations();
        if (configLocations != null) {
            reader.loadBeanDefinitions(configLocations);
        }
    }

   上面的方法调用了XmlBeanDefinitionReader类的loadBeanDefinitions(EncodedResource encodedResource)方法：

/**
     * Load bean definitions from the specified XML file.
     * rows BeanDefinitionStoreException in case of loading or parsing errors
     */publicint loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException {
        Assert.notNull(encodedResource, &quot;EncodedResource must not be null&quot;);
        if (logger.isInfoEnabled()) {
            logger.info(&quot;Loading XML bean definitions from &quot; + encodedResource.getResource());
        }

        Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get();
        if (currentResources == null) {
            currentResources = new HashSet&lt;&gt;(4);
            this.resourcesCurrentlyBeingLoaded.set(currentResources);
        }
        if (!currentResources.add(encodedResource)) {
            thrownew BeanDefinitionStoreException(
                    &quot;Detected cyclic loading of &quot; + encodedResource + &quot; - check your import definitions!&quot;);
        }
        try {
            InputStream inputStream = encodedResource.getResource().getInputStream();
            try {
                InputSource inputSource = new InputSource(inputStream);
                if (encodedResource.getEncoding() != null) {
                    inputSource.setEncoding(encodedResource.getEncoding());
                }
                return doLoadBeanDefinitions(inputSource, encodedResource.getResource());
            }
            finally {
                inputStream.close();
            }
        }
        catch (IOException ex) {
            thrownew BeanDefinitionStoreException(
                    &quot;IOException parsing XML document from &quot; + encodedResource.getResource(), ex);
        }
        finally {
            currentResources.remove(encodedResource);
            if (currentResources.isEmpty()) {
                this.resourcesCurrentlyBeingLoaded.remove();
            }
        }
    }

   从方法说明可以看出，这个方法是从指定的xml文件中加载bean定义，try块中的代码才是载入bean定义的过程。spring将资源返回的输入流包装以后传给了doLoadBeanDefinitions()方法，我们进入这个方法，代码如下：

/**
     * Actually load bean definitions from the specified XML file.
     * 
     */protectedint doLoadBeanDefinitions(InputSource inputSource, Resource resource)
            throws BeanDefinitionStoreException {
        try {
            Document doc = doLoadDocument(inputSource, resource);
            return registerBeanDefinitions(doc, resource);
        }
        catch (BeanDefinitionStoreException ex) {
            throw ex;
        }
        catch (SAXParseException ex) {
            thrownew XmlBeanDefinitionStoreException(resource.getDescription(),
                    &quot;Line &quot; + ex.getLineNumber() + &quot; in XML document from &quot; + resource + &quot; is invalid&quot;, ex);
        }
        catch (SAXException ex) {
            thrownew XmlBeanDefinitionStoreException(resource.getDescription(),
                    &quot;XML document from &quot; + resource + &quot; is invalid&quot;, ex);
        }
        catch (ParserConfigurationException ex) {
            thrownew BeanDefinitionStoreException(resource.getDescription(),
                    &quot;Parser configuration exception parsing XML from &quot; + resource, ex);
        }
        catch (IOException ex) {
            thrownew BeanDefinitionStoreException(resource.getDescription(),
                    &quot;IOException parsing XML document from &quot; + resource, ex);
        }
        catch (Throwable ex) {
            thrownew BeanDefinitionStoreException(resource.getDescription(),
                    &quot;Unexpected exception parsing XML document from &quot; + resource, ex);
        }
    }

/**
     * Actually load the specified document using the configured DocumentLoader.
     * 
     */protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception {
        returnthis.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler,
                getValidationModeForResource(resource), isNamespaceAware());
    }

   从try块中的代码可以看出，spring使用documentLoader将资源转换成了Document资源，spring使用的documentLoader为DefaultDocumentLoader，loadDocument方法定义在此类中：

/**
     * Load the {@link Document} at the supplied {@link InputSource} using the standard JAXP-configured
     * XML parser.
     */
    @Override
    public Document loadDocument(InputSource inputSource, EntityResolver entityResolver,
            ErrorHandler errorHandler, int validationMode, boolean namespaceAware) throws Exception {

        DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Using JAXP provider [&quot; + factory.getClass().getName() + &quot;]&quot;);
        }
        DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler);
        return builder.parse(inputSource);
    }

   从这里不难看出，这就是我们非常熟悉的DOM解析xml了，可以想象spring是根据XSD文件规定的格式解析了xml文件的各节点及属性。我们再来回头看看registerBeanDefinitions(doc, resource)方法，

/**
     * Register the bean definitions contained in the given DOM document.
     * Called by {@code loadBeanDefinitions}.
     * 
     */publicint registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException {
        BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();
        int countBefore = getRegistry().getBeanDefinitionCount();
        documentReader.registerBeanDefinitions(doc, createReaderContext(resource));
        return getRegistry().getBeanDefinitionCount() - countBefore;
    }

   方法说明很明确的告诉我们，这个方法是注册给定的DOM文档中包含的bean定义。到这里思路就很明确了，spring将包装的输入流解析成DOM文档，然后将DOM中包含的bean定义信息注册到IOC容器持有的Map&lt;String，BeanDefinition&gt;对象中。只要我们的IOC容器持有了bean定义，就能正确的生产bean实例。

   通过阅读源码，我们分析了Spring IOC的实现原理。有些实现细节并没有去深究，更重要的是去理解它的核心思想和实现思路。
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/动态代理案例1运用proxy动态代理来增强方法.html" rel="next" title="动态代理案例1:运用Proxy动态代理来增强方法"><i class="fa fa-chevron-left"></i> 动态代理案例1:运用Proxy动态代理来增强方法</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/这些年我们处理过的跨域.html" rel="prev" title="这些年我们处理过的跨域">这些年我们处理过的跨域 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->