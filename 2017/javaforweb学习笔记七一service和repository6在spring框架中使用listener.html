<!-- build time:Sat Oct 27 2018 21:00:19 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="Listener是Servlet的，不属于Spring framework，也就是说我们无法在Listener中主动注入Spring bean。本学习将解决这个问题。进一步了解Spring的bean注入在解决之前，我们先进一步了解Spring的注入机制。在Spring中，我们可以使用@Inject，@Anwired，@Resource等方式实现对自动扫描和自动注入。 同一上下文环境中，bean只实"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="Java for Web学习笔记（七一）：Service和Repository（6）在Spring框架中使用Listener"><meta property="og:url" content="http://www.jfox.info/2017/javaforweb学习笔记七一service和repository6在spring框架中使用listener.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="Listener是Servlet的，不属于Spring framework，也就是说我们无法在Listener中主动注入Spring bean。本学习将解决这个问题。进一步了解Spring的bean注入在解决之前，我们先进一步了解Spring的注入机制。在Spring中，我们可以使用@Inject，@Anwired，@Resource等方式实现对自动扫描和自动注入。 同一上下文环境中，bean只实"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.414Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java for Web学习笔记（七一）：Service和Repository（6）在Spring框架中使用Listener"><meta name="twitter:description" content="Listener是Servlet的，不属于Spring framework，也就是说我们无法在Listener中主动注入Spring bean。本学习将解决这个问题。进一步了解Spring的bean注入在解决之前，我们先进一步了解Spring的注入机制。在Spring中，我们可以使用@Inject，@Anwired，@Resource等方式实现对自动扫描和自动注入。 同一上下文环境中，bean只实"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/javaforweb学习笔记七一service和repository6在spring框架中使用listener.html"><title>Java for Web学习笔记（七一）：Service和Repository（6）在Spring框架中使用Listener | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/javaforweb学习笔记七一service和repository6在spring框架中使用listener.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">Java for Web学习笔记（七一）：Service和Repository（6）在Spring框架中使用Listener</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:55:15+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>Listener是Servlet的，不属于Spring framework，也就是说我们无法在Listener中主动注入Spring bean。本学习将解决这个问题。</p><h2 id="进一步了解Spring的bean注入"><a href="#进一步了解Spring的bean注入" class="headerlink" title="进一步了解Spring的bean注入"></a>进一步了解Spring的bean注入</h2><p>在解决之前，我们先进一步了解Spring的注入机制。在Spring中，我们可以使用@Inject，@Anwired，@Resource等方式实现对自动扫描和自动注入。 同一上下文环境中，bean只实例化一次，在不同类中注入的，都是同一个bean（同一对象） 。我们通常在根上下文中进行扫描，即使我们在不同的类中都进行注入，实际是注入的是同一个对象的。</p><p>我们将通过小测试来验证这点。</p><h3 id="小测试：设置Service"><a href="#小测试：设置Service" class="headerlink" title="小测试：设置Service"></a>小测试：设置Service</h3><p>设置一个简单的Service，打印对象地址，同时在构造函数中给出log，看看在哪个阶段进行实例化。</p><pre><code>public interface MyTestService {
    public void whoAmI(String className);
}

@Service
public class MyTestServiceImpl implements MyTestService{
    private static final Logger log = LogManager.getLogger();

    public MyTestServiceImpl(){
        log.info(&quot;MyTestServiceImpl instance is created, address is &quot; + this);
    }

    @Override
    public void whoAmI(String className) {
        log.info(&quot;{} : {}&quot; , className,this);        
    }
}
</code></pre><h3 id="小测试：注入该Service"><a href="#小测试：注入该Service" class="headerlink" title="小测试：注入该Service"></a>小测试：注入该Service</h3><p>在AuthenticationController中</p><pre><code>@Controller
public class AuthenticationController {
    @Inject private AuthenticationService authenticationService;

    @RequestMapping(value=&quot;login&quot;,method=RequestMethod.GET)
    public ModelAndView login(Map&lt;String,Object&gt; model,HttpSession session){
        myTestService.whoAmI(this.getClass().getName());
        ... ... 
    }
    ... ... 
}
</code></pre><p>在TicketController中</p><pre><code>@Controller
@RequestMapping(&quot;ticket&quot;)
public class TicketController {
    @Inject private MyTestService myTestService;

    @RequestMapping(value = {&quot;&quot;, &quot;list&quot;}, method = RequestMethod.GET)
    public String list(Map&lt;String,Object&gt; model){
        this.myTestService.whoAmI(this.getClass().getName());
        ... ... 
    }
}
</code></pre><p>输出结果：</p><pre><code>14:19:19.985 [localhost-startStop-1] [INFO ] (Spring) ContextLoader - Root WebApplicationContext: initialization started
... ...
14:19:20.633 [localhost-startStop-1] [INFO ] (Spring) AutowiredAnnotationBeanPostProcessor - JSR-330 &apos;javax.inject.Inject&apos; annotation found and supported for autowiring
14:19:20.934 [localhost-startStop-1]  [INFO ] MyTestServiceImpl:12 &lt;init&gt;() - MyTestServiceImpl instance is created, address is cn.wei.flowingflying.customer_support.site.test.MyTestServiceImpl@407cec
... ...
六月 23, 2017 2:19:21 下午 org.apache.catalina.core.ApplicationContext log
信息: Initializing Spring FrameworkServlet &apos;springDispatcher&apos;
... ...
14:19:23.217 [http-nio-8080-exec-5]  [INFO ] MyTestServiceImpl:16 whoAmI() - cn.wei.flowingflying.customer_support.site.AuthenticationController : cn.wei.flowingflying.customer_support.site.test.MyTestServiceImpl@407cec
... ...
14:19:36.195 [http-nio-8080-exec-8] wei [INFO ] MyTestServiceImpl:16 whoAmI() - cn.wei.flowingflying.customer_support.site.TicketController : cn.wei.flowingflying.customer_support.site.test.MyTestServiceImpl@407cec
</code></pre><p>我们看到在AuthenticationController和TicketController中注入的对象实际地址一样，都是407cec，即为同一对象,是在Root Context中被实例化，且只实例化一次。了解这点非常重要，不同Controller对某个注入的Service进行操作，是可能相互影响的。</p><h2 id="在Listener-中实现注入实例"><a href="#在Listener-中实现注入实例" class="headerlink" title="在Listener 中实现注入实例"></a>在Listener 中实现注入实例</h2><h3 id="无法直接在Listener中自动注入"><a href="#无法直接在Listener中自动注入" class="headerlink" title="无法直接在Listener中自动注入"></a>无法直接在Listener中自动注入</h3><p>Listener是Serlvet container的，不是Spring framework的，不是任何的Spring Component，不在自动扫描的范围内，我们在里面标记的任何@Inject不会被注入。</p><p>我们创建一个Session Listener作测试</p><pre><code>@WebListener
public class WeiTempListener implements HttpSessionListener {
    private static final Logger log = LogManager.getLogger();
    @Inject private MyTestService myTestService;

    public WeiTempListener() { }

    public void sessionCreated(HttpSessionEvent se)  { 
        log.info(&quot;------------------------------------&quot;);
        this.myTestService.whoAmI(this.getClass().getName());
    }

    public void sessionDestroyed(HttpSessionEvent se)  { }
}

14:50:31.164 [http-nio-8080-exec-4]  [INFO ] WeiTempListener:32 sessionCreated() - ------------------------------------
六月 23, 2017 2:50:31 下午 org.apache.catalina.session.StandardSession tellNew 
严重: Session event listener threw exception
java.lang.NullPointerException
      at cn.wei.flowingflying.customer_support.site.WeiTempListener.sessionCreated(WeiTempListener.java:33)
</code></pre><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>前面已经看到注入的实例化是在Root Context中进行。我们需要在Listener的初始化过程中，想办法从Root Context中获得实例。我们需要：</p><ol><li>跟踪发现，Listener的初始化是RootContext的初始化之前，这时是无法获取bean的。因此</li></ol><ul><li>删除 @WebListener的标记，否则无法确保初始化的顺序</li><li>在BootStrap中，在Root Context的初始化后加载Listener，确保能够获取在Root Context中实例化的bean</li></ul><ol start="2"><li>HttpSessionListener封装很好，不开放初始化接口，因此需要增加继承ServletContextListener，以便暴露初始化的方法，在初始化中作为bean。</li><li><p>使用org.springframework.beans.factory.annotation.Configurable标注对于非Spring管理的bean。</p><p>public class BootStrap implements WebApplicationInitializer{</p><pre><code>@Override
public void onStartup(ServletContext container) throws ServletException {
    container.getServletRegistration(&quot;default&quot;).addMapping(&quot;/resource/*&quot;);

    AnnotationConfigWebApplicationContext rootContext =  new AnnotationConfigWebApplicationContext();
    rootContext.register(RootContextConfiguration.class);
    container.addListener(new ContextLoaderListener(rootContext));
    //【1】设置Listener的加载位置，在完成Root Context之后
    container.addListener(WeiTempListener.class);
    ... ...
}
</code></pre><p>}</p></li></ol><p>我们再看看WeiTempListener</p><pre><code>//【1】删除@WebListener标记，采用手动在BootStrap中加入
//【2】增加ServletContextListener接口，以获得初始化入口
public class WeiTempListener implements HttpSessionListener,ServletContextListener {
    private static final Logger log = LogManager.getLogger();
    @Inject private MyTestService myTestService;

    public WeiTempListener() {
        // 这在Root Context初始化之前执行，因此我们不能在构造函数中进行设置
        log.info(&quot;-----------------WeiTempListener-------------------&quot;);
    }

    public void sessionCreated(HttpSessionEvent se)  {         
        this.myTestService.whoAmI(this.getClass().getName());  // 测试
    }

    public void sessionDestroyed(HttpSessionEvent se)  {    }

    //【3】在contextInitialized()中获得Spring的rootContext实例
    @Override
    public void contextInitialized(ServletContextEvent event) {
        // 根据BoorStrap的执行顺序，这时RootContext的初始化已经完成，包括Service的实例化，可以注入。
        // 无法自动注入是因为Listerner并不是Spring的bean（如不是@Controller），我们要想办法手动让Listerner成为bean。
        // （1）获取Spring的root WebApplicationContext
        WebApplicationContext rootContext = 
                    WebApplicationContextUtils.getRequiredWebApplicationContext(event.getServletContext());
        // （2）获取根上下文扫描和注入bean的factory
        AutowireCapableBeanFactory factory = rootContext.getAutowireCapableBeanFactory();
        // （3）无法扫描是因为Listener不是Spring的bean，类上没有加spring的annotation，我们需要手动设置这个对象（this）作为Factory中的一个bean，这样才能对里面的属性进行注入
        factory.autowireBeanProperties(this, AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE,true);
        // （4）在factory中对这个新的bean进行初始化。
        factory.initializeBean(this,&quot;WeiTempListener&quot;);
        log.info(this.myTestService); //测试一下注入情况 
    }

    public void contextDestroyed(ServletContextEvent sce) { }
}
</code></pre><h3 id="限制说明"><a href="#限制说明" class="headerlink" title="限制说明"></a>限制说明</h3><p>虽然我们将Listener手动设置为fatory可以认识的bean，但仍不是spring下一个真正意义的bean。其他的bean中不能将其注入，部分地我们可以通过factory的registerSingleton()，将其设置为singleton bean来解决（即确保注入的都是同一的bean），但依然收到限制，有些内容仍无法正常执行，如计划执行，构造后和注销前的回调函数。</p><h2 id="SessionListener的具体应用例子"><a href="#SessionListener的具体应用例子" class="headerlink" title="SessionListener的具体应用例子"></a>SessionListener的具体应用例子</h2><h3 id="webSocket-chat例子"><a href="#webSocket-chat例子" class="headerlink" title="webSocket chat例子"></a>webSocket chat例子</h3><p>这个小例子场景，我们在下一学习中继续使用，再此作个说明，用户请求帮助（通过websocket发其chat），客服（另一用户）选择需要帮助的用户（加入chat），双方之间进行通话：</p><ul><li>用户和web app之间创建web socket连接A，客服（另一用户）和web app之间创建web socket连接B，web app关联这两段连接之间的消息收发。</li><li>web app在web socket中定时向浏览器发送ping消息，并监听响应的pong消息。</li><li><p>用户的名字将根据登录信息自动获取，用户退出，chat也将关闭</p></li><li><p>通过SessionRegisterService来维护所有的在线http session</p></li><li>将存放在session中的username方在请求的principal中，方便获取</li></ul><p>在webSocket chat中我们通过SessionRegisterService打算维护在线的session。对用户退出登录（主动退出，session超时而被删除）时，如果该用户在chat中，需要行chat close动作，可以利用Consumer进行触发。</p><h3 id="SessionRegisterService"><a href="#SessionRegisterService" class="headerlink" title="SessionRegisterService"></a>SessionRegisterService</h3><pre><code>public interface SessionRegistryService {
    public void addSession(HttpSession session);
    public void updateSessionId(HttpSession session, String oldSessionId);
    public void removeSession(HttpSession session);
    /** 注册回调函数 用户开启chat进行回掉函数或者触发函数的注册 */ 
    public void registerOnRemoveCallback(Consumer&lt;HttpSession&gt; callback);
    /** 注销回掉函数 用户关闭chat进行注销 */
    public void deregisterOnRemoveCallback(Consumer&lt;HttpSession&gt; callback);
}
</code></pre><h3 id="SessionListener"><a href="#SessionListener" class="headerlink" title="SessionListener"></a>SessionListener</h3><p>SessionListener没有什么特别：</p><ol><li>允许SessionRegisterService的注入，前面刚刚学习</li><li><p>对create/change Id/remove session是调用service的add/update和remove接口</p><p>public class SessionListener implements HttpSessionListener, ServletContextListener {</p><pre><code>@Inject private SessionRegistryService sessionRegistryService;

public void sessionCreated(HttpSessionEvent event)  { 
    this.sessionRegistryService.addSession(event.getSession());
}

public void sessionIdChanged(HttpSessionEvent event, String oldSessionId)  { 
    this.sessionRegistryService.updateSessionId(event.getSession(), oldSessionId);
}

public void sessionDestroyed(HttpSessionEvent event)  { 
     this.sessionRegistryService.removeSession(event.getSession());
}

@Override
public void contextInitialized(ServletContextEvent event) {
    .... 见前面 ....
}
... ...
</code></pre><p>}</p></li></ol><h3 id="SessionRegistryService的实现"><a href="#SessionRegistryService的实现" class="headerlink" title="SessionRegistryService的实现"></a>SessionRegistryService的实现</h3><pre><code>@Service
public class DefaultSessionRegistryService implements SessionRegistryService{
    private final Map&lt;String, HttpSession&gt; sessions = new Hashtable&lt;&gt;();
    /** Consumer的具体操作是：如果httpSession相同，则删除，里面已经进行了判断，所以就不需要Predicate */
    private final Set&lt;Consumer&lt;HttpSession&gt;&gt; callbacks = new HashSet&lt;&gt;();
    /** callbacksAddesWhileLocked是个比较有意思的处理，需要学习：
     *  我们几乎同时收到了同一个用户（同一个httpSession）要求退出登录 和 chat申请的两个操作，一般来讲虽然不会如此，多页面的请求有可能会造成几乎同时到达，由或者session到期的瞬间。callbacksAddedWhileLocked用于对这个时间差的session进行处理，即请求加入，然后马上推出登录，即removeSession()和registerOnRemoveCallback()几乎同时操作。理想顺序是有先后，而不是同时进行，但实际多线程运行的顺序无法保证。callbacksAddedWhileLocked来避免同时运行的问题。 */
    private final Set&lt;Consumer&lt;HttpSession&gt;&gt; callbacksAddedWhileLocked = new HashSet&lt;&gt;();

    @Override
    public void addSession(HttpSession session) {
        this.sessions.put(session.getId(), session);        
    }

    @Override
    public void updateSessionId(HttpSession session, String oldSessionId) {
        synchronized(this.sessions) {
            this.sessions.remove(oldSessionId);
            addSession(session);
        }
    }

    @Override
    public void removeSession(HttpSession session) {
        this.sessions.remove(session.getId());
        synchronized(this.callbacks){
            this.callbacksAddedWhileLocked.clear();
            this.callbacks.forEach(c -&gt; c.accept(session));
            try {
                this.callbacksAddedWhileLocked.forEach(c -&gt; c.accept(session));
            } catch(ConcurrentModificationException ignore) { }
        }        
    }

    @Override
    public void registerOnRemoveCallback(Consumer&lt;HttpSession&gt; callback) {
        this.callbacksAddedWhileLocked.add(callback);

        synchronized(this.callbacks){
            this.callbacks.add(callback);
        }        
    }

    @Override
    public void deregisterOnRemoveCallback(Consumer&lt;HttpSession&gt; callback) {
        synchronized(this.callbacks){
            this.callbacks.remove(callback);
        }        
    }
}
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/java环境为何如此配置.html" rel="next" title="Java环境为何如此配置？"><i class="fa fa-chevron-left"></i> Java环境为何如此配置？</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/javaforweb学习笔记七十service和repository5回调处理consumer.html" rel="prev" title="Java for Web学习笔记（七十）：Service和Repository（5）回调处理Consumer">Java for Web学习笔记（七十）：Service和Repository（5）回调处理Consumer <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#进一步了解Spring的bean注入"><span class="nav-number">1.</span> <span class="nav-text">进一步了解Spring的bean注入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#小测试：设置Service"><span class="nav-number">1.1.</span> <span class="nav-text">小测试：设置Service</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#小测试：注入该Service"><span class="nav-number">1.2.</span> <span class="nav-text">小测试：注入该Service</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在Listener-中实现注入实例"><span class="nav-number">2.</span> <span class="nav-text">在Listener 中实现注入实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无法直接在Listener中自动注入"><span class="nav-number">2.1.</span> <span class="nav-text">无法直接在Listener中自动注入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现方式"><span class="nav-number">2.2.</span> <span class="nav-text">实现方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#限制说明"><span class="nav-number">2.3.</span> <span class="nav-text">限制说明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SessionListener的具体应用例子"><span class="nav-number">3.</span> <span class="nav-text">SessionListener的具体应用例子</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#webSocket-chat例子"><span class="nav-number">3.1.</span> <span class="nav-text">webSocket chat例子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SessionRegisterService"><span class="nav-number">3.2.</span> <span class="nav-text">SessionRegisterService</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SessionListener"><span class="nav-number">3.3.</span> <span class="nav-text">SessionListener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SessionRegistryService的实现"><span class="nav-number">3.4.</span> <span class="nav-text">SessionRegistryService的实现</span></a></li></ol></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->