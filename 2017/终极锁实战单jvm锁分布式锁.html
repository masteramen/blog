<!-- build time:Sat Oct 27 2018 21:00:17 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="只会一点java 阅读(…) 评论(…)编辑收藏目录1.前言2.单JVM锁3.分布式锁4.总结=========正文分割线=================1.前言锁就像一把钥匙，需要加锁的代码就像一个房间。出现互斥操作的场景：多人同时想进同一个房间争抢这个房间的钥匙（只有一把），一人抢到钥匙，其他人都等待这个人出来归还钥匙，此时大家再次争抢钥匙循环下去。本篇用java语言分析锁的原理（简单描述）"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="终极锁实战：单JVM锁+分布式锁"><meta property="og:url" content="http://www.jfox.info/2017/终极锁实战单jvm锁分布式锁.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="只会一点java 阅读(…) 评论(…)编辑收藏目录1.前言2.单JVM锁3.分布式锁4.总结=========正文分割线=================1.前言锁就像一把钥匙，需要加锁的代码就像一个房间。出现互斥操作的场景：多人同时想进同一个房间争抢这个房间的钥匙（只有一把），一人抢到钥匙，其他人都等待这个人出来归还钥匙，此时大家再次争抢钥匙循环下去。本篇用java语言分析锁的原理（简单描述）"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:37.379Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="终极锁实战：单JVM锁+分布式锁"><meta name="twitter:description" content="只会一点java 阅读(…) 评论(…)编辑收藏目录1.前言2.单JVM锁3.分布式锁4.总结=========正文分割线=================1.前言锁就像一把钥匙，需要加锁的代码就像一个房间。出现互斥操作的场景：多人同时想进同一个房间争抢这个房间的钥匙（只有一把），一人抢到钥匙，其他人都等待这个人出来归还钥匙，此时大家再次争抢钥匙循环下去。本篇用java语言分析锁的原理（简单描述）"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/终极锁实战单jvm锁分布式锁.html"><title>终极锁实战：单JVM锁+分布式锁 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/终极锁实战单jvm锁分布式锁.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">终极锁实战：单JVM锁+分布式锁</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:58:54+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p><a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/dennyzhangdd/">只会一点java</a> 阅读(<br>…) 评论(<br>…)<br><a href="https://www.jfox.info/go.php?url=https://i.cnblogs.com/EditPosts.aspx?postid=7133653">编辑</a><a href="#">收藏</a><br>目录</p><p>1.前言</p><p>2.单JVM锁</p><p>3.分布式锁</p><p>4.总结</p><p>=========正文分割线=================</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>锁就像一把钥匙，需要加锁的代码就像一个房间。出现互斥操作的场景：多人同时想进同一个房间争抢这个房间的钥匙（只有一把），一人抢到钥匙，其他人都等待这个人出来归还钥匙，此时大家再次争抢钥匙循环下去。</p><p>本篇用java语言分析锁的原理（简单描述）和应用（详细代码），根据锁的作用范围分为：JVM锁和分布式锁。如理解有误之处，还请指出。</p><h2 id="2-单JVM锁（进程级别）"><a href="#2-单JVM锁（进程级别）" class="headerlink" title="2.单JVM锁（进程级别）"></a>2.单JVM锁（进程级别）</h2><p>程序部署在一台服务器上，当容器启动时（例如tomcat），一台JVM就运行起来了。第一部门分析的锁均只能在单JVM下生效。因为最终锁定的是某个对象，这个对象生存在JVM中，自然锁只能锁单JVM。这一点很重要。如果你的服务只部署一个实例，那么恭喜你，用以下几种锁就可以了。</p><p>1.synchronized同步锁</p><p>2.ReentrantLock重入锁</p><p>3.ReadWriteLock读写锁</p><p>4.StampedLock戳锁</p><p>由于之前已经详细分析过原理+使用，各位直接坐飞机吧：<a href="https://www.jfox.info/go.php?url=http://www.cnblogs.com/dennyzhangdd/p/6925473.html">同步中的四种锁synchronized、ReentrantLock、ReadWriteLock、StampedLock</a></p><h2 id="3-分布式锁（多服务节点，多进程）"><a href="#3-分布式锁（多服务节点，多进程）" class="headerlink" title="3.分布式锁（多服务节点，多进程）"></a>3.分布式锁（多服务节点，多进程）</h2><h3 id="3-1基于数据库锁实现"><a href="#3-1基于数据库锁实现" class="headerlink" title="3.1基于数据库锁实现"></a>3.1基于数据库锁实现</h3><p>场景举例：</p><p>卖商品，先查询库存&gt;0,更新库存-1。</p><p>1.悲观锁：<strong>select for update</strong></p><pre><code>确保以下2步骤在一个事务中：


SELECT * FROM tb_product_stock WHERE product_id=1 FOR UPDATE---&gt;product_id有索引，锁行.加锁（注:条件字段必须有索引才能锁行，否则锁表，且最好用explain查看一下是否使用了索引，因为有一些会被优化掉最终没有使用索引）


UPDATE tb_product_stock SET number=number-1 WHERE product_id=1---&gt;更新库存-1.解锁
</code></pre><p>2.乐观锁：<strong>版本控制</strong>，选一个<code>字段作为版本控制字段，更新前查询一次，更新时该字段作为更新条件</code>。不同业务场景，版本控制字段，可以0 1控制，也可以+1控制，也可以-1控制，这个随意。</p><pre><code>确保以下2步骤在一个事务中：
SELECT number FROM tb_product_stock WHERE product_id=1--》查询库存总数，不加锁


UPDATE tb_product_stock SET number=number-1 WHERE product_id=1 AND number=第一步查询到的库存数--》number字段作为版本控制字段
</code></pre><h3 id="3-2基于缓存实现（redis，memcached）"><a href="#3-2基于缓存实现（redis，memcached）" class="headerlink" title="3.2基于缓存实现（redis，memcached）"></a>3.2基于缓存实现（redis，memcached）</h3><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><p>redisson开源jar包,提供了很多功能，其中就包含分布式锁。</p><p>核心org.redisson.api.RLock接口封装了分布式锁的获取和释放。源码如下：</p><pre><code> 1@Override
 2publicboolean tryLock(long waitTime, long leaseTime, TimeUnit unit) throws InterruptedException {
 3long time = unit.toMillis(waitTime);
 4long current = System.currentTimeMillis();
 5finallong threadId = Thread.currentThread().getId();
 6Long ttl = tryAcquire(leaseTime, unit, threadId);//申请锁，返回还剩余的锁过期时间 7// lock acquired 8if (ttl == null) {
 9returntrue;
10        }
1112         time -= (System.currentTimeMillis() - current);
13if (time &lt;= 0) {
14            acquireFailed(threadId);
15returnfalse;
16        }
1718         current = System.currentTimeMillis();
19final RFuture&lt;RedissonLockEntry&gt; subscribeFuture = subscribe(threadId);
20if (!await(subscribeFuture, time, TimeUnit.MILLISECONDS)) {
21if (!subscribeFuture.cancel(false)) {
22                 subscribeFuture.addListener(new FutureListener&lt;RedissonLockEntry&gt;() {
23                    @Override
24publicvoid operationComplete(Future&lt;RedissonLockEntry&gt; future) throws Exception {
25if (subscribeFuture.isSuccess()) {
26                            unsubscribe(subscribeFuture, threadId);
27                        }
28                    }
29                });
30            }
31            acquireFailed(threadId);
32returnfalse;
33        }
3435try {
36             time -= (System.currentTimeMillis() - current);
37if (time &lt;= 0) {
38                acquireFailed(threadId);
39returnfalse;
40            }
4142while (true) {
43long currentTime = System.currentTimeMillis();
44                 ttl = tryAcquire(leaseTime, unit, threadId);
45// lock acquired46if (ttl == null) {
47returntrue;
48                }
4950                 time -= (System.currentTimeMillis() - currentTime);
51if (time &lt;= 0) {
52                    acquireFailed(threadId);
53returnfalse;
54                }
5556// waiting for message57                 currentTime = System.currentTimeMillis();
58if (ttl &gt;= 0 &amp;&amp; ttl &lt; time) {
59                    getEntry(threadId).getLatch().tryAcquire(ttl, TimeUnit.MILLISECONDS);
60                 } else {
61                    getEntry(threadId).getLatch().tryAcquire(time, TimeUnit.MILLISECONDS);
62                }
6364                 time -= (System.currentTimeMillis() - currentTime);
65if (time &lt;= 0) {
66                    acquireFailed(threadId);
67returnfalse;
68                }
69            }
70         } finally {
71            unsubscribe(subscribeFuture, threadId);
72        }
73//        return get(tryLockAsync(waitTime, leaseTime, unit));74     }
</code></pre><p>上述方法，调用加锁的逻辑就是在tryAcquire(leaseTime, unit, threadId)中，如下图：</p><pre><code>1private Long tryAcquire(long leaseTime, TimeUnit unit, long threadId) {
2return get(tryAcquireAsync(leaseTime, unit, threadId));//tryAcquireAsync返回RFutrue
3 }

tryAcquireAsync中commandExecutor.evalWriteAsync就是咱们加锁核心方法了

 1 &lt;T&gt; RFuture&lt;T&gt; tryLockInnerAsync(long leaseTime, TimeUnit unit, long threadId, RedisStrictCommand&lt;T&gt; command) {
 2         internalLockLeaseTime = unit.toMillis(leaseTime);
 3 4return commandExecutor.evalWriteAsync(getName(), LongCodec.INSTANCE, command,
 5                   &quot;if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) then &quot; +
 6                       &quot;redis.call(&apos;hset&apos;, KEYS[1], ARGV[2], 1); &quot; +
 7                       &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]); &quot; +
 8                       &quot;return nil; &quot; +
 9                   &quot;end; &quot; +
10                   &quot;if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[2]) == 1) then &quot; +
11                       &quot;redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[2], 1); &quot; +
12                       &quot;redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[1]); &quot; +
13                       &quot;return nil; &quot; +
14                   &quot;end; &quot; +
15                   &quot;return redis.call(&apos;pttl&apos;, KEYS[1]);&quot;,
16                     Collections.&lt;Object&gt;singletonList(getName()), internalLockLeaseTime, getLockName(threadId));
17     }
</code></pre><p>如上图，已经到了redis命令了</p><p><strong>加锁：</strong></p><ul><li>KEYS[1] ：需要加锁的key，这里需要是字符串类型。</li><li>ARGV[1] ：锁的超时时间，防止死锁</li><li><p>ARGV[2] ：锁的唯一标识，<em>（UUID.randomUUID()） + “:” + threadId</em></p><p>1// 检查是否key已经被占用，如果没有则设置超时时间和唯一标识，初始化value=1 2if (redis.call(‘exists’, KEYS[1]) == 0)<br>3then<br>4 redis.call(‘hset’, KEYS[1], ARGV[2], 1);<br>5 redis.call(‘pexpire’, KEYS[1], ARGV[1]);<br>6return nil;<br>7end;<br>8// 如果锁重入,需要判断锁的key field 都一直情况下 value 加一 9if (redis.call(‘hexists’, KEYS[1], ARGV[2]) == 1)<br>10then<br>11 redis.call(‘hincrby’, KEYS[1], ARGV[2], 1);<br>12 redis.call(‘pexpire’, KEYS[1], ARGV[1]);//锁重入重新设置超时时间13return nil;<br>14end;<br>15// 返回剩余的过期时间16return redis.call(‘pttl’, KEYS[1]);</p></li></ul><p>以上的方法，当返回空是，说明获取到锁，如果返回一个long数值（pttl 命令的返回值），说明锁已被占用，通过返回剩余时间，外部可以做一些等待时间的判断和调整。</p><p>不再分析解锁步骤，直接贴上解锁的redis 命令</p><p><strong>解锁：</strong></p><p>– KEYS[1] ：需要加锁的key，这里需要是字符串类型。</p><p>– KEYS[2] ：redis消息的ChannelName,一个分布式锁对应唯一的一个channelName:<em>“redisson_lock__channel__{” + getName() + “}”</em></p><p>– ARGV[1] ：reids消息体，这里只需要一个字节的标记就可以，主要标记redis的key已经解锁，再结合redis的Subscribe，能唤醒其他订阅解锁消息的客户端线程申请锁。</p><p>– ARGV[2] ：锁的超时时间，防止死锁</p><p>– ARGV[3] ：锁的唯一标识，<em>（UUID.randomUUID()） + “:” + threadId</em></p><pre><code> 1// 如果key已经不存在，说明已经被解锁，直接发布（publihs）redis消息 2if (redis.call(&apos;exists&apos;, KEYS[1]) == 0) 
 3then
 4     redis.call(&apos;publish&apos;, KEYS[2], ARGV[1]);
 5return 1;
 6end;
 7// key和field不匹配，说明当前客户端线程没有持有锁，不能主动解锁。 8if (redis.call(&apos;hexists&apos;, KEYS[1], ARGV[3]) == 0)
 9then 
10return nil;
11end; 
12// 将value减113 local counter = redis.call(&apos;hincrby&apos;, KEYS[1], ARGV[3], -1); 
14// 如果counter&gt;0说明锁在重入，不能删除key15if (counter &gt; 0)  
16then
17     redis.call(&apos;pexpire&apos;, KEYS[1], ARGV[2]);                             
18return 0; 
19else20// 删除key并且publish 解锁消息21     redis.call(&apos;del&apos;, KEYS[1]);                            
22     redis.call(&apos;publish&apos;, KEYS[2], ARGV[1]); 
23return 1; 
24end; 
25return nil;
</code></pre><h4 id="实战："><a href="#实战：" class="headerlink" title="实战："></a>实战：</h4><p>1.创建RedissonClient</p><pre><code>1 Config config = new Config();
2 config.useSingleServer().setAddress(redisHost + &quot;:&quot; + redisPort)
3.setPassword(redisPassword)
4 .setDatabase(redisDatabase);//可以不设置，看业务是否需要隔离 0-15共16个数据库5 RedissonClient redisson = Redisson.create(config);
</code></pre><p>2.加锁解锁</p><pre><code> 1 1.加锁
 2try {
 3//根据key获取锁实例，非公平锁 4     RLock lock = redissonClient.getLock(key);
 5//在leaseTime时间内阻塞获取锁，获取锁后持有锁直到leaseTime租期结束（除非手动unLock释放锁）。 6return lock.tryLock(waitTime, leaseTime, timeUnit);
 7 } catch (Exception e) {
 8     logger.error(&quot;redis获取分布式锁异常;key=&quot; + key + &quot;,waitTime=&quot; + waitTime + &quot;,leaseTime=&quot; + leaseTime +
 9             &quot;,timeUnit=&quot; + timeUnit, e);
10returnfalse;
11}
12 2.解锁
13 RLock lock = redissonClient.getLock(key);
14 lock.unlock();
</code></pre><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><p>逻辑并不复杂, 但是通过记录客户端ID和线程ID来唯一标识线程, 实现重入功能, 通过pub sub功能来减少空转.</p><p>实现了Lock的大部分功能, 提供了特殊情况方法(如:强制解锁, 判断当前线程是否已经获取锁, 超时强制解锁等功能), 可重入, 减少重试.</p><p>使用依赖Redisson, 而Redisson依赖netty, 如果简单使用, 引入了较多的依赖, pub sub的实时性需要测试, 没有监控等功能, 查问题麻烦, 统计功能也没有</p><h3 id="2）基于zookeeper实现"><a href="#2）基于zookeeper实现" class="headerlink" title="2）基于zookeeper实现"></a>2）基于zookeeper实现</h3><h4 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h4><p>每个客户端（每个JVM中共用一个客户端实例，单例模式）对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。当释放锁的时候，只需将这个瞬时节点删除即可。同时，可以避免服务宕机导致的锁无法释放，而产生的死锁问题（临时节点服务宕机节点就没了）。</p><h4 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h4><p>单个JVM可实现按照请求顺序获取锁，分布式下无法保证全部顺序：顺序创建节点-》获取锁时获取第一个节点（节点名有序）。一般实现分布式锁肯定会是有多个JVM即多个客户端那么无法保证按照请求时间顺序获取锁，因为每个JVM中服务请求时间不一定一致。（节点名和请求时间有关）</p><h4 id="实战：-1"><a href="#实战：-1" class="headerlink" title="实战："></a>实战：</h4><p><strong>Curator组件概览：</strong></p><ul><li>Recipes：通用ZooKeeper技巧(“recipes”)的实现. 建立在Curator Framework之上</li><li>Framework：简化zookeeper使用的高级. 增加了很多建立在zooper之上的特性. 管理复杂连接处理和重试操作</li><li>Utilities：各种工具类</li><li>Client：ZooKeeper本身提供的类的替代者。负责底层的开销以及一些工具</li><li>Errors：Curator怎样来处理错误和异常</li><li>Extensions：curator-recipes包实现了通用的技巧，这些技巧在ZooKeeper文档中有介绍。为了避免是这个包(package)变得巨大，recipes/applications将会放入一个独立的extension包下。并使用命名规则curator-x-name</li></ul><p>我们主要使用的Client、Framework、Recipes三个组件。</p><pre><code> 1package distributed.lock.zk;
 2 3import java.text.SimpleDateFormat;
 4import java.util.Date;
 5import java.util.concurrent.TimeUnit;
 6 7import org.apache.curator.framework.CuratorFramework;
 8import org.apache.curator.framework.CuratorFrameworkFactory;
 9import org.apache.curator.framework.recipes.locks.InterProcessMutex;
10import org.apache.curator.retry.RetryNTimes;
1112/**13 * 
14 * @ClassName:CuratorDistrLockTest
15 * @Description:Curator包实现zk分布式锁
16 * @author diandian.zhang
17 * @date 2017年7月11日下午12:43:44
18*/1920publicclass CuratorDistrLock {
2122privatestaticfinal String ZK_ADDRESS = &quot;192.168.50.253:2181&quot;;//地址23privatestaticfinal String ZK_LOCK_PATH = &quot;/zktest&quot;;//path24static SimpleDateFormat time = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
2526publicstaticvoid main(String[] args)  {
27try {
28//创建zk客户端29             CuratorFramework client = CuratorFrameworkFactory.newClient(
30                    ZK_ADDRESS,
31new RetryNTimes(10, 5000)
32            );
33//开启34            client.start();
35             System.out.println(&quot;zk client start successfully!&quot;);
36//依赖ZK生成的互斥锁，公平锁（按照请求顺序获取锁）37             InterProcessMutex lock = new InterProcessMutex(client, ZK_LOCK_PATH);
38             Thread t1 = new Thread(() -&gt; {
39                 doWithLock(client,lock);//函数式编程40             }, &quot;t1&quot;);
41             Thread t2 = new Thread(() -&gt; {
42                doWithLock(client,lock);
43             }, &quot;t2&quot;);
44             Thread t3 = new Thread(() -&gt; {
45                doWithLock(client,lock);
46             }, &quot;t3&quot;);
47//启动线程48            t1.start();
49            t2.start();
50            t3.start();
51         } catch (Exception e) {
52            e.printStackTrace();
53        }
54    }
5556/**57     * 
58     * @Description 线程执行函数体
59     * @param client
60     * @param lock
61     * @author diandian.zhang
62     * @date 2017年7月12日下午6:00:53
63     * @since JDK1.8
64*/65privatestaticvoid doWithLock(CuratorFramework client,InterProcessMutex lock) {
66         Boolean b = false;//是否持有锁67try {
68             System.out.println(&quot;进入线程=&quot;+Thread.currentThread().getName()+&quot;:&quot;+time.format(new Date()));
69//花1秒时间尝试获取锁，成功70if (lock.acquire(1, TimeUnit.SECONDS)) {
71                 b = true;
72                 System.out.println(Thread.currentThread().getName() + &quot; 获取锁成功！，执行需要加锁的任务&quot;+time.format(new Date()));
73                 Thread.sleep(2000L);//休息2秒模拟执行需要加锁的任务
74//获取锁超时75             }else{
76                 System.out.println(Thread.currentThread().getName() + &quot; 获取锁超时！&quot;+time.format(new Date()));
77            }
78         } catch (Exception e) {
79            e.printStackTrace();
80         } finally {
81try {
82                 System.out.println(Thread.currentThread().getName() + &quot; 释放锁&quot;+time.format(new Date()));
83//当前线程获取到锁，那么最后需要释放锁84if(b){
85                    lock.release();
86                }
87             } catch (Exception e) {
88                e.printStackTrace();
89            }
90        }
91    }
9293 }
</code></pre><p>执行结果：</p><pre><code>zk client start successfully!
进入线程=t2:2017-07-1311:13:13
进入线程=t1:2017-07-1311:13:13
进入线程=t3:2017-07-1311:13:13
t2 获取锁成功！，执行需要加锁的任务2017-07-1311:13:23
t2 释放锁2017-07-1311:13:25
t3 获取锁成功！，执行需要加锁的任务2017-07-1311:13:25
t3 释放锁2017-07-1311:13:27
t1 获取锁成功！，执行需要加锁的任务2017-07-1311:13:27
t1 释放锁2017-07-1311:13:29
</code></pre><h2 id="4-总结比较"><a href="#4-总结比较" class="headerlink" title="4.总结比较"></a>4.总结比较</h2><h3 id="一级锁分类"><a href="#一级锁分类" class="headerlink" title="一级锁分类"></a>一级锁分类</h3><h3 id="二级锁分类"><a href="#二级锁分类" class="headerlink" title="二级锁分类"></a>二级锁分类</h3><h3 id="锁名称"><a href="#锁名称" class="headerlink" title="锁名称"></a>锁名称</h3><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h3 id="是否推荐"><a href="#是否推荐" class="headerlink" title="是否推荐"></a>是否推荐</h3><h3 id="单JVM锁"><a href="#单JVM锁" class="headerlink" title="单JVM锁"></a>单JVM锁</h3><p>基于JVM源生synchronized关键字实现<br>synchronized同步锁<br>适用于低并发的情况，性能稳定。新手推荐基于JDK实现，需显示获取锁，释放锁<br>ReentrantLock可重入锁<br>适用于低、高并发的情况，性能较高 建议需要手动操作线程时使用。<br>ReentrantReadWriteLock</p><p>可重入读写锁<br>适用于读多写少的情况。性能高。 老司机推荐<br>StampedLock戳锁<br>JDK8才有，适用于高并发且读远大于写时，支持乐观读，票据校验失败后可升级悲观读锁，性能极高！ 老司机推荐</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>基于数据库锁实现</p><p><strong>悲观锁：select for update</strong><br>sql直接使用，但可能出现死锁 不推荐<br><strong>乐观锁：版本控制</strong><br>自己实现字段版本控制 新手推荐<br>基于缓存实现</p><p>org.redisson<br>支持除了分布式锁外还实现了分布式对象、分布式集合等极端强大的功能 老司机推荐<br>基于zookeeper实现</p><p>org.apache.curator zookeeper<br>除支持分布式锁外，还实现了master选举、节点监听（）、分布式队列、Barrier、AtomicLong等计数器 老司机推荐</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/shardingjdbc150正式发布全新sql解析发动机.html" rel="next" title="Sharding-JDBC 1.5.0 正式发布：全新 SQL 解析发动机"><i class="fa fa-chevron-left"></i> Sharding-JDBC 1.5.0 正式发布：全新 SQL 解析发动机</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/js组件系列在abp中封装bootstraptable.html" rel="prev" title="JS组件系列——在ABP中封装BootstrapTable">JS组件系列——在ABP中封装BootstrapTable <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-前言"><span class="nav-number">1.</span> <span class="nav-text">1.前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-单JVM锁（进程级别）"><span class="nav-number">2.</span> <span class="nav-text">2.单JVM锁（进程级别）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-分布式锁（多服务节点，多进程）"><span class="nav-number">3.</span> <span class="nav-text">3.分布式锁（多服务节点，多进程）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1基于数据库锁实现"><span class="nav-number">3.1.</span> <span class="nav-text">3.1基于数据库锁实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2基于缓存实现（redis，memcached）"><span class="nav-number">3.2.</span> <span class="nav-text">3.2基于缓存实现（redis，memcached）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原理："><span class="nav-number">3.2.1.</span> <span class="nav-text">原理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实战："><span class="nav-number">3.2.2.</span> <span class="nav-text">实战：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点："><span class="nav-number">3.2.3.</span> <span class="nav-text">特点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2）基于zookeeper实现"><span class="nav-number">3.3.</span> <span class="nav-text">2）基于zookeeper实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#原理：-1"><span class="nav-number">3.3.1.</span> <span class="nav-text">原理：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特点：-1"><span class="nav-number">3.3.2.</span> <span class="nav-text">特点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实战：-1"><span class="nav-number">3.3.3.</span> <span class="nav-text">实战：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-总结比较"><span class="nav-number">4.</span> <span class="nav-text">4.总结比较</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#一级锁分类"><span class="nav-number">4.1.</span> <span class="nav-text">一级锁分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二级锁分类"><span class="nav-number">4.2.</span> <span class="nav-text">二级锁分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁名称"><span class="nav-number">4.3.</span> <span class="nav-text">锁名称</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#特性"><span class="nav-number">4.4.</span> <span class="nav-text">特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#是否推荐"><span class="nav-number">4.5.</span> <span class="nav-text">是否推荐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单JVM锁"><span class="nav-number">4.6.</span> <span class="nav-text">单JVM锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分布式锁"><span class="nav-number">4.7.</span> <span class="nav-text">分布式锁</span></a></li></ol></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->