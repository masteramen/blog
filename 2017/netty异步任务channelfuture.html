<!DOCTYPE html>
<html lang="zh_CN"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>netty 异步任务-ChannelFuture | Java面试</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="netty 异步任务-ChannelFuture" />
<meta property="og:locale" content="zh_CN" />
<meta name="description" content="netty Inboudn/Outbound通道Invoker: http://donald-draper.iteye.com/blog/2388233引言： 上一篇看了Channel管道线的父类接口Inboudn/Outbound通道Invoker定义，先来回顾一下：" />
<meta property="og:description" content="netty Inboudn/Outbound通道Invoker: http://donald-draper.iteye.com/blog/2388233引言： 上一篇看了Channel管道线的父类接口Inboudn/Outbound通道Invoker定义，先来回顾一下：" />
<link rel="canonical" href="http://www.jfox.info/2017/netty%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1channelfuture.html" />
<meta property="og:url" content="http://www.jfox.info/2017/netty%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1channelfuture.html" />
<meta property="og:site_name" content="Java面试" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-01-01T23:59:24+08:00" />
<script type="application/ld+json">
{"description":"netty Inboudn/Outbound通道Invoker: http://donald-draper.iteye.com/blog/2388233引言： 上一篇看了Channel管道线的父类接口Inboudn/Outbound通道Invoker定义，先来回顾一下：","@type":"BlogPosting","url":"http://www.jfox.info/2017/netty%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1channelfuture.html","headline":"netty 异步任务-ChannelFuture","dateModified":"2017-01-01T23:59:24+08:00","datePublished":"2017-01-01T23:59:24+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.jfox.info/2017/netty%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1channelfuture.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://www.jfox.info/feed.xml" title="Java面试" /></head><body><header class="site-header" role="banner">
  <div class="wrapper"><a class="site-title" rel="author" href="/">Java面试</a><nav class="site-nav">
      <input type="checkbox" id="nav-trigger" class="nav-trigger" />
      <label for="nav-trigger">
        <span class="menu-icon">
          <svg viewBox="0 0 18 15" width="18px" height="15px">
            <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z" />
          </svg>
        </span>
      </label>

      <div class="trigger"><a class="page-link" href="/about/">About</a></div>
    </nav></div>
</header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">netty 异步任务-ChannelFuture</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2017-01-01T23:59:24+08:00" itemprop="datePublished">Jan 1, 2017
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    
<p>netty Inboudn/Outbound通道Invoker: 
<a href="https://www.jfox.info/go.php?url=http://donald-draper.iteye.com/blog/2388233">http://donald-draper.iteye.com/blog/2388233</a><strong>引言：</strong>
上一篇看了Channel管道线的父类接口Inboudn/Outbound通道Invoker定义，先来回顾一下：</p>

<p>每个通道Channel拥有自己的管道Pipeline，当通道创建时，管道自动创建,默认为DefaultChannelPipeline。Inbound通道Invoker ChannelInboundInvoker主要是触发管道线ChannelPipeline上的下一个Inbound通道处理器ChannelInboundHandler的相关方法。ChannelInboundInvoker有点Mina过滤器的意味。Outbound通道Invoker ChannelOutboundInvoker主要是触发触发管道线ChannelPipeline上的下一个Outbound通道处理器ChannelOnboundHandler的相关方法，同时增加了一下通道任务创建方法，</p>

<p>ChannelOutboundInvoker也有点Mina过滤器的意味，只不过不像ChannelInboundInvoker的方法命名那么相似。</p>

<p>在Outbound通道Invoker的方法定义中，我们看到有很多类型的返回异步任务，</p>

<p>比如：ChannelFuture，ChannelPromise，ChannelProgressivePromise，我们来看一下这些异步任务：</p>

<p>注意异步任务和异步结果的含义要结合上下文来看。</p>

<p>//ChannelFuture</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>public interface ChannelFuture extends Future&lt;Void&gt; 
</code></pre></div></div>

<p>再看ChannelFuture之前，先看Future接口定义</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.util.concurrent.CancellationException;
import java.util.concurrent.TimeUnit;
/**
 * The result of an asynchronous operation.
 一个异步操作接口，从定义来看继承与JUC的Future
 */
@SuppressWarnings("ClassNameSameAsAncestorName")
public interface Future&lt;V&gt; extends java.util.concurrent.Future&lt;V&gt; {

    /**
     * Returns {@code true} if and only if the I/O operation was completed
     * successfully.
     如果一个IO操作是否成功完成，返回ture
     */
    boolean isSuccess();

    /**
     * returns {@code true} if and only if the operation can be cancelled via {@link #cancel(boolean)}.
     如果一个操作通过cancel方法取消，则返回true
     */
    boolean isCancellable();

    /**
     * Returns the cause of the failed I/O operation if the I/O operation has
     * failed.
     *如果IO操作失败，则返回失败原因
     * @return the cause of the failure.
     *         {@code null} if succeeded or this future is not
     *         completed yet.
     */
    Throwable cause();

    /**
     * Adds the specified listener to this future.  The
     * specified listener is notified when this future is
     * {@linkplain #isDone() done}.  If this future is already
     * completed, the specified listener is notified immediately.
     添加任务监听器。当操作完成时，通知监听器。如果操作已经完成，则将立刻通知任务监听器。
     */
    Future&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    /**
     * Adds the specified listeners to this future.  The
     * specified listeners are notified when this future is
     * {@linkplain #isDone() done}.  If this future is already
     * completed, the specified listeners are notified immediately.
     与上述方法类似，可以一次添加多个监听器
     */
    Future&lt;V&gt; addListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    /**
     * Removes the first occurrence of the specified listener from this future.
     * The specified listener is no longer notified when this
     * future is {@linkplain #isDone() done}.  If the specified
     * listener is not associated with this future, this method
     * does nothing and returns silently.
     从异步任务移除监听器。当操作完成时，不在通知监听器。如果监听器与当前异步任务没有关联，
     则此方什么都不做
     */
    Future&lt;V&gt; removeListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    /**
     * Removes the first occurrence for each of the listeners from this future.
     * The specified listeners are no longer notified when this
     * future is {@linkplain #isDone() done}.  If the specified
     * listeners are not associated with this future, this method
     * does nothing and returns silently.
     与上述方法类似，可以一次移动多个监听器
     */
    Future&lt;V&gt; removeListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    /**
     * Waits for this future until it is done, and rethrows the cause of the failure if this future
     * failed.
     等待异步任务，直到操作完成，如果操作失败，则重新抛出失败的原因。
     */
    Future&lt;V&gt; sync() throws InterruptedException;

    /**
     * Waits for this future until it is done, and rethrows the cause of the failure if this future
     * failed.
     以不可中断方式，等待异步任务，直到操作完成，如果操作失败，则重新抛出失败的原因。
     */
    Future&lt;V&gt; syncUninterruptibly();

    /**
     * Waits for this future to be completed.
     *等待操作完成
     * @throws InterruptedException
     *         if the current thread was interrupted
     */
    Future&lt;V&gt; await() throws InterruptedException;

    /**
     * Waits for this future to be completed without
     * interruption.  This method catches an {@link InterruptedException} and
     * discards it silently.
     以不可中断方法等待操作结果，如果遇到中断异常，则直接丢弃
     */
    Future&lt;V&gt; awaitUninterruptibly();

    /**
     * Waits for this future to be completed within the
     * specified time limit.
     *超时等待操作完成
     * @return {@code true} if and only if the future was completed within
     *         the specified time limit
     *
     * @throws InterruptedException
     *         if the current thread was interrupted
     */
    boolean await(long timeout, TimeUnit unit) throws InterruptedException;

    /**
     * Waits for this future to be completed within the
     * specified time limit.
     *超时等待，单位毫秒
     * @return {@code true} if and only if the future was completed within
     *         the specified time limit
     *
     * @throws InterruptedException
     *         if the current thread was interrupted
     */
    boolean await(long timeoutMillis) throws InterruptedException;

    /**
     * Waits for this future to be completed within the
     * specified time limit without interruption.  This method catches an
     * {@link InterruptedException} and discards it silently.
     *超时不可中断等待操作结果
     * @return {@code true} if and only if the future was completed within
     *         the specified time limit
     */
    boolean awaitUninterruptibly(long timeout, TimeUnit unit);

    /**
     * Waits for this future to be completed within the
     * specified time limit without interruption.  This method catches an
     * {@link InterruptedException} and discards it silently.
     *超时不可中断等待操作结果，单位毫秒
     * @return {@code true} if and only if the future was completed within
     *         the specified time limit
     */
    boolean awaitUninterruptibly(long timeoutMillis);

    /**
     * Return the result without blocking. If the future is not done yet this will return {@code null}.
     *
     * As it is possible that a {@code null} value is used to mark the future as successful you also need to check
     * if the future is really done with {@link #isDone()} and not relay on the returned {@code null} value.
     */
    V getNow();

    /**
     * {@inheritDoc}
     *
     * If the cancellation was successful it will fail the future with an {@link CancellationException}.
     如果取消成功，返回一个取消异常的失败结果。
     */
    @Override
    boolean cancel(boolean mayInterruptIfRunning);
}
</code></pre></div></div>

<p>从Netty的异步任务Future定义来看，继承于JUC的Future，可以异步获取IO操作的结果信息，比如操作是否成功完成，如果失败，可以获取失败的原因，是否取消，同时可以使用cancel方法取消IO操作，添加异步任务监听器，、监听IO操作是否完成，同时可以移除任务监听器，除这些之外我们可以异步、同步等待或超时等待IO操作结果。</p>

<p>来看一下结果监听器：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import java.util.EventListener;

/**
 * Listens to the result of a {@link Future}.  The result of the asynchronous operation is notified once this listener
 * is added by calling {@link Future#addListener(GenericFutureListener)}.
 监听IO操作异步结果。只要监听器被添加的异步任务中，异步操作完成，将会通知监听器。
 */
public interface GenericFutureListener&lt;F extends Future&lt;?&gt;&gt; extends EventListener {

    /**
     * Invoked when the operation associated with the {@link Future} has been completed.
     当异步任务关联的IO操作完成时，触发operationComplete方法
     *
     * @param future  the source {@link Future} which called this callback
     */
    void operationComplete(F future) throws Exception;
}
</code></pre></div></div>

<p>从上面来异步任务监听器，主要监听一个IO操作是否完成，在异步任务有返回值时，通知监听器。</p>

<p>下面我们来看通道异步任务：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import io.netty.bootstrap.Bootstrap;
import io.netty.util.concurrent.BlockingOperationException;
import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;

import java.util.concurrent.TimeUnit;


/**
 * The result of an asynchronous {@link Channel} I/O operation.
 ChannelFuture为一个通道的异步IO操作结果
 * &lt;p&gt;
 * All I/O operations in Netty are asynchronous.  It means any I/O calls will
 * return immediately with no guarantee that the requested I/O operation has
 * been completed at the end of the call.  Instead, you will be returned with
 * a {@link ChannelFuture} instance which gives you the information about the
 * result or status of the I/O operation.
 Netty所有的IO操作都是异步的。意味着所有IO操作在不能保证在调用结束后，IO请求操作完成
 情况下，立刻返回。然而，你可以返回一个异步结果实例，可以等待异步IO操作的结果或IO状态。
 * &lt;p&gt;
 * A {@link ChannelFuture} is either [i]uncompleted[/i] or [i]completed[/i].
 * When an I/O operation begins, a new future object is created.  The new future
 * is uncompleted initially - it is neither succeeded, failed, nor cancelled
 * because the I/O operation is not finished yet.  If the I/O operation is
 * finished either successfully, with failure, or by cancellation, the future is
 * marked as completed with more specific information, such as the cause of the
 * failure.  Please note that even failure and cancellation belong to the
 * completed state.
 当一个IO操作开始时，不管操作是否完成，一个新的异步操作结果将会被创建。
 如果因为IO操作没有完成，同时既没有成功，失败，也没有取消，新创建的
 异步结果并没有完成初始化。如果IO操作完成，不论操作结果成功，失败或取消，
 异步结果将会标记为完成，同时携带更多的精确信息，比如失败的原因。需要注意的时，
 失败或取消也属于完成状态。
 * &lt;pre&gt;
 *                                      +---------------------------+
 *                                      | Completed successfully    |
 *                                      +---------------------------+
 *                                 +----&gt;      isDone() = true      |
 * +--------------------------+    |    |   isSuccess() = true      |
 * |        Uncompleted       |    |    +===========================+
 * +--------------------------+    |    | Completed with failure    |
 * |      isDone() = false    |    |    +---------------------------+
 * |   isSuccess() = false    |----+----&gt;      isDone() = true      |
 * | isCancelled() = false    |    |    |       cause() = non-null  |
 * |       cause() = null     |    |    +===========================+
 * +--------------------------+    |    | Completed by cancellation |
 *                                 |    +---------------------------+
 *                                 +----&gt;      isDone() = true      |
 *                                      | isCancelled() = true      |
 *                                      +---------------------------+
 * &lt;/pre&gt;
 *
 * Various methods are provided to let you check if the I/O operation has been
 * completed, wait for the completion, and retrieve the result of the I/O
 * operation. It also allows you to add {@link ChannelFutureListener}s so you
 * can get notified when the I/O operation is completed.
 异步结果提供不同的方法，用于检查IO操作是否完成，等待操作完成，获取IO操作结果。
 同时运行添加通道结果监听器，以便可以在IO操作完成时获取通知。
 *
 * &lt;h3&gt;Prefer {@link #addListener(GenericFutureListener)} to {@link #await()}&lt;/h3&gt;
 *
 * It is recommended to prefer {@link #addListener(GenericFutureListener)} to
 * {@link #await()} wherever possible to get notified when an I/O operation is
 * done and to do any follow-up tasks.
 强烈建议使用添加监听器的方式，而不是等待方式，等待IO操作完成，同时可以做一下一些任务。
 * &lt;p&gt;
 * {@link #addListener(GenericFutureListener)} is non-blocking.  It simply adds
 * the specified {@link ChannelFutureListener} to the {@link ChannelFuture}, and
 * I/O thread will notify the listeners when the I/O operation associated with
 * the future is done.  {@link ChannelFutureListener} yields the best
 * performance and resource utilization because it does not block at all, but
 * it could be tricky to implement a sequential logic if you are not used to
 * event-driven programming.
 添加监听器是非阻塞的。仅仅简单地添加一个通道结果监听器到异步监听结果，当IO操作关联的 异步任务完成时，IO线程将会通知监听器。通道结果监听器因为是非阻塞的，所以有更好的性能和资源利用率，如果你不使用事件驱动编程，可以实现一个时间顺序的逻辑。
 * &lt;p&gt;
 * By contrast, {@link #await()} is a blocking operation.  Once called, the
 * caller thread blocks until the operation is done.  It is easier to implement
 * a sequential logic with {@link #await()}, but the caller thread blocks
 * unnecessarily until the I/O operation is done and there's relatively
 * expensive cost of inter-thread notification.  Moreover, there's a chance of
 * dead lock in a particular circumstance, which is described below.
 相比之下，await方式是一个阻塞操作。一旦调用，调用线程将会阻塞到IO操作完成。
 使用await可以很容易实现一个时序的逻辑，但是调用线程不需要阻塞到IO操作完成，这种
 方式相对于内部线程通知，代价比较大。更进一步说，在特殊的循环下，有可能出现死锁情况，
 具体描述如下：
 *
 * &lt;h3&gt;Do not call {@link #await()} inside {@link ChannelHandler}&lt;/h3&gt;
 * &lt;p&gt;不要在通道处理器中调用await方法
 * The event handler methods in {@link ChannelHandler} are usually called by
 * an I/O thread.  If {@link #await()} is called by an event handler
 * method, which is called by the I/O thread, the I/O operation it is waiting
 * for might never complete because {@link #await()} can block the I/O
 * operation it is waiting for, which is a dead lock.
 在通道处理器内，通常有IO线程调用事件处理方法。如果await方法被IO线程调用事件处理方法调用，IO操作将会等待，同时可能因为await方法阻塞IO操作正在等待的条件，可能导致死锁，进而Io操作不能完成。
 * &lt;pre&gt;
 * // BAD - NEVER DO THIS ，坚决不要用await方式
 * {@code @Override}
 * public void channelRead({@link ChannelHandlerContext} ctx, Object msg) {
 *     {@link ChannelFuture} future = ctx.channel().close();
 *     future.awaitUninterruptibly();
 *     // Perform post-closure operation
 *     // ...
 * }
 *
 * // GOOD
 * {@code @Override} 建议方式，减价通道结果监听器
 * public void channelRead({@link ChannelHandlerContext} ctx, Object msg) {
 *     {@link ChannelFuture} future = ctx.channel().close();
 *     future.addListener(new {@link ChannelFutureListener}() {
 *         public void operationComplete({@link ChannelFuture} future) {
 *             // Perform post-closure operation
 *             // ...
 *         }
 *     });
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * In spite of the disadvantages mentioned above, there are certainly the cases
 * where it is more convenient to call {@link #await()}. In such a case, please
 * make sure you do not call {@link #await()} in an I/O thread.  Otherwise,
 * {@link BlockingOperationException} will be raised to prevent a dead lock.
 尽管await方法有诸多缺点，但在其他一些场景中，释放await方法，非常便利。在这些场景中，
 要确保不在IO线程中，调用await方法。否则阻塞操作异常将会抛出，以阻止死锁的产生。
 *

 * &lt;h3&gt;Do not confuse I/O timeout and await timeout&lt;/h3&gt;
 *不要混淆IO超时和超时等待。
 * The timeout value you specify with {@link #await(long)},
 * {@link #await(long, TimeUnit)}, {@link #awaitUninterruptibly(long)}, or
 * {@link #awaitUninterruptibly(long, TimeUnit)} are not related with I/O
 * timeout at all.  If an I/O operation times out, the future will be marked as
 * 'completed with failure,' as depicted in the diagram above.  For example,
 * connect timeout should be configured via a transport-specific option:
 在await*（*）方法中的超时时间与IO超时一点关系也没有。如果一个IO操作超时，异步结果
 将被标记为失败并完成，如果上图中的描述。比如，连接超时应该通过transport配置。
 * &lt;pre&gt;
 * // BAD - NEVER DO THIS 坚决不要使用这种方式
 * {@link Bootstrap} b = ...;
 * {@link ChannelFuture} f = b.connect(...);
 * f.awaitUninterruptibly(10, TimeUnit.SECONDS);
 * if (f.isCancelled()) {
 *     // Connection attempt cancelled by user
 * } else if (!f.isSuccess()) {
 *     // You might get a NullPointerException here because the future
 *     // might not be completed yet.
 *     f.cause().printStackTrace();
 * } else {
 *     // Connection established successfully
 * }
 *
 * // GOOD 建议方式
 * {@link Bootstrap} b = ...;
 * // Configure the connect timeout option.
 * &lt;b&gt;b.option({@link ChannelOption}.CONNECT_TIMEOUT_MILLIS, 10000);&lt;/b&gt;
 * {@link ChannelFuture} f = b.connect(...);
 * f.awaitUninterruptibly();
 *
 * // Now we are sure the future is completed.
 * assert f.isDone();
 *
 * if (f.isCancelled()) {
 *     // Connection attempt cancelled by user
 * } else if (!f.isSuccess()) {
 *     f.cause().printStackTrace();
 * } else {
 *     // Connection established successfully
 * }
 * &lt;/pre&gt;
 */
public interface ChannelFuture extends Future&lt;Void&gt; {

    /**
     * Returns a channel where the I/O operation associated with this
     * future takes place.
     返回异步结果关联IO操作所在的通道
     */
    Channel channel();
    //添加移除监听器，同步异步等待方法为空体，因为ChannelFuture继承与空异步结果，即没有返回值
    @Override
    ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);

    @Override
    ChannelFuture addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);

    @Override
    ChannelFuture removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);

    @Override
    ChannelFuture removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);

    @Override
    ChannelFuture sync() throws InterruptedException;

    @Override
    ChannelFuture syncUninterruptibly();

    @Override
    ChannelFuture await() throws InterruptedException;

    @Override
    ChannelFuture awaitUninterruptibly();

    /**
     * Returns {@code true} if this {@link ChannelFuture} is a void future and so not allow to call any of the
     * following methods:
     如果通道异步结果为void，返回ture，并不允许调用下面方法
     * [list]
     *     [*]{@link #addListener(GenericFutureListener)}

     *     [*]{@link #addListeners(GenericFutureListener[])}

     *     [*]{@link #await()}

     *     [*]{@link #await(long, TimeUnit)} ()}

     *     [*]{@link #await(long)} ()}

     *     [*]{@link #awaitUninterruptibly()}

     *     [*]{@link #sync()}

     *     [*]{@link #syncUninterruptibly()}

     * [/list]
     */
    boolean isVoid();
}
</code></pre></div></div>

<p>从上面可以看出，因为ChannelFuture继承于空异步结果，即没有返回值，所以添加移除监听器，同步异步等待方法为空体。netty所有的IO操作都是异步的，当一个IO操作开始时，不管操作是否完成，一个新的异步操作结果将会被创建。如果因为IO操作没有完成，同时既没有成功，失败，也没有取消，新创建的那么，异步结果并没有完成初始化。如果IO操作完成，不论操作结果成功，失败或取消，异步结果将会标记为完成，同时携带更多的精确信息，比如失败的原因。需要注意的时，失败或取消也属于完成状态。强烈建议使用添加监听器的方式等待IO操作结果，而不await方法，因为监听器模式时非阻塞的，有更好的性能和资源利用率。</p>

<p>再来看一通道结果监听器：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">channel</span><span class="p">;</span>
<span class="n">import</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">Future</span><span class="p">;</span>
<span class="n">import</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">GenericFutureListener</span><span class="p">;</span>


<span class="p">/**</span>
 <span class="p">*</span> <span class="n">Listens</span> <span class="k">to</span> <span class="n">the</span> <span class="n">result</span> <span class="k">of</span> <span class="n">a</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelFuture</span><span class="p">}.</span>  <span class="n">The</span> <span class="n">result</span> <span class="k">of</span> <span class="n">the</span>
 <span class="p">*</span> <span class="n">asynchronous</span> <span class="p">{@</span><span class="n">link</span> <span class="n">Channel</span><span class="p">}</span> <span class="n">I</span><span class="p">/</span><span class="n">O</span> <span class="n">operation</span> <span class="n">is</span> <span class="n">notified</span> <span class="n">once</span> <span class="n">this</span> <span class="n">listener</span>
 <span class="p">*</span> <span class="n">is</span> <span class="n">added</span> <span class="n">by</span> <span class="n">calling</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelFuture</span><span class="p">#</span><span class="n">addListener</span><span class="p">(</span><span class="n">GenericFutureListener</span><span class="p">)}.</span>
 <span class="p">*</span><span class="err">通道结果监听器</span><span class="n">ChannelFutureListener</span><span class="err">，监听通道任务的结果。一旦监听器被添加到通道任务中，</span>
 <span class="err">当通道的异步</span><span class="n">IO</span><span class="err">操作完成时，将会通知监听器。</span>
 <span class="p">*</span> <span class="p">&lt;</span><span class="n">h3</span><span class="p">&gt;</span><span class="n">Return</span> <span class="n">the</span> <span class="n">control</span> <span class="k">to</span> <span class="n">the</span> <span class="n">caller</span> <span class="n">quickly</span><span class="p">&lt;/</span><span class="n">h3</span><span class="p">&gt;</span>
 <span class="p">*</span><span class="err">快速地将控制权交给调用者</span>
 <span class="p">*</span> <span class="p">{@</span><span class="n">link</span> <span class="p">#</span><span class="n">operationComplete</span><span class="p">(</span><span class="n">Future</span><span class="p">)}</span> <span class="n">is</span> <span class="n">directly</span> <span class="n">called</span> <span class="n">by</span> <span class="n">an</span> <span class="n">I</span><span class="p">/</span><span class="n">O</span>
 <span class="p">*</span> <span class="n">thread</span><span class="p">.</span>  <span class="n">Therefore</span><span class="p">,</span> <span class="n">performing</span> <span class="n">a</span> <span class="n">time</span> <span class="n">consuming</span> <span class="n">task</span> <span class="k">or</span> <span class="n">a</span> <span class="n">blocking</span> <span class="n">operation</span>
 <span class="p">*</span> <span class="k">in</span> <span class="n">the</span> <span class="n">handler</span> <span class="n">method</span> <span class="n">can</span> <span class="n">cause</span> <span class="n">an</span> <span class="n">unexpected</span> <span class="n">pause</span> <span class="n">during</span> <span class="n">I</span><span class="p">/</span><span class="n">O</span><span class="p">.</span>  <span class="k">If</span> <span class="n">you</span> <span class="n">need</span>
 <span class="p">*</span> <span class="k">to</span> <span class="n">perform</span> <span class="n">a</span> <span class="n">blocking</span> <span class="n">operation</span> <span class="n">on</span> <span class="n">I</span><span class="p">/</span><span class="n">O</span> <span class="n">completion</span><span class="p">,</span> <span class="n">try</span> <span class="k">to</span> <span class="n">execute</span> <span class="n">the</span>
 <span class="p">*</span> <span class="n">operation</span> <span class="k">in</span> <span class="n">a</span> <span class="n">different</span> <span class="n">thread</span> <span class="n">using</span> <span class="n">a</span> <span class="n">thread</span> <span class="n">pool</span><span class="p">.</span>
<span class="p">#</span><span class="n">operationComplete</span><span class="err">直接通过</span><span class="n">IO</span><span class="err">线程调用。因此在</span><span class="n">IO</span><span class="err">操作过程中，执行一个耗时的任务或者阻塞操作在处理方法中，可能引起一个不期望的异常抛出。如果你需要执行一个阻塞操作在</span><span class="n">IO</span><span class="err">操作完成时，尝试在一个线程池中的不同线程执行操作。</span>
 <span class="p">*/</span>
<span class="k">public</span> <span class="n">interface</span> <span class="n">ChannelFutureListener</span> <span class="n">extends</span> <span class="n">GenericFutureListener</span><span class="p">&lt;</span><span class="n">ChannelFuture</span><span class="p">&gt;</span> <span class="p">{</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">A</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelFutureListener</span><span class="p">}</span> <span class="n">that</span> <span class="n">closes</span> <span class="n">the</span> <span class="p">{@</span><span class="n">link</span> <span class="n">Channel</span><span class="p">}</span> <span class="n">which</span> <span class="n">is</span>
     <span class="p">*</span> <span class="n">associated</span> <span class="k">with</span> <span class="n">the</span> <span class="n">specified</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelFuture</span><span class="p">}.</span>
     <span class="err">在操作完成时，关闭通道任务关联的通道</span>
     <span class="p">*/</span>
    <span class="n">ChannelFutureListener</span> <span class="n">CLOSE</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ChannelFutureListener</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">@</span><span class="n">Override</span>
        <span class="k">public</span> <span class="n">void</span> <span class="n">operationComplete</span><span class="p">(</span><span class="n">ChannelFuture</span> <span class="n">future</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">future</span><span class="p">.</span><span class="n">channel</span><span class="p">().</span><span class="n">close</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">A</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelFutureListener</span><span class="p">}</span> <span class="n">that</span> <span class="n">closes</span> <span class="n">the</span> <span class="p">{@</span><span class="n">link</span> <span class="n">Channel</span><span class="p">}</span> <span class="n">when</span> <span class="n">the</span>
     <span class="p">*</span> <span class="n">operation</span> <span class="n">ended</span> <span class="n">up</span> <span class="k">with</span> <span class="n">a</span> <span class="n">failure</span> <span class="k">or</span> <span class="n">cancellation</span> <span class="n">rather</span> <span class="n">than</span> <span class="n">a</span> <span class="n">success</span><span class="p">.</span>
     <span class="err">当</span><span class="n">IO</span><span class="err">操作失败时，关闭通道任务关联的通道</span>
     <span class="p">*/</span>
    <span class="n">ChannelFutureListener</span> <span class="n">CLOSE_ON_FAILURE</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ChannelFutureListener</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">@</span><span class="n">Override</span>
        <span class="k">public</span> <span class="n">void</span> <span class="n">operationComplete</span><span class="p">(</span><span class="n">ChannelFuture</span> <span class="n">future</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="c1">!future.isSuccess()) {
</span>                <span class="n">future</span><span class="p">.</span><span class="n">channel</span><span class="p">().</span><span class="n">close</span><span class="p">();</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">A</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelFutureListener</span><span class="p">}</span> <span class="n">that</span> <span class="n">forwards</span> <span class="n">the</span> <span class="p">{@</span><span class="n">link</span> <span class="n">Throwable</span><span class="p">}</span> <span class="k">of</span> <span class="n">the</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelFuture</span><span class="p">}</span> <span class="n">into</span> <span class="n">the</span>
     <span class="p">*</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelPipeline</span><span class="p">}.</span> <span class="n">This</span> <span class="n">mimics</span> <span class="n">the</span> <span class="n">old</span> <span class="n">behavior</span> <span class="k">of</span> <span class="n">Netty</span> <span class="m">3.</span>
     <span class="err">转发通道任务异常到</span><span class="n">Channel</span><span class="err">管道。默认</span><span class="n">Netty3</span><span class="err">的行为。</span>
     <span class="p">*/</span>
    <span class="n">ChannelFutureListener</span> <span class="n">FIRE_EXCEPTION_ON_FAILURE</span> <span class="p">=</span> <span class="n">new</span> <span class="n">ChannelFutureListener</span><span class="p">()</span> <span class="p">{</span>
        <span class="p">@</span><span class="n">Override</span>
        <span class="k">public</span> <span class="n">void</span> <span class="n">operationComplete</span><span class="p">(</span><span class="n">ChannelFuture</span> <span class="n">future</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="c1">!future.isSuccess()) {
</span>                <span class="n">future</span><span class="p">.</span><span class="n">channel</span><span class="p">().</span><span class="n">pipeline</span><span class="p">().</span><span class="n">fireExceptionCaught</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="n">cause</span><span class="p">());</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="p">//</span> <span class="n">Just</span> <span class="n">a</span> <span class="n">type</span> <span class="n">alias</span>
<span class="p">}</span>
</code></pre></div></div>

<p>从上面来看，通道结果监听器内部有3个监听器，分别为在操作完成时，关闭通道任务关联的通道的监听器CLOSE；当IO操作失败时，关闭通道任务关联的通道的监听器CLOSE_ON_FAILURE；转发通道任务异常到Channel管道的监听器FIRE_EXCEPTION_ON_FAILURE。</p>

<p>来看一下可写的通道结果ChannelPromise</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Special {@link ChannelFuture} which is writable.
 */
public interface ChannelPromise extends ChannelFuture, Promise&lt;Void&gt; {
在往下看之前，来看Promise接口定义：
/**
 * Special {@link Future} which is writable.
 可写的Future
 */
public interface Promise&lt;V&gt; extends Future&lt;V&gt; {

    /**
     * Marks this future as a success and notifies all
     * listeners.
     标记任务成功，通知所有监听器
     *
     * If it is success or failed already it will throw an {@link IllegalStateException}.
     如果任务已经成功完成或失败，则抛出非法状态异常
     */
    Promise&lt;V&gt; setSuccess(V result);

    /**
     * Marks this future as a success and notifies all
     * listeners.
     *标记任务成功，通知所有监听器
     * @return {@code true} if and only if successfully marked this future as
     *         a success. Otherwise {@code false} because this future is
     *         already marked as either a success or a failure.
     成功标记Future为成功完成，则返回true，如果任务已经标记成功完成或失败，则返回false
     */
    boolean trySuccess(V result);

    /**
     * Marks this future as a failure and notifies all
     * listeners.
     *标记任务失败，通知所有监听器
     * If it is success or failed already it will throw an {@link IllegalStateException}.
     如果任务已经成功完成或失败，则抛出非法状态异常
     */
    Promise&lt;V&gt; setFailure(Throwable cause);

    /**
     * Marks this future as a failure and notifies all
     * listeners.
     *标记任务失败，通知所有监听器
     * @return {@code true} if and only if successfully marked this future as
     *         a failure. Otherwise {@code false} because this future is
     *         already marked as either a success or a failure.
      成功标记Future为失败完成，则返回true，如果任务已经标记成功完成或失败，则返回false
     */
    boolean tryFailure(Throwable cause);

    /**
     * Make this future impossible to cancel.
     *标记任务不可能取消
     * @return {@code true} if and only if successfully marked this future as uncancellable or it is already done
     *         without being cancelled.  {@code false} if this future has been cancelled already.
     如果成功标记不可取消，或在没有取消的情况下已经标记，则返回true，如果任务已经取消，返回false
     */
    boolean setUncancellable();
    //下面方法与Future相同

    @Override
    Promise&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    @Override
    Promise&lt;V&gt; addListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    @Override
    Promise&lt;V&gt; removeListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    @Override
    Promise&lt;V&gt; removeListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    @Override
    Promise&lt;V&gt; await() throws InterruptedException;

    @Override
    Promise&lt;V&gt; awaitUninterruptibly();

    @Override
    Promise&lt;V&gt; sync() throws InterruptedException;

    @Override
    Promise&lt;V&gt; syncUninterruptibly();
}
</code></pre></div></div>

<p>从Promise任务定义可以看出，继承了任务Future，但多了以便标记成功、失败和不可取消的方法。</p>

<p>再来看一下</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import io.netty.util.concurrent.Future;
import io.netty.util.concurrent.GenericFutureListener;
import io.netty.util.concurrent.Promise;

/**
 * Special {@link ChannelFuture} which is writable.
 */
public interface ChannelPromise extends ChannelFuture, Promise&lt;Void&gt; {

    @Override
    Channel channel();

    @Override
    ChannelPromise setSuccess(Void result);

    ChannelPromise setSuccess();

    boolean trySuccess();

    @Override
    ChannelPromise setFailure(Throwable cause);

    @Override
    ChannelPromise addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);

    @Override
    ChannelPromise addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);

    @Override
    ChannelPromise removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);

    @Override
    ChannelPromise removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);

    @Override
    ChannelPromise sync() throws InterruptedException;

    @Override
    ChannelPromise syncUninterruptibly();

    @Override
    ChannelPromise await() throws InterruptedException;

    @Override
    ChannelPromise awaitUninterruptibly();

    /**
     * Returns a new {@link ChannelPromise} if {@link #isVoid()} returns {@code true} otherwise itself.
     如果isVoid返回true，而不它自己，则返回一个新的ChannelPromise
     */
    ChannelPromise unvoid();
}
</code></pre></div></div>

<p>从上可以看出，ChannelPromise与ChannelFuture的不同在于ChannelPromise可以标记任务结果。</p>

<p>**
总结：**
      netty的异步结果Future继承于JUC的Future，可以异步获取IO操作的结果信息，比如IO操作是否成功完成，如果失败，可以获取失败的原因，是否取消，同时可以使用cancel方法取消IO操作，添加异步结果监听器，、监听IO操作是否完成，并可以移除结果监听器，除这些之外我们还可以异步、同步等待或超时等待IO操作结果。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  异步结果监听器GenericFutureListener，主要监听一个IO操作是否完成，在异步结果有返回值时，通知监听器。 

  ChannelFuture继承于空异步结果，即没有返回值，所以添加移除监听器，同步异步等待方法为空体。netty所有的IO操作都是异步的，当一个IO操作开始时，不管操作是否完成，一个新的异步操作结果将会被创建。如果因为IO操作没有完成，同时既没有成功，失败，也没有取消，新创建的那么，异步结果并没有完成初始化。如果IO操作完成，不论操作结果成功，失败或取消，异步结果将会标记为完成，同时携带更多的精确信息，比如失败的原因。需要注意的时，失败或取消也属于完成状态。强烈建议使用添加监听器的方式等待IO操作结果，而不await方法，因为监听器模式时非阻塞的，有更好的性能和资源利用率。 

  通道结果监听器ChannelFutureListener内部有3个监听器，分别为在操作完成时，关闭通道任务关联的通道的监听器CLOSE；当IO操作失败时，关闭通道任务关联的通道的监听器CLOSE_ON_FAILURE；转发通道任务异常到Channel管道的监听器FIRE_EXCEPTION_ON_FAILURE。 

   Promise任务继承了任务Future，但多了以便标记成功、失败和不可取消的方法。 
</code></pre></div></div>

<p>ChannelPromise与ChannelFuture的不同在于ChannelPromise可以标记任务结果。</p>

<p>ChannelProgressivePromise与ProgressivePromise，ChannelProgressiveFuture的关系与ChannelPromise与Promise，ChannelFuture的关系类似，只不过ChannelPromise表示异步操作任务，ChannelProgressivePromise表示异步任务的进度，同时Promise类型异步任务都是可写的。</p>

<p>附：</p>

<p>ChannelProgressivePromise接口，简单看一下：</p>

<p>//ChannelProgressivePromise</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">channel</span><span class="p">;</span>

<span class="n">import</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">Future</span><span class="p">;</span>
<span class="n">import</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">GenericFutureListener</span><span class="p">;</span>
<span class="n">import</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">.</span><span class="n">ProgressivePromise</span><span class="p">;</span>

<span class="p">/**</span>
 <span class="p">*</span> <span class="n">Special</span> <span class="p">{@</span><span class="n">link</span> <span class="n">ChannelPromise</span><span class="p">}</span> <span class="n">which</span> <span class="n">will</span> <span class="n">be</span> <span class="n">notified</span> <span class="n">once</span> <span class="n">the</span> <span class="n">associated</span> <span class="n">bytes</span> <span class="n">is</span> <span class="n">transferring</span><span class="p">.</span>
 <span class="err">当关联的字节数据正在传输时，</span><span class="n">ChannelProgressivePromise</span><span class="err">将会被通知</span>
 <span class="p">*/</span>
<span class="k">public</span> <span class="n">interface</span> <span class="n">ChannelProgressivePromise</span> <span class="n">extends</span> <span class="n">ProgressivePromise</span><span class="p">&lt;</span><span class="n">Void</span><span class="p">&gt;,</span> <span class="n">ChannelProgressiveFuture</span><span class="p">,</span> <span class="n">ChannelPromise</span> <span class="p">{</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">addListener</span><span class="p">(</span><span class="n">GenericFutureListener</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">Future</span><span class="p">&lt;?</span> <span class="n">super</span> <span class="n">Void</span><span class="p">&gt;&gt;</span> <span class="n">listener</span><span class="p">);</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">addListeners</span><span class="p">(</span><span class="n">GenericFutureListener</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">Future</span><span class="p">&lt;?</span> <span class="n">super</span> <span class="n">Void</span><span class="p">&gt;&gt;...</span> <span class="n">listeners</span><span class="p">);</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">removeListener</span><span class="p">(</span><span class="n">GenericFutureListener</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">Future</span><span class="p">&lt;?</span> <span class="n">super</span> <span class="n">Void</span><span class="p">&gt;&gt;</span> <span class="n">listener</span><span class="p">);</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">removeListeners</span><span class="p">(</span><span class="n">GenericFutureListener</span><span class="p">&lt;?</span> <span class="n">extends</span> <span class="n">Future</span><span class="p">&lt;?</span> <span class="n">super</span> <span class="n">Void</span><span class="p">&gt;&gt;...</span> <span class="n">listeners</span><span class="p">);</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">sync</span><span class="p">()</span> <span class="n">throws</span> <span class="n">InterruptedException</span><span class="p">;</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">syncUninterruptibly</span><span class="p">();</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">await</span><span class="p">()</span> <span class="n">throws</span> <span class="n">InterruptedException</span><span class="p">;</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">awaitUninterruptibly</span><span class="p">();</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">setSuccess</span><span class="p">(</span><span class="n">Void</span> <span class="n">result</span><span class="p">);</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">setSuccess</span><span class="p">();</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">setFailure</span><span class="p">(</span><span class="n">Throwable</span> <span class="n">cause</span><span class="p">);</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">setProgress</span><span class="p">(</span><span class="n">long</span> <span class="n">progress</span><span class="p">,</span> <span class="n">long</span> <span class="n">total</span><span class="p">);</span>

    <span class="p">@</span><span class="n">Override</span>
    <span class="n">ChannelProgressivePromise</span> <span class="n">unvoid</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>//ProgressivePromise</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * Special {@link ProgressiveFuture} which is writable.
 可写的过程任务。
 */
public interface ProgressivePromise&lt;V&gt; extends Promise&lt;V&gt;, ProgressiveFuture&lt;V&gt; {

    /**
     * Sets the current progress of the operation and notifies the listeners that implement
     * {@link GenericProgressiveFutureListener}.
     设置当前操作进程，并通知监听器GenericProgressiveFutureListener
     */
    ProgressivePromise&lt;V&gt; setProgress(long progress, long total);

    /**
     * Tries to set the current progress of the operation and notifies the listeners that implement
     * {@link GenericProgressiveFutureListener}.  If the operation is already complete or the progress is out of range,
     * this method does nothing but returning {@code false}.
     设置当前操作进程，并通知监听器GenericProgressiveFutureListener。如果此操作已经完成，进度已经超过范围，
     此方法不会做任何事情，仅仅返回false。
     */
    boolean tryProgress(long progress, long total);

    @Override
    ProgressivePromise&lt;V&gt; setSuccess(V result);

    @Override
    ProgressivePromise&lt;V&gt; setFailure(Throwable cause);

    @Override
    ProgressivePromise&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    @Override
    ProgressivePromise&lt;V&gt; addListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    @Override
    ProgressivePromise&lt;V&gt; removeListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    @Override
    ProgressivePromise&lt;V&gt; removeListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    @Override
    ProgressivePromise&lt;V&gt; await() throws InterruptedException;

    @Override
    ProgressivePromise&lt;V&gt; awaitUninterruptibly();

    @Override
    ProgressivePromise&lt;V&gt; sync() throws InterruptedException;

    @Override
    ProgressivePromise&lt;V&gt; syncUninterruptibly();
}
</code></pre></div></div>

<p>//GenericProgressiveFutureListener</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">io</span><span class="p">.</span><span class="n">netty</span><span class="p">.</span><span class="n">util</span><span class="p">.</span><span class="n">concurrent</span><span class="p">;</span>

<span class="k">public</span> <span class="n">interface</span> <span class="n">GenericProgressiveFutureListener</span><span class="p">&lt;</span><span class="n">F</span> <span class="n">extends</span> <span class="n">ProgressiveFuture</span><span class="p">&lt;?&gt;&gt;</span> <span class="n">extends</span> <span class="n">GenericFutureListener</span><span class="p">&lt;</span><span class="n">F</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="p">/**</span>
     <span class="p">*</span> <span class="n">Invoked</span> <span class="n">when</span> <span class="n">the</span> <span class="n">operation</span> <span class="n">has</span> <span class="n">progressed</span><span class="p">.</span>
     <span class="p">*</span><span class="err">操作已经达到所设的进度</span>
     <span class="p">*</span> <span class="p">@</span><span class="n">param</span> <span class="n">progress</span> <span class="n">the</span> <span class="n">progress</span> <span class="k">of</span> <span class="n">the</span> <span class="n">operation</span> <span class="n">so</span> <span class="n">far</span> <span class="p">(</span><span class="n">cumulative</span><span class="p">)</span><span class="err">，操作当前进度</span>
     <span class="p">*</span> <span class="p">@</span><span class="n">param</span> <span class="n">total</span> <span class="n">the</span> <span class="n">number</span> <span class="n">that</span> <span class="n">signifies</span> <span class="n">the</span> <span class="k">end</span> <span class="k">of</span> <span class="n">the</span> <span class="n">operation</span> <span class="n">when</span> <span class="p">{@</span><span class="n">code</span> <span class="n">progress</span><span class="p">}</span> <span class="n">reaches</span> <span class="n">at</span> <span class="n">it</span><span class="p">.</span>
     <span class="p">*</span>              <span class="p">{@</span><span class="n">code</span> <span class="p">-</span><span class="m">1</span><span class="p">}</span> <span class="k">if</span> <span class="n">the</span> <span class="k">end</span> <span class="k">of</span> <span class="n">operation</span> <span class="n">is</span> <span class="n">unknown</span><span class="p">.</span>
     <span class="n">total</span><span class="err">，当操作完成时达到的进度，如果操作的结束点不确定，则为</span><span class="p">-</span><span class="m">1</span>
     <span class="p">*/</span>
    <span class="n">void</span> <span class="n">operationProgressed</span><span class="p">(</span><span class="n">F</span> <span class="n">future</span><span class="p">,</span> <span class="n">long</span> <span class="n">progress</span><span class="p">,</span> <span class="n">long</span> <span class="n">total</span><span class="p">)</span> <span class="n">throws</span> <span class="n">Exception</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>//ProgressiveFuture</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>**
 * A {@link Future} which is used to indicate the progress of an operation.
 表示一个操作的进度
 */
public interface ProgressiveFuture&lt;V&gt; extends Future&lt;V&gt; {

    @Override
    ProgressiveFuture&lt;V&gt; addListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    @Override
    ProgressiveFuture&lt;V&gt; addListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    @Override
    ProgressiveFuture&lt;V&gt; removeListener(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt; listener);

    @Override
    ProgressiveFuture&lt;V&gt; removeListeners(GenericFutureListener&lt;? extends Future&lt;? super V&gt;&gt;... listeners);

    @Override
    ProgressiveFuture&lt;V&gt; sync() throws InterruptedException;

    @Override
    ProgressiveFuture&lt;V&gt; syncUninterruptibly();

    @Override
    ProgressiveFuture&lt;V&gt; await() throws InterruptedException;

    @Override
    ProgressiveFuture&lt;V&gt; awaitUninterruptibly();
}
</code></pre></div></div>

<p>//ChannelProgressiveFuture</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/**
 * An special {@link ChannelFuture} which is used to indicate the {@link FileRegion} transfer progress
 表示一个文件region的传输进度
 */
public interface ChannelProgressiveFuture extends ChannelFuture, ProgressiveFuture&lt;Void&gt; {
    @Override
    ChannelProgressiveFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);

    @Override
    ChannelProgressiveFuture addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);

    @Override
    ChannelProgressiveFuture removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt; listener);

    @Override
    ChannelProgressiveFuture removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void&gt;&gt;... listeners);

    @Override
    ChannelProgressiveFuture sync() throws InterruptedException;

    @Override
    ChannelProgressiveFuture syncUninterruptibly();

    @Override
    ChannelProgressiveFuture await() throws InterruptedException;

    @Override
    ChannelProgressiveFuture awaitUninterruptibly();
}
</code></pre></div></div>

  </div><div style="width:300px;height:250px;float:left;">
    <!-- 300_250_1 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="4142158067"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<div style="width:300px;height:250px;float:left;">
    <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <!-- 300-250-2 -->
    <ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196"
        data-ad-slot="5618891265"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div><a class="u-url" href="/2017/netty%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1channelfuture.html" hidden></a>
</article>
<div class="PageNavigation">
  
  <a class="prev" href="/2017/%E6%B5%85%E8%B0%88servlet%E5%92%8Cfilter%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%B8%A4%E8%80%85%E5%9C%A8struts2%E5%92%8Cspringmvc%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8.html">&laquo; 浅谈Servlet和Filter的区别以及两者在Struts2和Springmvc中的应用</a>
  
  
  <a class="next" href="/2017/jooq%E4%B8%AD%E6%96%872jooq%E4%B8%8Espring%E5%92%8Cdruid%E9%9B%86%E6%88%90.html">【jOOQ中文】2. jOOQ与Spring和Druid集成 &raquo;</a>
  
</div>
<div class="sfix"><!-- 240x600 -->
<div class="fixedme">
    <ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460"
        data-ad-format="auto"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
</div>
<script type="text/javascript">
    function offset(target) {
        var top = 0,
            left = 0

        while (target.offsetParent) {
            top += target.offsetTop
            left += target.offsetLeft
            target = target.offsetParent
        }

        return {
            top: top,
            left: left,
        }
    }
    window.onload = function () {
        var e = document.getElementsByClassName('sfix')[0];
        e.offset = offset(e);

        window.onscroll = function (event) {
            var e = document.getElementsByClassName('sfix')[0];
            if (window.pageYOffset && e.offset && window.pageYOffset > e.offset.top) {
                e.style.position = 'fixed';
                e.style.left = e.offset.left + 'px';
                e.style.right = 'auto';


            } else {
                e.style.position = 'absolute';
                e.style.left = 'auto';
                e.style.right = '-240px';

            }
        }
    }

</script></div>

<style>
  .wrapper {
    position: relative;
  }

  .sfix {
    position: absolute;
    top: 0;
    right: -240px;
    width: 240px;
    height: 600px;
  }

  .PageNavigation {
    font-size: 14px;
    display: block;
    width: auto;
    overflow: hidden;
    clear: both;
  }

  .PageNavigation a {
    display: block;
    width: 50%;
    float: left;
    margin: 1em 0;
  }

  .PageNavigation .next {
    text-align: right;
    float: right;
  }
</style>
      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java面试</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java面试</li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"></ul>
</div>

      <div class="footer-col footer-col-3">
        <p></p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
