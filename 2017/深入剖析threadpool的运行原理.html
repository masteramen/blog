<!-- build time:Sat Oct 27 2018 21:00:19 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="深入剖析ThreadPool的运行原理线程在执行任务时，正常的情况是这样的：Thread  t=new Thread(new  Runnable() {                         @Override             public void run() {                 // TODO Auto-generated method stub"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="深入剖析ThreadPool的运行原理"><meta property="og:url" content="http://www.jfox.info/2017/深入剖析threadpool的运行原理.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="深入剖析ThreadPool的运行原理线程在执行任务时，正常的情况是这样的：Thread  t=new Thread(new  Runnable() {                         @Override             public void run() {                 // TODO Auto-generated method stub"><meta property="og:locale" content="zh_CN"><meta property="og:updated_time" content="2018-10-27T12:29:40.334Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="深入剖析ThreadPool的运行原理"><meta name="twitter:description" content="深入剖析ThreadPool的运行原理线程在执行任务时，正常的情况是这样的：Thread  t=new Thread(new  Runnable() {                         @Override             public void run() {                 // TODO Auto-generated method stub"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/深入剖析threadpool的运行原理.html"><title>深入剖析ThreadPool的运行原理 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/深入剖析threadpool的运行原理.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">深入剖析ThreadPool的运行原理</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:55:27+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="深入剖析ThreadPool的运行原理"><a href="#深入剖析ThreadPool的运行原理" class="headerlink" title="深入剖析ThreadPool的运行原理"></a>深入剖析ThreadPool的运行原理</h1><p>线程在执行任务时，正常的情况是这样的：</p><pre><code>Thread  t=new Thread(new  Runnable() {            
            @Override
            public void run() {
                // TODO Auto-generated method stub    
            }
        });

        t.start();
</code></pre><p>Thread 在初始化的时候传入一个Runnable,以后就没有机会再传入一个Runable了。那么，woker作为一个已经启动的线程。是如何不断获取Runnable的呢？这个时候可以使用一个包装器，将线程包装起来，在Run方法内部获取任务。</p><pre><code>public final class Worker implements Runnable {
    Thread thread = null;
    Runnable task;
    private BlockingQueue&lt;Runnable&gt; queues;
    public Worker(Runnable task, BlockingQueue&lt;Runnable&gt; queues) {
        this.thread = new Thread(this);
        this.task = task;
        this.queues = queues;
    }
    public void run() {
        if (task != null) {
            task.run();
        } 
            try {
                while (true) {
                    task = queues.take();
                    if (task != null) {
                        task.run();
                    }
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    public void start() {
        this.thread.start();
    }
}

public class Main {
    public static void main(String[] args) {
        BlockingQueue&lt;Runnable&gt; queues=new ArrayBlockingQueue&lt;Runnable&gt;(100);
        Worker  worker=new Worker(new Runnable() {
            public void run() {
                System.out.println(&quot;hello!!! &quot;);
                try {
                    Thread.currentThread().sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }            
            }
        }, queues);
        worker.start();
        for(int i=0;i&lt;100;i++){
            queues.offer(new Runnable() {
                public void run() {
                    System.out.println(&quot;hello!!! &quot;);
                    try {
                        Thread.currentThread().sleep(3000);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }

}
</code></pre><p>这样我们就简单地实现了一个“线程池”（可以将这个“线程池”改造成官方的模式，不过可以自己尝试一下）。ThreadPool的这种实现模式是并发编程中经典的Cyclic Work Distribution模式。  那么，这种实现的线程池性能如何呢？  由于其任务队列使用的是阻塞队列，在队列内部是自旋的。Reeteenlok是改进的CLH队列。自旋锁会耗费一定CPU的资源，在拥有大量任务执行下的情况下比较有效。而且，线程池中的线程并没有睡眠，而是进入了自旋状态。</p><h2 id="CPU的线程与关系"><a href="#CPU的线程与关系" class="headerlink" title="CPU的线程与关系"></a>CPU的线程与关系</h2><p>如果是不支持超线程的CPU，在同一时刻的确只能处理2个线程，但是并不意味着双核的CPU只能处理两个线程，它可以通过切换上下文来执行多个线程。比如我只有一个大脑，但是我要处理5个人提交的任务，我可以处理完A的事情后，把事情的中间结果保存下，然后再处理B的，然后再读取A的中间结果，处理A的事情。</p><h1 id="JDK中的线程池实现分析"><a href="#JDK中的线程池实现分析" class="headerlink" title="JDK中的线程池实现分析"></a>JDK中的线程池实现分析</h1><p>Woker自身继承了Runnable,并对Thread做了一个包装。Woker代码如下所示：</p><pre><code>private final class Worker
        extends AbstractQueuedSynchronizer
        implements Runnable
    {

        private static final long serialVersionUID = 6138294804551838833L;


        Runnable firstTask;

        volatile long completedTasks;


        Worker(Runnable firstTask) {
            setState(-1); // inhibit interrupts until runWorker
            this.firstTask = firstTask;
            this.thread = getThreadFactory().newThread(this);
        }
        public void run() {
            runWorker(this);
        }
        protected boolean isHeldExclusively() {
            return getState() != 0;
        }

        protected boolean tryAcquire(int unused) {
            if (compareAndSetState(0, 1)) {
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            }
            return false;
        }

        protected boolean tryRelease(int unused) {
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        }

        public void lock()        { acquire(1); }
        public boolean tryLock()  { return tryAcquire(1); }
        public void unlock()      { release(1); }
        public boolean isLocked() { return isHeldExclusively(); }

        void interruptIfStarted() {
            Thread t;
            if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) {
                try {
                    t.interrupt();
                } catch (SecurityException ignore) {
                }
            }
        }
    }
</code></pre><p>execute(Runnable command)方法内部是这样的：</p><pre><code>public void execute(Runnable command) {
       if (command == null)
           throw new NullPointerException();

       int c = ctl.get();
       if (workerCountOf(c) &lt; corePoolSize) {
           if (addWorker(command, true))
               return;
           c = ctl.get();
       }
       if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
           int recheck = ctl.get();
           if (! isRunning(recheck) &amp;&amp; remove(command))
               reject(command);
           else if (workerCountOf(recheck) == 0)
               addWorker(null, false);
       }
       else if (!addWorker(command, false))
           reject(command);
   }
</code></pre><p>ctl一个合并类型的值。将当前线程数和线程池状态通过数学运算合并到了一个值。具体是如何合并的可以参看一下源码，这里就不叙述了。继续向下走：</p><pre><code>if (workerCountOf(c) &lt; corePoolSize) {
            if (addWorker(command, true))
                return;
            c = ctl.get();
        }
</code></pre><p>可以看到，如果当前线程数量小于了核心线程数量corePoolSize，就直接增加线程处理任务。与队列没有关系。但是紧接着又检查了一遍状态，因为在这个过程中，别的线程也可能在添加任务。继续向下走：</p><pre><code>if (isRunning(c) &amp;&amp; workQueue.offer(command)) {
          int recheck = ctl.get();
          if (! isRunning(recheck) &amp;&amp; remove(command))
              reject(command);
          else if (workerCountOf(recheck) == 0)
              addWorker(null, false);
      }
</code></pre><p>可以看到如果线程池是运行态的，就把线程添加到任务队列。workQueue是构造函数传递过来的，可以是有界队列，也可以是无界队列。可以看出来，队列如果是无界的，直接往队列里面添加任务，这个时候，线程池中的线程也不会增加，一直会等于核心线程数。  如果队列是有界的，就尝试直接新增线程处理任务，如果添加任务失败，就调用reject方法来处理添加失败的任务：</p><pre><code>else if (!addWorker(command, false))
           reject(command);
</code></pre><p>来看看addWorker是如何实现的，逻辑流程已经直接在注释中说明了。</p><pre><code>private boolean addWorker(Runnable firstTask, boolean core) {
        retry:
        for (;;) {
            int c = ctl.get();
            int rs = runStateOf(c);
            //如果状态大于SHUTDOWN，不再接受新的任务，直接返回
            if (rs &gt;= SHUTDOWN &amp;&amp;
                ! (rs == SHUTDOWN &amp;&amp;
                   firstTask == null &amp;&amp;
                   ! workQueue.isEmpty()))
                return false;

/**根据core来判断，如果当前线程数量大于corePoolSize或者最大线程数，直接返回。添加任务失败。
**如果队列是有界的或者任务添加到队列失败(参数core是false)，那么就会新开一个线程处理业务，但如果线程已经大于了maximumPoolSize，就会出现添加失败，返回false。
*/

            for (;;) {
                int wc = workerCountOf(c);
                if (wc &gt;= CAPACITY ||
                    wc &gt;= (core ? corePoolSize : maximumPoolSize))
                    return false;

                if (compareAndIncrementWorkerCount(c))
                    break retry;
                c = ctl.get();  // Re-read ctl
                if (runStateOf(c) != rs)
                    continue retry;
                // else CAS failed due to workerCount change; retry inner loop
            }
        }

        boolean workerStarted = false;
        boolean workerAdded = false;
        Worker w = null;
        try {
            w = new Worker(firstTask);
            final Thread t = w.thread;
            if (t != null) {
                final ReentrantLock mainLock = this.mainLock;
                mainLock.lock();
                try {
                    // Recheck while holding lock.
                    // Back out on ThreadFactory failure or if
                    // shut down before lock acquired.
                    int rs = runStateOf(ctl.get());

                    if (rs &lt; SHUTDOWN ||
                        (rs == SHUTDOWN &amp;&amp; firstTask == null)) {
                        if (t.isAlive()) // precheck that t is startable
                            throw new IllegalThreadStateException();
                        workers.add(w);
                        int s = workers.size();
                        if (s &gt; largestPoolSize)
                            largestPoolSize = s;
                        workerAdded = true;
                    }
                } finally {
                    mainLock.unlock();
                }
                if (workerAdded) {
                    t.start();
                    workerStarted = true;
                }
            }
        } finally {
            if (! workerStarted)
                addWorkerFailed(w);
        }
        return workerStarted;
    }
</code></pre><p>如果创建失败的情况下会调用addWorkerFailed方法，从而将减少实际线程数。</p><h2 id="addWorker中for循环的意义"><a href="#addWorker中for循环的意义" class="headerlink" title="addWorker中for循环的意义"></a>addWorker中for循环的意义</h2><p>在addWorker中有这么一段代码，表示为当前线程数加1：</p><pre><code>private boolean compareAndIncrementWorkerCount(int expect) {
      return ctl.compareAndSet(expect, expect + 1);
  }
</code></pre><p>由于多线程可能同时操作。expect值可能会变化。仅仅一次的操作compareAndIncrementWorkerCount可能一次并不会成功，而且，一个线程在执行addWork的过程中间，另外一个线程假设直接shotdown这个线程池。for循环的存在可以保证状态一定是一致的。</p><h2 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h2><p>在Worker中间实际上是调用的runWorker方法来执行的具体业务：</p><pre><code>final void runWorker(Worker w) {
        Thread wt = Thread.currentThread();
        Runnable task = w.firstTask;
        w.firstTask = null;
        w.unlock(); // allow interrupts
        boolean completedAbruptly = true;
        try {
            while (task != null || (task = getTask()) != null) {
                w.lock();
                if ((runStateAtLeast(ctl.get(), STOP) ||
                     (Thread.interrupted() &amp;&amp;
                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;
                    !wt.isInterrupted())
                    wt.interrupt();
                try {
                    beforeExecute(wt, task);
                    Throwable thrown = null;
                    try {
                        task.run();
                    } catch (RuntimeException x) {
                        thrown = x; throw x;
                    } catch (Error x) {
                        thrown = x; throw x;
                    } catch (Throwable x) {
                        thrown = x; throw new Error(x);
                    } finally {
                        afterExecute(task, thrown);
                    }
                } finally {
                    task = null;
                    w.completedTasks++;
                    w.unlock();
                }
            }
            completedAbruptly = false;
        } finally {
            processWorkerExit(w, completedAbruptly);
        }
    }
</code></pre><p>可以看到while循环不断的从队列中取出任务执行。如果task==null 并且getTask()等于null的话，那么就会跳出循环，进入到processWorkerExit，run方法执行完毕以后，这个线程也被销毁了。但是为什么在各自的线程执行，为什么还需要加锁呢？答案是因为要线程池需要判断这个线程是否在执行任务。在interruptIdleWorkers方法中，要中断那写目前空闲的线程，通过当前Worker是否获得了锁就能判断这个worker是否是空闲的:</p><pre><code>private void interruptIdleWorkers(boolean onlyOne) {
     final ReentrantLock mainLock = this.mainLock;
     mainLock.lock();
     try {
         for (Worker w : workers) {
             Thread t = w.thread;
             if (!t.isInterrupted() &amp;&amp; w.tryLock()) {
                 try {
                     t.interrupt();
                 } catch (SecurityException ignore) {
                 } finally {
                     w.unlock(); //中断不起作用。interrupt()对于自旋锁是不起作用的。只是逻辑上被阻塞，
                 }
             }
             if (onlyOne)
                 break;
         }
     } finally {
         mainLock.unlock();
     }
 }
</code></pre><p>可以看到，如果w.tryLock()可以获取到锁，那么就意味着当前的 Woker并没有处理任务（没有进入到循环里面或者被getTask方法所阻塞，无法获取锁）。Work之所以继承AbstractQueuedSynchronizer，而不去使用ReentrantLock。是因为ReentrantLock是可重入锁，在调用lock方法获取锁之后，再调用tryLock()还是会返回true。</p><pre><code>public static void main(String[] args) {
        ReentrantLock lock = new ReentrantLock();
        lock.lock();
        System.out.println(lock.tryLock());        
    }
</code></pre><p>输出结果是true，所以使用ReentrantLock则难以判断当前Worker是否在执行任务。</p><h2 id="线程超时allowCoreThreadTimeOut、keepAliveTime以及线程死亡"><a href="#线程超时allowCoreThreadTimeOut、keepAliveTime以及线程死亡" class="headerlink" title="线程超时allowCoreThreadTimeOut、keepAliveTime以及线程死亡"></a>线程超时allowCoreThreadTimeOut、keepAliveTime以及线程死亡</h2><p>在上面的interruptIdleWorkers方法中，线程被中断。普通的线程被中断会导致线程继续执行，从而run方法运行完毕，线程退出。</p><p>对于一个没有被阻塞的线程，中断是不起作用的。中断在如下线程被阻塞的方法中起作用：the wait(), wait(long), wait(long, int) join(), join(long), join(long, int), sleep(long), or sleep(long, int)LockSupport.park(Object object);LockSupport.park();</p><p>，如果唤醒这些被阻塞的线程，从而能使得run方法继续执行，当run方法执行完毕，那么线程也就终结死亡。但是对于ReentrantLock和AbstractQueuedSynchronizer这种自旋+CAS实现的“逻辑锁”，是不起作用的。而且runWork本身也是While循环，靠中断是无法退出循环的。</p><p>但是在ThreadPoolExecutor的构造函数中，有一个允许设置线程超时allowCoreThreadTimeOut参数的方法。如果允许超时，多于corePoolSize的线程将会在处在空闲状态之后存活keepAliveTime时长后终止。因此有了一个allowCoreThreadTimeOut方法：</p><pre><code>public void allowCoreThreadTimeOut(boolean value) {
       if (value &amp;&amp; keepAliveTime &lt;= 0)
           throw new IllegalArgumentException(&quot;Core threads must have nonzero keep alive times&quot;);
       if (value != allowCoreThreadTimeOut) {
           allowCoreThreadTimeOut = value;
           if (value)
               interruptIdleWorkers();
       }
   }
</code></pre><p>正如上面提到的一样，允许allowCoreThreadTimeOut并且调用interruptIdleWorkers方法并不能使线程退出。那么线程池又如何杀掉这个线程呢？  没错，就是getTask方法。只有当getTask返回null的时候才能跳出While循环，run方法运行完毕，那么线程自然而然就死亡了。getTask方法如下所示：</p><pre><code>private Runnable getTask() {
      boolean timedOut = false; // Did the last poll() time out?
      for (;;) {
          int c = ctl.get();
          int rs = runStateOf(c);

          // Check if queue empty only if necessary.
          if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
              decrementWorkerCount();
              return null;
          }

          int wc = workerCountOf(c);
          // Are workers subject to culling?
          boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
          if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
              &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
              if (compareAndDecrementWorkerCount(c))
                  return null;
              continue;
          }
          try {
              Runnable r = timed ?
                  workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                  workQueue.take();
              if (r != null)
                  return r;
              timedOut = true;
          } catch (InterruptedException retry) {
              timedOut = false;
          }
      }
  }
</code></pre><p>可以看到，如果线程池状态大于SHUTDOWN并且队列空，返回null，从而结束循环。（线程死亡）</p><p>或者状态大于SHUTDOWN并且线程大于STOP（STOP一定大于SHUTDOWN，所以可以直接说线程大于STOP）返回null，从而结束循环。（线程死亡）再往下可以看到如果超过了maximumPoolSize，返回null，从而结束循环。（线程死亡）超过keepAliveTime时间，任务对列没有数据而返回null。从而结束循环。（线程死亡）<code>boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</code>保证了线程池至少留下corePoolSize个线程。</p><h2 id="预定义的拒接处理协议"><a href="#预定义的拒接处理协议" class="headerlink" title="预定义的拒接处理协议"></a>预定义的拒接处理协议</h2><p>在execute方法中，如果线程池拒绝添加任务，就会有一个钩子方法来处理被拒绝的任务。可以自己定义，也可以使用线城池中默认的拒接处理协议。</p><p>AbortPolicy :直接抛出RejectedExecutionException异常；</p><p>CallerRunsPolicy：谁调用的execute方法，谁就执行这个任务；</p><p>DiscardPolicy:直接丢弃，什么也不做；</p><p>DiscardOldestPolicy：丢弃对列中间最老的任务，执行新任务。</p><p>有什么问题或者建议，可以加入小密圈和我一起讨论，或者在简书留言，欢迎喜欢和打赏。</p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/死磕java并发juc之java并发容器concurrentlinkedqueue.html" rel="next" title="【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentLinkedQueue"><i class="fa fa-chevron-left"></i> 【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentLinkedQueue</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/为什么要招老程序员这5个理由或许说服你.html" rel="prev" title="为什么要招老程序员？这 5 个理由或许说服你">为什么要招老程序员？这 5 个理由或许说服你 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#深入剖析ThreadPool的运行原理"><span class="nav-number">1.</span> <span class="nav-text">深入剖析ThreadPool的运行原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#CPU的线程与关系"><span class="nav-number">1.1.</span> <span class="nav-text">CPU的线程与关系</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JDK中的线程池实现分析"><span class="nav-number">2.</span> <span class="nav-text">JDK中的线程池实现分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#addWorker中for循环的意义"><span class="nav-number">2.1.</span> <span class="nav-text">addWorker中for循环的意义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#任务的执行"><span class="nav-number">2.2.</span> <span class="nav-text">任务的执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程超时allowCoreThreadTimeOut、keepAliveTime以及线程死亡"><span class="nav-number">2.3.</span> <span class="nav-text">线程超时allowCoreThreadTimeOut、keepAliveTime以及线程死亡</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预定义的拒接处理协议"><span class="nav-number">2.4.</span> <span class="nav-text">预定义的拒接处理协议</span></a></li></ol></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->