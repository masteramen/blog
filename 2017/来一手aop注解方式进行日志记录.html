<!-- build time:Sat Oct 27 2018 21:00:17 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="系统日志对于定位/排查问题的重要性不言而喻，相信许多开发和运维都深有体会。通过日志追踪代码运行状况，模拟系统执行情况，并迅速定位代码/部署环境问题。系统日志同样也是数据统计/建模的重要依据，通过分析系统日志能窥探出许多隐晦的内容。如系统的健壮性(服务并发访问/数据库交互/整体响应时间…)某位用户的喜好(分析用户操作习惯，推送对口内容…)当然系统开发者还不满足于日志组件打印出来的日志，毕竟冗余且篇幅"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="来一手 AOP 注解方式进行日志记录"><meta property="og:url" content="http://www.jfox.info/2017/来一手aop注解方式进行日志记录.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="系统日志对于定位/排查问题的重要性不言而喻，相信许多开发和运维都深有体会。通过日志追踪代码运行状况，模拟系统执行情况，并迅速定位代码/部署环境问题。系统日志同样也是数据统计/建模的重要依据，通过分析系统日志能窥探出许多隐晦的内容。如系统的健壮性(服务并发访问/数据库交互/整体响应时间…)某位用户的喜好(分析用户操作习惯，推送对口内容…)当然系统开发者还不满足于日志组件打印出来的日志，毕竟冗余且篇幅"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2017/1427/00d2619.png"><meta property="og:image" content="http://www.jfox.info/2017/1427/8200ed7.gif"><meta property="og:image" content="http://www.jfox.info/wp-content/uploads/2017/07/1501508453.gif"><meta property="og:image" content="http://www.jfox.info/2017/1427/c738520.png"><meta property="og:updated_time" content="2018-10-27T12:29:37.413Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="来一手 AOP 注解方式进行日志记录"><meta name="twitter:description" content="系统日志对于定位/排查问题的重要性不言而喻，相信许多开发和运维都深有体会。通过日志追踪代码运行状况，模拟系统执行情况，并迅速定位代码/部署环境问题。系统日志同样也是数据统计/建模的重要依据，通过分析系统日志能窥探出许多隐晦的内容。如系统的健壮性(服务并发访问/数据库交互/整体响应时间…)某位用户的喜好(分析用户操作习惯，推送对口内容…)当然系统开发者还不满足于日志组件打印出来的日志，毕竟冗余且篇幅"><meta name="twitter:image" content="http://www.jfox.info/2017/1427/00d2619.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2017/来一手aop注解方式进行日志记录.html"><title>来一手 AOP 注解方式进行日志记录 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2017/来一手aop注解方式进行日志记录.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">来一手 AOP 注解方式进行日志记录</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-01T23:58:47+08:00">2017-01-01</time></span></div></header><div class="post-body" itemprop="articleBody"><p>系统日志对于定位/排查问题的重要性不言而喻，相信许多开发和运维都深有体会。</p><p>通过日志追踪代码运行状况，模拟系统执行情况，并迅速定位代码/部署环境问题。</p><p>系统日志同样也是数据统计/建模的重要依据，通过分析系统日志能窥探出许多隐晦的内容。</p><p>如系统的健壮性(服务并发访问/数据库交互/整体响应时间…)</p><p>某位用户的喜好(分析用户操作习惯，推送对口内容…)</p><p>当然系统开发者还不满足于日志组件打印出来的日志，毕竟冗余且篇幅巨长。</p><p>so,对于关键的系统操作设计日志表，并在代码中进行操作的记录，配合 SQL 统计和搜索数据是件很愉快的事情。</p><p>本篇旨在总结在 Spring 下使用 AOP 注解方式进行日志记录的过程，如果能对你有所启发阁下不甚感激。</p><ol><li><p>依赖类库</p><dependency><groupid>org.aspectj</groupid><artifactid>aspectjweaver</artifactid><version>${aspectjweaver.version}</version></dependency><p>AspectJ 中的很多语法结构基本上已成为 AOP 领域的标准。</p><p>Spring 也有自己的 Spring-AOP，采用运行时生成代理类，底层可以选用 JDK 或者 CGLIB 动态代理。</p><p>通俗点，AspectJ 在编译时增强要切入的类，而 Spring-AOP 是在运行时通过代理类增强切入的类，效率和性能可想而知。</p><p>Spring 在 2.0 的时候就已经开始支持 AspectJ ，现在到 4.X 的时代已经很完美的和 AspectJ 拥抱到了一起。</p></li></ol><p>2.定义切入点日志注解</p><p><img src="/2017/1427/00d2619.png" alt=""></p><p>目标操作日志表，其中设计了一些必要的字段，具体字体请拿捏你们自己的项目场景，根据表结构设计注解如下。</p><pre><code>@Inherited
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface OperationLog {

    String operationModular() default &quot;&quot;;

    String operationContent() default &quot;&quot;;
}
</code></pre><p>上述我只做了两个必要的参数，一个为操作的模块，一个为具体的操作内容。</p><p>其实根据项目场景这里参数的设计可以非常丰富，不被其他程序员吐槽在此一举。</p><p>3.编写处理日志切点类</p><pre><code>@Pointcut(&quot;@annotation(com.rambo.spm.common.aop.OperationLog)&quot;)
 publicvoid operationLogAspect() {

 }
</code></pre><p>类的构造函数上描述了该类要拦截的为 OperationLog 的注解方法， 同样你也可以配置 XML 进行拦截。</p><p>切入点的姿势有很多，不仅是正则同样也支持组合表达式，强大的表达式能让你精准的切入到任何你想要的地方。</p><p>更多详情：<a href="https://www.jfox.info/go.php?url=http://blog.csdn.net/zhengchao1991/article/details/53391244">http://blog.csdn.net/zhengchao1991/article/details/53391244</a></p><pre><code>    @Before(&quot;operationLogAspect()&quot;)
    publicvoid doBefore(JoinPoint joinPoint) {
        logger.info(&quot;before aop：{}&quot;, joinPoint);
        //do something    }

    @Around(&quot;operationLogAspect()&quot;)
    public Object doAround(ProceedingJoinPoint point) {
        logger.info(&quot;Around:{}&quot;, point);
        Object proceed = null;
        try {
            proceed = point.proceed();

            //do somthing
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            logger.error(&quot;日志 aop 异常信息:{}&quot;, throwable.getMessage());
        }
        return proceed;
    }

    @AfterThrowing(&quot;operationLogAspect()&quot;)
    publicvoid doAfterThrowing(JoinPoint pjp) {
        logger.info(&quot;@After:{}&quot;, pjp);
        //do somthing    }

    @After(&quot;operationLogAspect()&quot;)
    publicvoid doAfter(JoinPoint pjp) {
        logger.info(&quot;@After:{}&quot;, pjp);
    }

    @AfterReturning(&quot;operationLogAspect()&quot;)
    publicvoid doAfterReturning(JoinPoint point) {
        logger.info(&quot;@AfterReturning:{}&quot;, point);
    }

AspectJ 提供了几种通知方法，通过在方法上注解这几种通知，解析对应的方法入参，你就能洞悉切点的一切运行情况。
</code></pre><p>前置通知（@Before）：在某连接点（join point）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）；</p><p>返回后通知（@AfterReturning）：在某连接点（join point）正常完成后执行的通知：例如，一个方法没有抛出任何异常，正常返回；</p><p>抛出异常后通知（@AfterThrowing）：方法抛出异常退出时执行的通知；</p><p>后通知（@After）：当某连接点退出的时候执行的通知（不论是正常返回还是异常退出）；</p><p>环绕通知（@Around）：包围一个连接点（joinpoint）的通知，如方法调用；</p><p>通知方法中的值与构造函数一致，指定该通知对哪个切点有效，</p><p>上述 @Around 为最强大的一种通知类型，可以在方法调用前后完成自定义的行为，它可选择是否继续执行切点、直接返回、抛出异常来结束执行。</p><p>@Around 之所以如此强大是和它的入参有关，别的注解注解入参只容许 JoinPoint ，而 @Around 注解容许入参 ProceedingJoinPoint。</p><pre><code>package org.aspectj.lang;

import org.aspectj.runtime.internal.AroundClosure;

publicinterface ProceedingJoinPoint extends JoinPoint {
    void set$AroundClosure(AroundClosure var1);

    Object proceed() throws Throwable;

    Object proceed(Object[] var1) throws Throwable;
}
</code></pre><p>反编译 ProceedingJoinPoint 你会恍然大悟，Proceedingjoinpoint 继承了 JoinPoint 。</p><p>在 JoinPoint 的基础上暴露出 proceed 这个方法。proceed 方法很重要，这是 aop 代理链执行的方法。</p><p>暴露出这个方法，就能支持 aop:around 这种切面（而其他的几种切面只需要用到 JoinPoint，这跟切面类型有关）， 能决定是否走代理链还是走自己拦截的其他逻辑。</p><p>如果项目没有特定的需求，妥善使用 @Around 注解就能帮你解决一切问题。</p><pre><code>@Around(&quot;operationLogAspect()&quot;)
public Object doAround(ProceedingJoinPoint point) {
    logger.info(&quot;Around:{}&quot;, point);
    Object proceed = null;
    try {
        proceed = point.proceed();

        Object pointTarget = point.getTarget();
        Signature pointSignature = point.getSignature();

        String targetName = pointTarget.getClass().getName();
        String methodName = pointSignature.getName();
        Method method = pointTarget.getClass().getMethod(pointSignature.getName(), ((MethodSignature) pointSignature).getParameterTypes());
        OperationLog methodAnnotation = method.getAnnotation(OperationLog.class);
        String operationModular = methodAnnotation.operationModular();
        String operationContent = methodAnnotation.operationContent();

        OperationLogPO log = new OperationLogPO();
        log.setOperUserid(SecureUtil.simpleUUID());
        log.setOperUserip(HttpUtil.getClientIP(getHttpReq()));
        log.setOperModular(operationModular);
        log.setOperContent(operationContent);
        log.setOperClass(targetName);
        log.setOperMethod(methodName);
        log.setOperTime(new Date());
        log.setOperResult(&quot;Y&quot;);
        operationLogService.insert(log);
    } catch (Throwable throwable) {
        throwable.printStackTrace();
        logger.error(&quot;日志 aop 异常信息:{}&quot;, throwable.getMessage());
    }
    return proceed;
}
</code></pre><p>别忘记将上面切点处理类/和要切入的类托管给 Spring，Aop 日志是不是很简单，复杂的应该是 aspectj 内部实现机制，有机会要看看源码哦。</p><p>处理切点类完整代码：<br><img src="/2017/1427/8200ed7.gif" alt=""><img src="/wp-content/uploads/2017/07/1501508453.gif" alt=""><br>@Aspect<br>@Component<br>publicclass OperationLogAspect {<br>privatestaticfinal Logger logger = LoggerFactory.getLogger(OperationLogAspect.class);</p><pre><code>    //ProceedingJoinPoint 与 JoinPoint
    //注入Service用于把日志保存数据库
    //这里我用resource注解，一般用的是@Autowired，他们的区别如有时间我会在后面的博客中来写    @Resource
    private OperationLogService operationLogService;

    //@Pointcut(&quot;execution (* com.rambo.spm.*.controller..*.*(..))&quot;)
    @Pointcut(&quot;@annotation(com.rambo.spm.common.aop.OperationLog)&quot;)
    publicvoid operationLogAspect() {

    }


    @Before(&quot;operationLogAspect()&quot;)
    publicvoid doBefore(JoinPoint joinPoint) {
        logger.info(&quot;before aop：{}&quot;, joinPoint);
        gePointMsg(joinPoint);
    }

    @Around(&quot;operationLogAspect()&quot;)
    public Object doAround(ProceedingJoinPoint point) {
        logger.info(&quot;Around:{}&quot;, point);
        Object proceed = null;
        try {
            proceed = point.proceed();

            Object pointTarget = point.getTarget();
            Signature pointSignature = point.getSignature();

            String targetName = pointTarget.getClass().getName();
            String methodName = pointSignature.getName();
            Method method = pointTarget.getClass().getMethod(pointSignature.getName(), ((MethodSignature) pointSignature).getParameterTypes());
            OperationLog methodAnnotation = method.getAnnotation(OperationLog.class);
            String operationModular = methodAnnotation.operationModular();
            String operationContent = methodAnnotation.operationContent();

            OperationLogPO log = new OperationLogPO();
            log.setOperUserid(SecureUtil.simpleUUID());
            log.setOperUserip(HttpUtil.getClientIP(getHttpReq()));
            log.setOperModular(operationModular);
            log.setOperContent(operationContent);
            log.setOperClass(targetName);
            log.setOperMethod(methodName);
            log.setOperTime(new Date());
            log.setOperResult(&quot;Y&quot;);
            operationLogService.insert(log);
        } catch (Throwable throwable) {
            throwable.printStackTrace();
            logger.error(&quot;日志 aop 异常信息:{}&quot;, throwable.getMessage());
        }
        return proceed;
    }

    @AfterThrowing(&quot;operationLogAspect()&quot;)
    publicvoid doAfterThrowing(JoinPoint pjp) {
        logger.info(&quot;@AfterThrowing:{}&quot;, pjp);

    }

    @After(&quot;operationLogAspect()&quot;)
    publicvoid doAfter(JoinPoint pjp) {
        logger.info(&quot;@After:{}&quot;, pjp);
    }

    @AfterReturning(&quot;operationLogAspect()&quot;)
    publicvoid doAfterReturning(JoinPoint point) {
        logger.info(&quot;@AfterReturning:{}&quot;, point);
    }

    privatevoid gePointMsg(JoinPoint joinPoint) {
        logger.info(&quot;切点所在位置:{}&quot;, joinPoint.toString());
        logger.info(&quot;切点所在位置的简短信息:{}&quot;, joinPoint.toShortString());
        logger.info(&quot;切点所在位置的全部信息:{}&quot;, joinPoint.toLongString());
        logger.info(&quot;切点AOP代理对象:{}&quot;, joinPoint.getThis());
        logger.info(&quot;切点目标对象:{}&quot;, joinPoint.getTarget());
        logger.info(&quot;切点被通知方法参数列表:{}&quot;, joinPoint.getArgs());
        logger.info(&quot;切点签名:{}&quot;, joinPoint.getSignature());
        logger.info(&quot;切点方法所在类文件中位置:{}&quot;, joinPoint.getSourceLocation());
        logger.info(&quot;切点类型:{}&quot;, joinPoint.getKind());
        logger.info(&quot;切点静态部分:{}&quot;, joinPoint.getStaticPart());
    }

    private HttpServletRequest getHttpReq() {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) requestAttributes;
        return servletRequestAttributes.getRequest();
    }
}
</code></pre><p>View Code<br>上述三步骤之后，你就可以在想记录日志的方法上面添加注解来进行记录操作日志，像下面这样。</p><p><img src="/2017/1427/c738520.png" alt=""></p><pre><code>源码托管地址：[https://git.oschina.net/LanboEx/spmvc-mybatis.git](https://www.jfox.info/go.php?url=https://git.oschina.net/LanboEx/spmvc-mybatis.git)  有这方面需求和兴趣的可以检出到本地跑一跑。
</code></pre></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2017/rxjava2入门教程四scheduler线程调度器.html" rel="next" title="Rxjava2入门教程四：Scheduler线程调度器"><i class="fa fa-chevron-left"></i> Rxjava2入门教程四：Scheduler线程调度器</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2017/nodejs基金会2017用户调查报告近一半用户是菜鸟.html" rel="prev" title="Node.js基金会2017用户调查报告：近一半用户是菜鸟">Node.js基金会2017用户调查报告：近一半用户是菜鸟 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">1358</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->