<!-- build time:Sat Oct 27 2018 19:38:33 GMT+0800 (CST) --><!DOCTYPE html><html class="theme-next muse use-motion"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="description" content="H2M_LI_HEADER Spring 的事物是通过哪些原理实现的?H2M_LI_HEADER Spring 的事物机制是如何提交和回滚的?==希望你有阅读过 Spring 源码的经历,不然有的东西可能理解不清楚..==Spring 的事物是通过哪些原理实现的?首先给大家布置一个代码场景(以项目代码为例):spring-dataSource.xml 文件     &amp;lt;bean id=&amp;quo"><meta name="keywords" content="JAVA,面试"><meta property="og:type" content="article"><meta property="og:title" content="回眸Spring – 事物运行原理机制"><meta property="og:url" content="http://www.jfox.info/2018/2443f3f/index.html"><meta property="og:site_name" content="java面试"><meta property="og:description" content="H2M_LI_HEADER Spring 的事物是通过哪些原理实现的?H2M_LI_HEADER Spring 的事物机制是如何提交和回滚的?==希望你有阅读过 Spring 源码的经历,不然有的东西可能理解不清楚..==Spring 的事物是通过哪些原理实现的?首先给大家布置一个代码场景(以项目代码为例):spring-dataSource.xml 文件     &amp;lt;bean id=&amp;quo"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://www.jfox.info/2018/2443f3f/4c65d5d.png"><meta property="og:image" content="http://www.jfox.info/2018/2443f3f/c2c8a47.png"><meta property="og:image" content="http://www.jfox.info/2018/2443f3f/e7ce0f9.png"><meta property="og:image" content="http://www.jfox.info/2018/2443f3f/0058398.png"><meta property="og:image" content="http://www.jfox.info/2018/2443f3f/a52da6b.png"><meta property="og:image" content="http://www.jfox.info/2018/2443f3f/f31168b.png"><meta property="og:image" content="http://www.jfox.info/2018/2443f3f/3ef958b.png"><meta property="og:image" content="http://www.jfox.info/2018/2443f3f/6bf2383.png"><meta property="og:updated_time" content="2018-10-24T14:48:47.084Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="回眸Spring – 事物运行原理机制"><meta name="twitter:description" content="H2M_LI_HEADER Spring 的事物是通过哪些原理实现的?H2M_LI_HEADER Spring 的事物机制是如何提交和回滚的?==希望你有阅读过 Spring 源码的经历,不然有的东西可能理解不清楚..==Spring 的事物是通过哪些原理实现的?首先给大家布置一个代码场景(以项目代码为例):spring-dataSource.xml 文件     &amp;lt;bean id=&amp;quo"><meta name="twitter:image" content="http://www.jfox.info/2018/2443f3f/4c65d5d.png"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"Author"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://www.jfox.info/2018/2443f3f/"><title>回眸Spring – 事物运行原理机制 | java面试</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh_CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">java面试</span> <span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle"></p></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>Archives</a></li></ul></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://www.jfox.info/2018/2443f3f/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Hello"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="java面试"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">回眸Spring – 事物运行原理机制</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-07T00:44:59+08:00">2018-09-07</time></span></div></header><div class="post-body" itemprop="articleBody"><p>H2M_LI_HEADER Spring 的事物是通过哪些原理实现的?<br>H2M_LI_HEADER Spring 的事物机制是如何提交和回滚的?</p><p><strong>==希望你有阅读过 Spring 源码的经历,不然有的东西可能理解不清楚..==</strong></p><h3 id="Spring-的事物是通过哪些原理实现的"><a href="#Spring-的事物是通过哪些原理实现的" class="headerlink" title="Spring 的事物是通过哪些原理实现的?"></a>Spring 的事物是通过哪些原理实现的?</h3><p>首先给大家布置一个代码场景(以项目代码为例):</p><p>spring-dataSource.xml 文件</p><pre><code>     &lt;bean id=&quot;db1&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;     destroy-method=&quot;close&quot;&gt;
         ....
    &lt;/bean&gt;
    &lt;!-- 数据源配置 --&gt;
    &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;db1&quot;/&gt;
    &lt;qualifier value=&quot;&quot;/&gt;
&lt;/bean&gt;

&lt;!-- 事物管理器 --&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;
    proxy-target-class=&quot;true&quot;&gt;&lt;/tx:annotation-driven&gt;
</code></pre><p>Spring-service.xml</p><pre><code>&lt;!-- 注解扫描包 --&gt;
 &lt;context:component-scan base-package=&quot;com.elab.execute.services,com.elab.execute.dao,com.elab.execute.utils&quot;&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt;
        &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Component&quot;/&gt;
        &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt;
    &lt;/context:component-scan&gt;
</code></pre><p>Serivce.java</p><pre><code>    //方法上只要加上@Transactional方法就行了,一个DML操作
    @Transactional
    public void testTransactional() throws Exception {
        System.out.println(&quot;=====================开始处理事物&quot;);
        TGirl girl = new TGirl();
        girl.setAge(11);
        girl.setGirl_name(&quot;hah&quot;);
        girl.setStatus(1);
        int insert = girlMapper.insert(girl);
        System.out.println(&quot;=====================结束处理事物&quot;);
        System.out.println(&quot;处理完成...&quot;);
        // 模拟程序报错
//        int i = 1 / 0;
    }
</code></pre><p><strong>==注意我们这只是模拟一个简单的事物管理配置场景,大概就是这么一些要配置的东西==</strong></p><p>测试类: 我没有用 Junit,不过效果是差不多的</p><pre><code>String xml[] = new String[]{&quot;applicationContext-service.xml&quot;, &quot;applicationContext-datasource.xml&quot;, };
        ApplicationContext app = new ClassPathXmlApplicationContext(xml);
        IDemoService demoService = (IDemoService) app.getBean(&quot;demoService&quot;);
        // DML操作
        demoService.testTransactional();
</code></pre><p>首先我们的目的是想知道 Spring 事物的运行流程,这时候可能就需要 Debug 调试,我们也就只关注事物这块初始化和执行的情况,我们可以采用<strong>倒推</strong>的方式<br><strong>先看 spring 事物的执行过程,再看初始化过程</strong></p><ol><li>debug 断点打在 demoService.testTransactional(); 这块,然后 F5 进去<br><img src="/2018/2443f3f/4c65d5d.png" alt=""><br>image</li></ol><p>进入到的是一个 CglibAopProxy 内部类<strong>DynamicAdvisedInterceptor</strong>的<strong>intercept</strong>方法,从这里看的话,其实这个类就是一个责任链类型的处理类</p><p>注意这一块是一个<strong>责任链模式</strong>,表示需要经过一系列链条之后才会到达最终的方法,<strong>当然这三个类切入点类型的类,是通过动态代理加入到责任链中的,下面初始化的时候会讲到</strong></p><pre><code>  // 这一段代码表示获取到你将要执行最终方法前要经过的一系列拦截类的处理,也就是责任链类的中的核心集合
List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
</code></pre><p><img src="/2018/2443f3f/c2c8a47.png" alt=""></p><p>image</p><p>图中 chain 集合有三个类,表示执行到目的方法之前需要经过这几个类</p><p>我们来看到执行到目标方法的执行轨迹:</p><p><img src="/2018/2443f3f/e7ce0f9.png" alt=""></p><p>image</p><p>确实是经过了三个拦截链</p><p>我们直接看事物相关的拦截链类</p><p>下面代码是不是似曾相识,这都是开启事物的操作和异常情况下,回滚和提交操作</p><p><img src="/2018/2443f3f/0058398.png" alt=""></p><p>image</p><p>经过这些代理类之后到达最终的方法,这是一个大概的运行过程.异常会被事物捕获到,没有则提交… 都是通过这个 TransactionAspectSupport 的 invokeWithinTransaction 方法去做的</p><h3 id="那-Spring-又是如何初始化这一系列的代理类操作的呢"><a href="#那-Spring-又是如何初始化这一系列的代理类操作的呢" class="headerlink" title="那 Spring 又是如何初始化这一系列的代理类操作的呢?"></a>那 Spring 又是如何初始化这一系列的代理类操作的呢?</h3><p>回到运行的第一步我们在那个 Aop 的拦截器类中(CglibApoProxy),想一想既然 spring 运行这个方法的时候会执行这个拦截器方法,那么初始化的时候应该也和这个类相关,然后从上面实例化的地方和可以的地方打打断点…</p><p>果然,初始化的方法断点被触发了…</p><p><img src="/2018/2443f3f/a52da6b.png" alt=""></p><p>image</p><p>这时候我们可以看断点的运行轨迹</p><p><img src="/2018/2443f3f/f31168b.png" alt=""></p><p>image</p><p>我们发现,触发到这个断点的时候,会经过一系列的方法执行,这些执行的方法链都是创建 bean 的时候必须经过的过程,也就是说每个 bean 创建的时候,都会经过这一系列的链路的检查(applyBeanPostProcessorsAfterInitialization 方法里面的 getBeanPostProcessors()方法),才会生成最终的 bean,这时候我们需要定位到执行这个 CglibAopProxy 初始化的方法这块,<strong>在什么情况下</strong>,会执行这个创建代理的类</p><p><img src="/2018/2443f3f/3ef958b.png" alt=""></p><p>image</p><p>我们现在已经知道他创建了代理类的过程,现在需要知道在什么情况下会为某些 bean 创建代理。了解了 getAdvicesAndAdvisorsForBean 这个方法运行做了什么事情,就大概知道创建代理类 bean 的条件</p><p>首先我们一步步看这个方法的代码:</p><pre><code>/**
    这是一个获取切入点和包含切入点的bean方法
/*
protected Object[] getAdvicesAndAdvisorsForBean(Class&lt;?&gt; beanClass, String beanName, TargetSource targetSource) {
    // 查询当前的bean是否包含切入点
    List&lt;Advisor&gt; advisors = findEligibleAdvisors(beanClass, beanName);
    if (advisors.isEmpty()) {
        return DO_NOT_PROXY;
    }
    return advisors.toArray();
}
</code></pre><p>findEligibleAdvisors 方法</p><pre><code>/**
 * 大概意思是为这个bean找到合适的自动代理类
 * Find all eligible Advisors for auto-proxying this class.
 * @param beanClass the clazz to find advisors for
 * @param beanName the name of the currently proxied bean
 * @return the empty List, not {@code null},
 * if there are no pointcuts or interceptors
 * @see #findCandidateAdvisors
 * @see #sortAdvisors
 * @see #extendAdvisors
 */
protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) {
    // 找到当前已经注册好的代理类bean
    List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();
    //将注册好的bean和当前bean的类型进行搜索查询,是否有合适的切入点类
    List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName);
    extendAdvisors(eligibleAdvisors);
    if (!eligibleAdvisors.isEmpty()) {
        eligibleAdvisors = sortAdvisors(eligibleAdvisors);
    }
    return eligibleAdvisors;
}
</code></pre><p>findAdvisorsThatCanApply :</p><pre><code>   /**
   大概意思就是搜索给定的切入点集合,以用于找到可以应用到当前bean的合适的切入点集合
 * Search the given candidate Advisors to find all Advisors that
 * can apply to the specified bean.
 * @param candidateAdvisors the candidate Advisors
 * @param beanClass the target&apos;s bean class
 * @param beanName the target&apos;s bean name
 * @return the List of applicable Advisors
 * @see ProxyCreationContext#getCurrentProxiedBeanName()
 */
protected List&lt;Advisor&gt; findAdvisorsThatCanApply(
        List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; beanClass, String beanName) {
            // 设置代理的上下文,只针当前线程
    ProxyCreationContext.setCurrentProxiedBeanName(beanName);
    try {
        // 这是一个AOP的工具类,用于
        return AopUtils.findAdvisorsThatCanApply(candidateAdvisors, beanClass);
    }
    finally {
        ProxyCreationContext.setCurrentProxiedBeanName(null);
    }
}
</code></pre><p>AopUtils.findAdvisorsThatCanApply</p><pre><code>/**
 * 确定能应用到当前clazz的List&lt;Advisor&gt;
 * Determine the sublist of the {@code candidateAdvisors} list
 * that is applicable to the given class.
 * @param candidateAdvisors the Advisors to evaluate
 * @param clazz the target class
 * @return sublist of Advisors that can apply to an object of the given class
 * (may be the incoming List as-is)
 */
public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) {
    if (candidateAdvisors.isEmpty()) {
        return candidateAdvisors;
    }
    List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;Advisor&gt;();
    for (Advisor candidate : candidateAdvisors) {
        if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) {
            eligibleAdvisors.add(candidate);
        }
    }
    boolean hasIntroductions = !eligibleAdvisors.isEmpty();
    for (Advisor candidate : candidateAdvisors) {
        if (candidate instanceof IntroductionAdvisor) {
            // already processed
            continue;
        }
                     // 这个方法很关键,用于判断是否能将当前Advisor应用到这个bean上
        if (canApply(candidate, clazz, hasIntroductions)) {
            // 如果验证通过,则会将当前切入点加入进来
            eligibleAdvisors.add(candidate);
        }
    }
    return eligibleAdvisors;
}
</code></pre><p>我们来看看 canApply 做了些什么?</p><pre><code>// 大概就是比较了Advisor的类型
public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
        if (advisor instanceof IntroductionAdvisor) {
            return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass);
        }
        else if (advisor instanceof PointcutAdvisor) {
            PointcutAdvisor pca = (PointcutAdvisor) advisor;
            // 最终会执行到这个方法
            return canApply(pca.getPointcut(), targetClass, hasIntroductions);
        }
        else {
            // It doesn&apos;t have a pointcut so we assume it applies.
            return true;
        }
    }

    public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) {
        Assert.notNull(pc, &quot;Pointcut must not be null&quot;);
        if (!pc.getClassFilter().matches(targetClass)) {
            return false;
        }
                // 获取当前切入点的类型
        MethodMatcher methodMatcher = pc.getMethodMatcher();
        IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null;
                //比较类型
        if (methodMatcher instanceof IntroductionAwareMethodMatcher) {
            introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher;
        }


                // !!!!! 这一部分的代码很关键!!!!
                // 获取所有相关的类
        Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;Class&lt;?&gt;&gt;(ClassUtils.getAllInterfacesForClassAsSet(targetClass));
        classes.add(targetClass);
                // 遍历这些类
        for (Class&lt;?&gt; clazz : classes) {
                        // 获取类的所有方法
            Method[] methods = clazz.getMethods();
                      // 遍历这些方法
            for (Method method : methods) {
                    //methodMatcher.matches(method, targetClass) 这个方法很重要
                if ((introductionAwareMethodMatcher != null &amp;&amp;
                        introductionAwareMethodMatcher.matches(method, targetClass, hasIntroductions)) ||
                        methodMatcher.matches(method, targetClass)) {
                    return true;
                }
            }
        }

        return false;
    }
</code></pre><p>matches 方法</p><pre><code> public boolean matches(Method method, Class&lt;?&gt; targetClass) {
    TransactionAttributeSource tas = getTransactionAttributeSource();
    // tas.getTransactionAttribute(method, targetClass)  这是个获取事物注解的方法
    return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);
}




// 获取事务属性的方法
public TransactionAttribute getTransactionAttribute(Method method, Class&lt;?&gt; targetClass) {
    // First, see if we have a cached value.
    Object cacheKey = getCacheKey(method, targetClass);
    Object cached = this.attributeCache.get(cacheKey);
    if (cached != null) {
        // Value will either be canonical value indicating there is no transaction attribute,
        // or an actual transaction attribute.
        if (cached == NULL_TRANSACTION_ATTRIBUTE) {
            return null;
        }
        else {
            return (TransactionAttribute) cached;
        }
    }
    else {
        // We need to work it out.
        // 获取事物属性的方法
        TransactionAttribute txAtt = computeTransactionAttribute(method, targetClass);
        // Put it in the cache.
        if (txAtt == null) {
            this.attributeCache.put(cacheKey, NULL_TRANSACTION_ATTRIBUTE);
        }
        else {
            if (logger.isDebugEnabled()) {
                Class&lt;?&gt; classToLog = (targetClass != null ? targetClass : method.getDeclaringClass());
                logger.debug(&quot;Adding transactional method &apos;&quot; + classToLog.getSimpleName() + &quot;.&quot; +
                        method.getName() + &quot;&apos; with attribute: &quot; + txAtt);
            }
            this.attributeCache.put(cacheKey, txAtt);
        }
        return txAtt;
    }
}

private TransactionAttribute computeTransactionAttribute(Method method, Class&lt;?&gt; targetClass) {
    // Don&apos;t allow no-public methods as required.
    if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) {
        return null;
    }

    // Ignore CGLIB subclasses - introspect the actual user class.
    Class&lt;?&gt; userClass = ClassUtils.getUserClass(targetClass);
    // The method may be on an interface, but we need attributes from the target class.
    // If the target class is null, the method will be unchanged.
    Method specificMethod = ClassUtils.getMostSpecificMethod(method, userClass);
    // If we are dealing with method with generic parameters, find the original method.
    specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);

    // First try is the method in the target class.
    // 查找该方法的事物属性
    TransactionAttribute txAtt = findTransactionAttribute(specificMethod);
    if (txAtt != null) {
        return txAtt;
    }

    // Second try is the transaction attribute on the target class.
    txAtt = findTransactionAttribute(specificMethod.getDeclaringClass());
    if (txAtt != null) {
        return txAtt;
    }

    if (specificMethod != method) {
        // Fallback is to look at the original method.
        txAtt = findTransactionAttribute(method);
        if (txAtt != null) {
            return txAtt;
        }
        // Last fallback is the class of the original method.
        return findTransactionAttribute(method.getDeclaringClass());
    }
    return null;
}
</code></pre><p>详细看下 findTransactionAttribute 方法,由于比较深我就直接贴最终执行的方法了</p><pre><code>public TransactionAttribute parseTransactionAnnotation(AnnotatedElement ae) {
        // 查看是否方法上面有@Transactional注解
        AnnotationAttributes ann = AnnotatedElementUtils.getAnnotationAttributes(ae, Transactional.class.getName());
        if (ann != null) {
            return parseTransactionAnnotation(ann);
        }
        else {
            return null;
        }
    }
    // 处理这个注解所包含的属性如传播途径和隔离级别
    protected TransactionAttribute parseTransactionAnnotation(AnnotationAttributes attributes) {
        RuleBasedTransactionAttribute rbta = new RuleBasedTransactionAttribute();
        Propagation propagation = attributes.getEnum(&quot;propagation&quot;);
        rbta.setPropagationBehavior(propagation.value());
        Isolation isolation = attributes.getEnum(&quot;isolation&quot;);
        rbta.setIsolationLevel(isolation.value());
        rbta.setTimeout(attributes.getNumber(&quot;timeout&quot;).intValue());
        rbta.setReadOnly(attributes.getBoolean(&quot;readOnly&quot;));
        rbta.setQualifier(attributes.getString(&quot;value&quot;));
        ArrayList&lt;RollbackRuleAttribute&gt; rollBackRules = new ArrayList&lt;RollbackRuleAttribute&gt;();
        Class&lt;?&gt;[] rbf = attributes.getClassArray(&quot;rollbackFor&quot;);
        for (Class&lt;?&gt; rbRule : rbf) {
            RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);
            rollBackRules.add(rule);
        }
        String[] rbfc = attributes.getStringArray(&quot;rollbackForClassName&quot;);
        for (String rbRule : rbfc) {
            RollbackRuleAttribute rule = new RollbackRuleAttribute(rbRule);
            rollBackRules.add(rule);
        }
        Class&lt;?&gt;[] nrbf = attributes.getClassArray(&quot;noRollbackFor&quot;);
        for (Class&lt;?&gt; rbRule : nrbf) {
            NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);
            rollBackRules.add(rule);
        }
        String[] nrbfc = attributes.getStringArray(&quot;noRollbackForClassName&quot;);
        for (String rbRule : nrbfc) {
            NoRollbackRuleAttribute rule = new NoRollbackRuleAttribute(rbRule);
            rollBackRules.add(rule);
        }
        rbta.getRollbackRules().addAll(rollBackRules);
        return rbta;
    }
</code></pre><p>这时候我们就可以大概的清楚知道哪些 bean 需要被事物代理的原因了<br>这时候我们在回过头来看 spring 是如何构建代理类的,这里我就不在详细各种贴流程代码了,只贴关键的</p><pre><code>DefaultAopProxyFactory 默认的AOP代理工厂


// 创建一个AopProxy的代理类,它这里提供了两种代理方式,一种是JDK代理,一种是CGlib代理
public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
            if (config.isOptimize() || config.isProxyTargetClass() ||
            hasNoUserSuppliedProxyInterfaces(config)) {
            Class&lt;?&gt; targetClass = config.getTargetClass();
            if (targetClass == null) {
                throw new AopConfigException(&quot;TargetSource cannot determine target class: &quot; +
                        &quot;Either an interface or a target is required for proxy creation.&quot;);
            }
            // 如果需要代理的类是接口的时候采用JDK
            if (targetClass.isInterface()) {
                return new JdkDynamicAopProxy(config);
            }
            // 普通类用CGlib代理
            return new ObjenesisCglibAopProxy(config);
        }
        else {
            return new JdkDynamicAopProxy(config);
        }
    }
</code></pre><p>ObjenesisCglibAopProxy 的 父类是 CglibAopProxy 所以初始化 ObjenesisCglibAopProxy 的构造方法时会调用 super(config);</p><pre><code>/**
* 实例化Cglib对象时,会初始化他的父类方法,并且把拦截器传递给父类,告诉他的需要加上代理的拦截器,也就是我们的TransactionInterceptor,如果有多个的话可能就会代理多个,这里我们只看事物的
*
*/
public ObjenesisCglibAopProxy(AdvisedSupport config) {
    super(config);
    this.objenesis = new ObjenesisStd(true);
}
</code></pre><p>初始化完成之后会调用它的 ObjenesisCglibAopProxy 的 getProxy()方法,这个方法是它的父类实现的,这里面才是真正实现了真正代理的对象,原理是构成一个责任链,将代理一个个链接起来</p><pre><code>public Object getProxy(ClassLoader classLoader) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Creating CGLIB proxy: target source is &quot; + this.advised.getTargetSource());
        }
        try {
            Class&lt;?&gt; rootClass = this.advised.getTargetClass();
            Assert.state(rootClass != null, &quot;Target class must be available for creating a CGLIB proxy&quot;);
            Class&lt;?&gt; proxySuperClass = rootClass;
            if (ClassUtils.isCglibProxyClass(rootClass)) {
                proxySuperClass = rootClass.getSuperclass();
                Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();
                for (Class&lt;?&gt; additionalInterface : additionalInterfaces) {
                    this.advised.addInterface(additionalInterface);
                }
            }
            // Validate the class, writing log messages as necessary.
            validateClassIfNecessary(proxySuperClass, classLoader);
            // Configure CGLIB Enhancer...
            // 这一部分是创建一个Enhancer 对象
            Enhancer enhancer = createEnhancer();
            if (classLoader != null) {
                enhancer.setClassLoader(classLoader);
                if (classLoader instanceof SmartClassLoader &amp;&amp;
                        ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
                    enhancer.setUseCache(false);
                }
            }
            enhancer.setSuperclass(proxySuperClass);
            enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
            enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
            enhancer.setStrategy(new UndeclaredThrowableStrategy(UndeclaredThrowableException.class));

            // 这部分代码非常关键,里面会创建一个DynamicAdvisedInterceptor对象,这个就是责任链的头端,所有的切入点都需要经过这个拦截器一步步执行到最终的方法
            Callback[] callbacks = getCallbacks(rootClass);
            Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length];
            for (int x = 0; x &lt; types.length; x++) {
                types[x] = callbacks[x].getClass();
            }
            // fixedInterceptorMap only populated at this point, after getCallbacks call above
            enhancer.setCallbackFilter(new ProxyCallbackFilter(
                    this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
            enhancer.setCallbackTypes(types);

            // Generate the proxy class and create a proxy instance.
            // 生成代理类并且创建实例,里面做的应该就是把DynamicAdvisedInterceptor对象和serviceImpl对象做了一个代理绑定,先进入DynamicAdvisedInterceptor,经过责任链模式一步步到达最终方法
            return createProxyClassAndInstance(enhancer, callbacks);
        }
        catch (CodeGenerationException ex) {
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; +
                    this.advised.getTargetClass() + &quot;]: &quot; +
                    &quot;Common causes of this problem include using a final class or a non-visible class&quot;,
                    ex);
        }
        catch (IllegalArgumentException ex) {
            throw new AopConfigException(&quot;Could not generate CGLIB subclass of class [&quot; +
                    this.advised.getTargetClass() + &quot;]: &quot; +
                    &quot;Common causes of this problem include using a final class or a non-visible class&quot;,
                    ex);
        }
        catch (Exception ex) {
            // TargetSource.getTarget() failed
            throw new AopConfigException(&quot;Unexpected AOP exception&quot;, ex);
        }
    }

private Callback[] getCallbacks(Class&lt;?&gt; rootClass) throws Exception {
        // Parameters used for optimisation choices...
        boolean exposeProxy = this.advised.isExposeProxy();
        boolean isFrozen = this.advised.isFrozen();
        boolean isStatic = this.advised.getTargetSource().isStatic();

        // Choose an &quot;aop&quot; interceptor (used for AOP calls).
        // 创建一个拦截器对象,所有被代理的类都走这个对象,最终返回的bean执行的起始方法
        Callback aopInterceptor = new DynamicAdvisedInterceptor(this.advised);

        // Choose a &quot;straight to target&quot; interceptor. (used for calls that are
        // unadvised but can return this). May be required to expose the proxy.
        Callback targetInterceptor;
        if (exposeProxy) {
            targetInterceptor = isStatic ?
                    new StaticUnadvisedExposedInterceptor(this.advised.getTargetSource().getTarget()) :
                    new DynamicUnadvisedExposedInterceptor(this.advised.getTargetSource());
        }
        else {
            targetInterceptor = isStatic ?
                    new StaticUnadvisedInterceptor(this.advised.getTargetSource().getTarget()) :
                    new DynamicUnadvisedInterceptor(this.advised.getTargetSource());
        }

        // Choose a &quot;direct to target&quot; dispatcher (used for
        // unadvised calls to static targets that cannot return this).
        Callback targetDispatcher = isStatic ?
                new StaticDispatcher(this.advised.getTargetSource().getTarget()) : new SerializableNoOp();

        Callback[] mainCallbacks = new Callback[]{
            aopInterceptor, // for normal advice
            targetInterceptor, // invoke target without considering advice, if optimized
            new SerializableNoOp(), // no override for methods mapped to this
            targetDispatcher, this.advisedDispatcher,
            new EqualsInterceptor(this.advised),
            new HashCodeInterceptor(this.advised)
        };

        Callback[] callbacks;

        // If the target is a static one and the advice chain is frozen,
        // then we can make some optimisations by sending the AOP calls
        // direct to the target using the fixed chain for that method.
        if (isStatic &amp;&amp; isFrozen) {
            Method[] methods = rootClass.getMethods();
            Callback[] fixedCallbacks = new Callback[methods.length];
            this.fixedInterceptorMap = new HashMap&lt;String, Integer&gt;(methods.length);

            // TODO: small memory optimisation here (can skip creation for methods with no advice)
            for (int x = 0; x &lt; methods.length; x++) {
                List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(methods[x], rootClass);
                fixedCallbacks[x] = new FixedChainStaticTargetInterceptor(
                        chain, this.advised.getTargetSource().getTarget(), this.advised.getTargetClass());
                this.fixedInterceptorMap.put(methods[x].toString(), x);
            }

            // Now copy both the callbacks from mainCallbacks
            // and fixedCallbacks into the callbacks array.
            callbacks = new Callback[mainCallbacks.length + fixedCallbacks.length];
            System.arraycopy(mainCallbacks, 0, callbacks, 0, mainCallbacks.length);
            System.arraycopy(fixedCallbacks, 0, callbacks, mainCallbacks.length, fixedCallbacks.length);
            this.fixedInterceptorOffset = mainCallbacks.length;
        }
        else {
            callbacks = mainCallbacks;
        }
        return callbacks;
    }


 最终生成了代理对象,将这个对象放入ioc容器当中,当调用这个对象时,ioc会直接取出代理对象,也就是先进入DynamicAdvisedInterceptor的intercept方法。
</code></pre><p>大概梳理一下事物的流程<br>一. 初始化流程</p><pre><code>1.首先开始初始化配置文件

2.然后执行到&lt;context:component-scan base-package=&quot;com.service&quot;&gt;&lt;/context:component-scan&gt;这里时,会开始扫描注解

3.当循环扫描到ServiceImpl的时候,会扫描每个方法,经过getAdvicesAndAdvisorsForBean这个方法时会判断每个方法是否触发代理的条件, 怎么触发代理条件, 这里以事物为例:
&lt;!--
这里注册了一个事物管理器,也就是说每个类都会经过这个事物管理器判断,是否有@Transactional方法;
需要注意的是,这个驱动相当于新加了一个方法环绕类型的切入点.
--&gt;
    &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;
proxy-target-class=&quot;true&quot;&gt;&lt;/tx:annotation-driven&gt;

  getAdvicesAndAdvisorsForBean如果返回有值时,则表示需要生成代理类

因为我们service中已经定义好了@Transactional方法了,所以触发了执行生成代理类的条件.

4. 生成代理类时,他主要做了两个步骤: 实现一个责任链的类[DynamicAdvisedInterceptor],然后将这个责任链类和service的实现类做绑定生成一个代理,然后返回这个代理对象到IOC容器中,初始化完成
</code></pre><p>二. 调用 service 的过程</p><pre><code>1. 当调用service这个实现类的时候,会从ioc容器里面去查找,找到了这个bean类则直接返回,注意这里的bean是一个代理类
2. 直接进入代理类DynamicAdvisedInterceptor的intercept方法里面;
3.  开始执行责任链机制,查找与这个类绑定的切入点


// 这里是直接查找与这个类相关的切入点,然后一个个执行完之后到达最终的service方法
List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);


4. 需要注意的是这个责任链中有一个TransactionAspectSupport类,这是一个事物的切入点类,这个类中的invokeWithinTransaction方法,它里面详细包含了事物的一系列操作,包括事物开启、提交、回滚等等一系列操作
5.  执行切入点后,直接到达目标方法,也就是service层的方法,service层的方法处理完毕,在回到invokeWithinTransaction判断是否报错,没有报错则事物提交,报错则进入到它的try/catch方法中进行回滚,最终执行完成;
</code></pre><p>最终我们总结上面的问题:</p><h4 id="Spring-的事物是通过哪些原理实现的-1"><a href="#Spring-的事物是通过哪些原理实现的-1" class="headerlink" title="Spring 的事物是通过哪些原理实现的?"></a>Spring 的事物是通过哪些原理实现的?</h4><p>动态代理 以及 切入点配合责任链组成的拦截器机制</p><h4 id="Spring-的事物机制是如何提交和回滚的"><a href="#Spring-的事物机制是如何提交和回滚的" class="headerlink" title="Spring 的事物机制是如何提交和回滚的?"></a>Spring 的事物机制是如何提交和回滚的?</h4><p>Spring 提供了一个事物管理器,这个事物管理器专门扫描所有方法的@Transactional 注解,一旦扫描到了,则会为这个方法的类设置代理,这个事物管理器可以理解为一个环绕类型的切入点,配合责任链模式,当方法执行的时候,会被拦截到 TransactionAspectSupport 的 invokeWithinTransaction 方法中,这个里面包含了事物的一系列操作。</p><h3 id="编后语"><a href="#编后语" class="headerlink" title="编后语"></a>编后语</h3><p>由于 spring 里面代码层次划分很细,导致贴出来的代码特别多,可能会影响你们阅读,不过 Spring 里面的很多东西封装的都是很完善的,几乎全部都是组件化,导致很多方法很深,不过我们只要了解它大概的原理就行了,至少能够在我们遇到问题时能够推断出从哪个步骤进行下手.可能这篇文章代码和图片比较凌乱,最好是大家有 spring 的一些基本原理基础,比如 bean 的实例化啊等等,不然有的地方会看不懂,好了就说这么多了… 希望对大家有帮助.. 也非常欢迎大家提意见!!! 谢谢</p><p><a href="https://itunes.apple.com/cn/app/学英语听新闻/id1368539116?mt=8" target="_blank" rel="noopener"><img src="/2018/2443f3f/6bf2383.png" alt=""></a></p></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="4142158067"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div style="width:300px;height:250px;float:left"><ins class="adsbygoogle" style="display:inline-block;width:300px;height:250px" data-ad-client="ca-pub-9477174171188196" data-ad-slot="5618891265"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><footer class="post-footer"><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2018/4ef2675/" rel="next" title="where子句的顺序在SQL中是否重要"><i class="fa fa-chevron-left"></i> where子句的顺序在SQL中是否重要</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2018/50f3d18/" rel="prev" title="node环境下如何使用jquery？">node环境下如何使用jquery？ <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article><div class="post-spread"></div></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">Overview</li></ul><section class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">Hello</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">238</span> <span class="site-state-item-name">posts</span></a></div></nav></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Spring-的事物是通过哪些原理实现的"><span class="nav-number">1.</span> <span class="nav-text">Spring 的事物是通过哪些原理实现的?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#那-Spring-又是如何初始化这一系列的代理类操作的呢"><span class="nav-number">2.</span> <span class="nav-text">那 Spring 又是如何初始化这一系列的代理类操作的呢?</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-的事物是通过哪些原理实现的-1"><span class="nav-number">2.1.</span> <span class="nav-text">Spring 的事物是通过哪些原理实现的?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Spring-的事物机制是如何提交和回滚的"><span class="nav-number">2.2.</span> <span class="nav-text">Spring 的事物机制是如何提交和回滚的?</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编后语"><span class="nav-number">3.</span> <span class="nav-text">编后语</span></a></li></ol></div></div></section></div></aside><div class="sfix"><div class="fixedme"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9477174171188196" data-ad-slot="9597600460" data-ad-format="auto"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Hello</span></div><div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div><span class="post-meta-divider">|</span><div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script></body></html><!-- rebuild by neat -->